"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/vaul";
exports.ids = ["vendor-chunks/vaul"];
exports.modules = {

/***/ "(ssr)/./node_modules/vaul/dist/index.mjs":
/*!******************************************!*\
  !*** ./node_modules/vaul/dist/index.mjs ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Content: () => (/* binding */ Content),\n/* harmony export */   Drawer: () => (/* binding */ Drawer),\n/* harmony export */   Handle: () => (/* binding */ Handle),\n/* harmony export */   NestedRoot: () => (/* binding */ NestedRoot),\n/* harmony export */   Overlay: () => (/* binding */ Overlay),\n/* harmony export */   Portal: () => (/* binding */ Portal),\n/* harmony export */   Root: () => (/* binding */ Root)\n/* harmony export */ });\n/* harmony import */ var _radix_ui_react_dialog__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @radix-ui/react-dialog */ \"(ssr)/./node_modules/@radix-ui/react-dialog/dist/index.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* __next_internal_client_entry_do_not_use__ Content,Drawer,Handle,NestedRoot,Overlay,Portal,Root auto */ function __insertCSS(code) {\n    if (!code || typeof document == 'undefined') return;\n    let head = document.head || document.getElementsByTagName('head')[0];\n    let style = document.createElement('style');\n    style.type = 'text/css';\n    head.appendChild(style);\n    style.styleSheet ? style.styleSheet.cssText = code : style.appendChild(document.createTextNode(code));\n}\n\n\n\nconst DrawerContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext({\n    drawerRef: {\n        current: null\n    },\n    overlayRef: {\n        current: null\n    },\n    onPress: ()=>{},\n    onRelease: ()=>{},\n    onDrag: ()=>{},\n    onNestedDrag: ()=>{},\n    onNestedOpenChange: ()=>{},\n    onNestedRelease: ()=>{},\n    openProp: undefined,\n    dismissible: false,\n    isOpen: false,\n    isDragging: false,\n    keyboardIsOpen: {\n        current: false\n    },\n    snapPointsOffset: null,\n    snapPoints: null,\n    handleOnly: false,\n    modal: false,\n    shouldFade: false,\n    activeSnapPoint: null,\n    onOpenChange: ()=>{},\n    setActiveSnapPoint: ()=>{},\n    closeDrawer: ()=>{},\n    direction: 'bottom',\n    shouldAnimate: {\n        current: true\n    },\n    shouldScaleBackground: false,\n    setBackgroundColorOnScale: true,\n    noBodyStyles: false,\n    container: null,\n    autoFocus: false\n});\nconst useDrawerContext = ()=>{\n    const context = react__WEBPACK_IMPORTED_MODULE_0__.useContext(DrawerContext);\n    if (!context) {\n        throw new Error('useDrawerContext must be used within a Drawer.Root');\n    }\n    return context;\n};\n__insertCSS(\"[data-vaul-drawer]{touch-action:none;will-change:transform;transition:transform .5s cubic-bezier(.32, .72, 0, 1);animation-duration:.5s;animation-timing-function:cubic-bezier(0.32,0.72,0,1)}[data-vaul-drawer][data-vaul-snap-points=false][data-vaul-drawer-direction=bottom][data-state=open]{animation-name:slideFromBottom}[data-vaul-drawer][data-vaul-snap-points=false][data-vaul-drawer-direction=bottom][data-state=closed]{animation-name:slideToBottom}[data-vaul-drawer][data-vaul-snap-points=false][data-vaul-drawer-direction=top][data-state=open]{animation-name:slideFromTop}[data-vaul-drawer][data-vaul-snap-points=false][data-vaul-drawer-direction=top][data-state=closed]{animation-name:slideToTop}[data-vaul-drawer][data-vaul-snap-points=false][data-vaul-drawer-direction=left][data-state=open]{animation-name:slideFromLeft}[data-vaul-drawer][data-vaul-snap-points=false][data-vaul-drawer-direction=left][data-state=closed]{animation-name:slideToLeft}[data-vaul-drawer][data-vaul-snap-points=false][data-vaul-drawer-direction=right][data-state=open]{animation-name:slideFromRight}[data-vaul-drawer][data-vaul-snap-points=false][data-vaul-drawer-direction=right][data-state=closed]{animation-name:slideToRight}[data-vaul-drawer][data-vaul-snap-points=true][data-vaul-drawer-direction=bottom]{transform:translate3d(0,var(--initial-transform,100%),0)}[data-vaul-drawer][data-vaul-snap-points=true][data-vaul-drawer-direction=top]{transform:translate3d(0,calc(var(--initial-transform,100%) * -1),0)}[data-vaul-drawer][data-vaul-snap-points=true][data-vaul-drawer-direction=left]{transform:translate3d(calc(var(--initial-transform,100%) * -1),0,0)}[data-vaul-drawer][data-vaul-snap-points=true][data-vaul-drawer-direction=right]{transform:translate3d(var(--initial-transform,100%),0,0)}[data-vaul-drawer][data-vaul-delayed-snap-points=true][data-vaul-drawer-direction=top]{transform:translate3d(0,var(--snap-point-height,0),0)}[data-vaul-drawer][data-vaul-delayed-snap-points=true][data-vaul-drawer-direction=bottom]{transform:translate3d(0,var(--snap-point-height,0),0)}[data-vaul-drawer][data-vaul-delayed-snap-points=true][data-vaul-drawer-direction=left]{transform:translate3d(var(--snap-point-height,0),0,0)}[data-vaul-drawer][data-vaul-delayed-snap-points=true][data-vaul-drawer-direction=right]{transform:translate3d(var(--snap-point-height,0),0,0)}[data-vaul-overlay][data-vaul-snap-points=false]{animation-duration:.5s;animation-timing-function:cubic-bezier(0.32,0.72,0,1)}[data-vaul-overlay][data-vaul-snap-points=false][data-state=open]{animation-name:fadeIn}[data-vaul-overlay][data-state=closed]{animation-name:fadeOut}[data-vaul-animate=false]{animation:none!important}[data-vaul-overlay][data-vaul-snap-points=true]{opacity:0;transition:opacity .5s cubic-bezier(.32, .72, 0, 1)}[data-vaul-overlay][data-vaul-snap-points=true]{opacity:1}[data-vaul-drawer]:not([data-vaul-custom-container=true])::after{content:'';position:absolute;background:inherit;background-color:inherit}[data-vaul-drawer][data-vaul-drawer-direction=top]::after{top:initial;bottom:100%;left:0;right:0;height:200%}[data-vaul-drawer][data-vaul-drawer-direction=bottom]::after{top:100%;bottom:initial;left:0;right:0;height:200%}[data-vaul-drawer][data-vaul-drawer-direction=left]::after{left:initial;right:100%;top:0;bottom:0;width:200%}[data-vaul-drawer][data-vaul-drawer-direction=right]::after{left:100%;right:initial;top:0;bottom:0;width:200%}[data-vaul-overlay][data-vaul-snap-points=true]:not([data-vaul-snap-points-overlay=true]):not(\\n[data-state=closed]\\n){opacity:0}[data-vaul-overlay][data-vaul-snap-points-overlay=true]{opacity:1}[data-vaul-handle]{display:block;position:relative;opacity:.7;background:#e2e2e4;margin-left:auto;margin-right:auto;height:5px;width:32px;border-radius:1rem;touch-action:pan-y}[data-vaul-handle]:active,[data-vaul-handle]:hover{opacity:1}[data-vaul-handle-hitarea]{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);width:max(100%,2.75rem);height:max(100%,2.75rem);touch-action:inherit}@media (hover:hover) and (pointer:fine){[data-vaul-drawer]{user-select:none}}@media (pointer:fine){[data-vaul-handle-hitarea]:{width:100%;height:100%}}@keyframes fadeIn{from{opacity:0}to{opacity:1}}@keyframes fadeOut{to{opacity:0}}@keyframes slideFromBottom{from{transform:translate3d(0,var(--initial-transform,100%),0)}to{transform:translate3d(0,0,0)}}@keyframes slideToBottom{to{transform:translate3d(0,var(--initial-transform,100%),0)}}@keyframes slideFromTop{from{transform:translate3d(0,calc(var(--initial-transform,100%) * -1),0)}to{transform:translate3d(0,0,0)}}@keyframes slideToTop{to{transform:translate3d(0,calc(var(--initial-transform,100%) * -1),0)}}@keyframes slideFromLeft{from{transform:translate3d(calc(var(--initial-transform,100%) * -1),0,0)}to{transform:translate3d(0,0,0)}}@keyframes slideToLeft{to{transform:translate3d(calc(var(--initial-transform,100%) * -1),0,0)}}@keyframes slideFromRight{from{transform:translate3d(var(--initial-transform,100%),0,0)}to{transform:translate3d(0,0,0)}}@keyframes slideToRight{to{transform:translate3d(var(--initial-transform,100%),0,0)}}\");\nfunction isMobileFirefox() {\n    const userAgent = navigator.userAgent;\n    return  false && (0 // iOS Firefox\n    );\n}\nfunction isMac() {\n    return testPlatform(/^Mac/);\n}\nfunction isIPhone() {\n    return testPlatform(/^iPhone/);\n}\nfunction isSafari() {\n    return /^((?!chrome|android).)*safari/i.test(navigator.userAgent);\n}\nfunction isIPad() {\n    return testPlatform(/^iPad/) || // iPadOS 13 lies and says it's a Mac, but we can distinguish by detecting touch support.\n    isMac() && navigator.maxTouchPoints > 1;\n}\nfunction isIOS() {\n    return isIPhone() || isIPad();\n}\nfunction testPlatform(re) {\n    return  false ? 0 : undefined;\n}\n// This code comes from https://github.com/adobe/react-spectrum/blob/main/packages/%40react-aria/overlays/src/usePreventScroll.ts\nconst KEYBOARD_BUFFER = 24;\nconst useIsomorphicLayoutEffect =  false ? 0 : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\nfunction chain$1(...callbacks) {\n    return (...args)=>{\n        for (let callback of callbacks){\n            if (typeof callback === 'function') {\n                callback(...args);\n            }\n        }\n    };\n}\n// @ts-ignore\nconst visualViewport = typeof document !== 'undefined' && window.visualViewport;\nfunction isScrollable(node) {\n    let style = window.getComputedStyle(node);\n    return /(auto|scroll)/.test(style.overflow + style.overflowX + style.overflowY);\n}\nfunction getScrollParent(node) {\n    if (isScrollable(node)) {\n        node = node.parentElement;\n    }\n    while(node && !isScrollable(node)){\n        node = node.parentElement;\n    }\n    return node || document.scrollingElement || document.documentElement;\n}\n// HTML input types that do not cause the software keyboard to appear.\nconst nonTextInputTypes = new Set([\n    'checkbox',\n    'radio',\n    'range',\n    'color',\n    'file',\n    'image',\n    'button',\n    'submit',\n    'reset'\n]);\n// The number of active usePreventScroll calls. Used to determine whether to revert back to the original page style/scroll position\nlet preventScrollCount = 0;\nlet restore;\n/**\n * Prevents scrolling on the document body on mount, and\n * restores it on unmount. Also ensures that content does not\n * shift due to the scrollbars disappearing.\n */ function usePreventScroll(options = {}) {\n    let { isDisabled } = options;\n    useIsomorphicLayoutEffect({\n        \"usePreventScroll.useIsomorphicLayoutEffect\": ()=>{\n            if (isDisabled) {\n                return;\n            }\n            preventScrollCount++;\n            if (preventScrollCount === 1) {\n                if (isIOS()) {\n                    restore = preventScrollMobileSafari();\n                }\n            }\n            return ({\n                \"usePreventScroll.useIsomorphicLayoutEffect\": ()=>{\n                    preventScrollCount--;\n                    if (preventScrollCount === 0) {\n                        restore == null ? void 0 : restore();\n                    }\n                }\n            })[\"usePreventScroll.useIsomorphicLayoutEffect\"];\n        }\n    }[\"usePreventScroll.useIsomorphicLayoutEffect\"], [\n        isDisabled\n    ]);\n}\n// Mobile Safari is a whole different beast. Even with overflow: hidden,\n// it still scrolls the page in many situations:\n//\n// 1. When the bottom toolbar and address bar are collapsed, page scrolling is always allowed.\n// 2. When the keyboard is visible, the viewport does not resize. Instead, the keyboard covers part of\n//    it, so it becomes scrollable.\n// 3. When tapping on an input, the page always scrolls so that the input is centered in the visual viewport.\n//    This may cause even fixed position elements to scroll off the screen.\n// 4. When using the next/previous buttons in the keyboard to navigate between inputs, the whole page always\n//    scrolls, even if the input is inside a nested scrollable element that could be scrolled instead.\n//\n// In order to work around these cases, and prevent scrolling without jankiness, we do a few things:\n//\n// 1. Prevent default on `touchmove` events that are not in a scrollable element. This prevents touch scrolling\n//    on the window.\n// 2. Prevent default on `touchmove` events inside a scrollable element when the scroll position is at the\n//    top or bottom. This avoids the whole page scrolling instead, but does prevent overscrolling.\n// 3. Prevent default on `touchend` events on input elements and handle focusing the element ourselves.\n// 4. When focusing an input, apply a transform to trick Safari into thinking the input is at the top\n//    of the page, which prevents it from scrolling the page. After the input is focused, scroll the element\n//    into view ourselves, without scrolling the whole page.\n// 5. Offset the body by the scroll position using a negative margin and scroll to the top. This should appear the\n//    same visually, but makes the actual scroll position always zero. This is required to make all of the\n//    above work or Safari will still try to scroll the page when focusing an input.\n// 6. As a last resort, handle window scroll events, and scroll back to the top. This can happen when attempting\n//    to navigate to an input with the next/previous buttons that's outside a modal.\nfunction preventScrollMobileSafari() {\n    let scrollable;\n    let lastY = 0;\n    let onTouchStart = (e)=>{\n        // Store the nearest scrollable parent element from the element that the user touched.\n        scrollable = getScrollParent(e.target);\n        if (scrollable === document.documentElement && scrollable === document.body) {\n            return;\n        }\n        lastY = e.changedTouches[0].pageY;\n    };\n    let onTouchMove = (e)=>{\n        // Prevent scrolling the window.\n        if (!scrollable || scrollable === document.documentElement || scrollable === document.body) {\n            e.preventDefault();\n            return;\n        }\n        // Prevent scrolling up when at the top and scrolling down when at the bottom\n        // of a nested scrollable area, otherwise mobile Safari will start scrolling\n        // the window instead. Unfortunately, this disables bounce scrolling when at\n        // the top but it's the best we can do.\n        let y = e.changedTouches[0].pageY;\n        let scrollTop = scrollable.scrollTop;\n        let bottom = scrollable.scrollHeight - scrollable.clientHeight;\n        if (bottom === 0) {\n            return;\n        }\n        if (scrollTop <= 0 && y > lastY || scrollTop >= bottom && y < lastY) {\n            e.preventDefault();\n        }\n        lastY = y;\n    };\n    let onTouchEnd = (e)=>{\n        let target = e.target;\n        // Apply this change if we're not already focused on the target element\n        if (isInput(target) && target !== document.activeElement) {\n            e.preventDefault();\n            // Apply a transform to trick Safari into thinking the input is at the top of the page\n            // so it doesn't try to scroll it into view. When tapping on an input, this needs to\n            // be done before the \"focus\" event, so we have to focus the element ourselves.\n            target.style.transform = 'translateY(-2000px)';\n            target.focus();\n            requestAnimationFrame(()=>{\n                target.style.transform = '';\n            });\n        }\n    };\n    let onFocus = (e)=>{\n        let target = e.target;\n        if (isInput(target)) {\n            // Transform also needs to be applied in the focus event in cases where focus moves\n            // other than tapping on an input directly, e.g. the next/previous buttons in the\n            // software keyboard. In these cases, it seems applying the transform in the focus event\n            // is good enough, whereas when tapping an input, it must be done before the focus event. 🤷‍♂️\n            target.style.transform = 'translateY(-2000px)';\n            requestAnimationFrame(()=>{\n                target.style.transform = '';\n                // This will have prevented the browser from scrolling the focused element into view,\n                // so we need to do this ourselves in a way that doesn't cause the whole page to scroll.\n                if (visualViewport) {\n                    if (visualViewport.height < window.innerHeight) {\n                        // If the keyboard is already visible, do this after one additional frame\n                        // to wait for the transform to be removed.\n                        requestAnimationFrame(()=>{\n                            scrollIntoView(target);\n                        });\n                    } else {\n                        // Otherwise, wait for the visual viewport to resize before scrolling so we can\n                        // measure the correct position to scroll to.\n                        visualViewport.addEventListener('resize', ()=>scrollIntoView(target), {\n                            once: true\n                        });\n                    }\n                }\n            });\n        }\n    };\n    let onWindowScroll = ()=>{\n        // Last resort. If the window scrolled, scroll it back to the top.\n        // It should always be at the top because the body will have a negative margin (see below).\n        window.scrollTo(0, 0);\n    };\n    // Record the original scroll position so we can restore it.\n    // Then apply a negative margin to the body to offset it by the scroll position. This will\n    // enable us to scroll the window to the top, which is required for the rest of this to work.\n    let scrollX = window.pageXOffset;\n    let scrollY = window.pageYOffset;\n    let restoreStyles = chain$1(setStyle(document.documentElement, 'paddingRight', `${window.innerWidth - document.documentElement.clientWidth}px`));\n    // Scroll to the top. The negative margin on the body will make this appear the same.\n    window.scrollTo(0, 0);\n    let removeEvents = chain$1(addEvent(document, 'touchstart', onTouchStart, {\n        passive: false,\n        capture: true\n    }), addEvent(document, 'touchmove', onTouchMove, {\n        passive: false,\n        capture: true\n    }), addEvent(document, 'touchend', onTouchEnd, {\n        passive: false,\n        capture: true\n    }), addEvent(document, 'focus', onFocus, true), addEvent(window, 'scroll', onWindowScroll));\n    return ()=>{\n        // Restore styles and scroll the page back to where it was.\n        restoreStyles();\n        removeEvents();\n        window.scrollTo(scrollX, scrollY);\n    };\n}\n// Sets a CSS property on an element, and returns a function to revert it to the previous value.\nfunction setStyle(element, style, value) {\n    // https://github.com/microsoft/TypeScript/issues/17827#issuecomment-391663310\n    // @ts-ignore\n    let cur = element.style[style];\n    // @ts-ignore\n    element.style[style] = value;\n    return ()=>{\n        // @ts-ignore\n        element.style[style] = cur;\n    };\n}\n// Adds an event listener to an element, and returns a function to remove it.\nfunction addEvent(target, event, handler, options) {\n    // @ts-ignore\n    target.addEventListener(event, handler, options);\n    return ()=>{\n        // @ts-ignore\n        target.removeEventListener(event, handler, options);\n    };\n}\nfunction scrollIntoView(target) {\n    let root = document.scrollingElement || document.documentElement;\n    while(target && target !== root){\n        // Find the parent scrollable element and adjust the scroll position if the target is not already in view.\n        let scrollable = getScrollParent(target);\n        if (scrollable !== document.documentElement && scrollable !== document.body && scrollable !== target) {\n            let scrollableTop = scrollable.getBoundingClientRect().top;\n            let targetTop = target.getBoundingClientRect().top;\n            let targetBottom = target.getBoundingClientRect().bottom;\n            // Buffer is needed for some edge cases\n            const keyboardHeight = scrollable.getBoundingClientRect().bottom + KEYBOARD_BUFFER;\n            if (targetBottom > keyboardHeight) {\n                scrollable.scrollTop += targetTop - scrollableTop;\n            }\n        }\n        // @ts-ignore\n        target = scrollable.parentElement;\n    }\n}\nfunction isInput(target) {\n    return target instanceof HTMLInputElement && !nonTextInputTypes.has(target.type) || target instanceof HTMLTextAreaElement || target instanceof HTMLElement && target.isContentEditable;\n}\n// This code comes from https://github.com/radix-ui/primitives/tree/main/packages/react/compose-refs\n/**\n * Set a given ref to a given value\n * This utility takes care of different types of refs: callback refs and RefObject(s)\n */ function setRef(ref, value) {\n    if (typeof ref === 'function') {\n        ref(value);\n    } else if (ref !== null && ref !== undefined) {\n        ref.current = value;\n    }\n}\n/**\n * A utility to compose multiple refs together\n * Accepts callback refs and RefObject(s)\n */ function composeRefs(...refs) {\n    return (node)=>refs.forEach((ref)=>setRef(ref, node));\n}\n/**\n * A custom hook that composes multiple refs\n * Accepts callback refs and RefObject(s)\n */ function useComposedRefs(...refs) {\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    return react__WEBPACK_IMPORTED_MODULE_0__.useCallback(composeRefs(...refs), refs);\n}\nconst cache = new WeakMap();\nfunction set(el, styles, ignoreCache = false) {\n    if (!el || !(el instanceof HTMLElement)) return;\n    let originalStyles = {};\n    Object.entries(styles).forEach(([key, value])=>{\n        if (key.startsWith('--')) {\n            el.style.setProperty(key, value);\n            return;\n        }\n        originalStyles[key] = el.style[key];\n        el.style[key] = value;\n    });\n    if (ignoreCache) return;\n    cache.set(el, originalStyles);\n}\nfunction reset(el, prop) {\n    if (!el || !(el instanceof HTMLElement)) return;\n    let originalStyles = cache.get(el);\n    if (!originalStyles) {\n        return;\n    }\n    {\n        el.style[prop] = originalStyles[prop];\n    }\n}\nconst isVertical = (direction)=>{\n    switch(direction){\n        case 'top':\n        case 'bottom':\n            return true;\n        case 'left':\n        case 'right':\n            return false;\n        default:\n            return direction;\n    }\n};\nfunction getTranslate(element, direction) {\n    if (!element) {\n        return null;\n    }\n    const style = window.getComputedStyle(element);\n    const transform = style.transform || style.webkitTransform || style.mozTransform;\n    let mat = transform.match(/^matrix3d\\((.+)\\)$/);\n    if (mat) {\n        // https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/matrix3d\n        return parseFloat(mat[1].split(', ')[isVertical(direction) ? 13 : 12]);\n    }\n    // https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/matrix\n    mat = transform.match(/^matrix\\((.+)\\)$/);\n    return mat ? parseFloat(mat[1].split(', ')[isVertical(direction) ? 5 : 4]) : null;\n}\nfunction dampenValue(v) {\n    return 8 * (Math.log(v + 1) - 2);\n}\nfunction assignStyle(element, style) {\n    if (!element) return ()=>{};\n    const prevStyle = element.style.cssText;\n    Object.assign(element.style, style);\n    return ()=>{\n        element.style.cssText = prevStyle;\n    };\n}\n/**\n * Receives functions as arguments and returns a new function that calls all.\n */ function chain(...fns) {\n    return (...args)=>{\n        for (const fn of fns){\n            if (typeof fn === 'function') {\n                // @ts-ignore\n                fn(...args);\n            }\n        }\n    };\n}\nconst TRANSITIONS = {\n    DURATION: 0.5,\n    EASE: [\n        0.32,\n        0.72,\n        0,\n        1\n    ]\n};\nconst VELOCITY_THRESHOLD = 0.4;\nconst CLOSE_THRESHOLD = 0.25;\nconst SCROLL_LOCK_TIMEOUT = 100;\nconst BORDER_RADIUS = 8;\nconst NESTED_DISPLACEMENT = 16;\nconst WINDOW_TOP_OFFSET = 26;\nconst DRAG_CLASS = 'vaul-dragging';\n// This code comes from https://github.com/radix-ui/primitives/blob/main/packages/react/use-controllable-state/src/useControllableState.tsx\nfunction useCallbackRef(callback) {\n    const callbackRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(callback);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect({\n        \"useCallbackRef.useEffect\": ()=>{\n            callbackRef.current = callback;\n        }\n    }[\"useCallbackRef.useEffect\"]);\n    // https://github.com/facebook/react/issues/19240\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo({\n        \"useCallbackRef.useMemo\": ()=>({\n                \"useCallbackRef.useMemo\": (...args)=>callbackRef.current == null ? void 0 : callbackRef.current.call(callbackRef, ...args)\n            })[\"useCallbackRef.useMemo\"]\n    }[\"useCallbackRef.useMemo\"], []);\n}\nfunction useUncontrolledState({ defaultProp, onChange }) {\n    const uncontrolledState = react__WEBPACK_IMPORTED_MODULE_0__.useState(defaultProp);\n    const [value] = uncontrolledState;\n    const prevValueRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(value);\n    const handleChange = useCallbackRef(onChange);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect({\n        \"useUncontrolledState.useEffect\": ()=>{\n            if (prevValueRef.current !== value) {\n                handleChange(value);\n                prevValueRef.current = value;\n            }\n        }\n    }[\"useUncontrolledState.useEffect\"], [\n        value,\n        prevValueRef,\n        handleChange\n    ]);\n    return uncontrolledState;\n}\nfunction useControllableState({ prop, defaultProp, onChange = ()=>{} }) {\n    const [uncontrolledProp, setUncontrolledProp] = useUncontrolledState({\n        defaultProp,\n        onChange\n    });\n    const isControlled = prop !== undefined;\n    const value = isControlled ? prop : uncontrolledProp;\n    const handleChange = useCallbackRef(onChange);\n    const setValue = react__WEBPACK_IMPORTED_MODULE_0__.useCallback({\n        \"useControllableState.useCallback[setValue]\": (nextValue)=>{\n            if (isControlled) {\n                const setter = nextValue;\n                const value = typeof nextValue === 'function' ? setter(prop) : nextValue;\n                if (value !== prop) handleChange(value);\n            } else {\n                setUncontrolledProp(nextValue);\n            }\n        }\n    }[\"useControllableState.useCallback[setValue]\"], [\n        isControlled,\n        prop,\n        setUncontrolledProp,\n        handleChange\n    ]);\n    return [\n        value,\n        setValue\n    ];\n}\nfunction useSnapPoints({ activeSnapPointProp, setActiveSnapPointProp, snapPoints, drawerRef, overlayRef, fadeFromIndex, onSnapPointChange, direction = 'bottom', container, snapToSequentialPoint }) {\n    const [activeSnapPoint, setActiveSnapPoint] = useControllableState({\n        prop: activeSnapPointProp,\n        defaultProp: snapPoints == null ? void 0 : snapPoints[0],\n        onChange: setActiveSnapPointProp\n    });\n    const [windowDimensions, setWindowDimensions] = react__WEBPACK_IMPORTED_MODULE_0__.useState( false ? 0 : undefined);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect({\n        \"useSnapPoints.useEffect\": ()=>{\n            function onResize() {\n                setWindowDimensions({\n                    innerWidth: window.innerWidth,\n                    innerHeight: window.innerHeight\n                });\n            }\n            window.addEventListener('resize', onResize);\n            return ({\n                \"useSnapPoints.useEffect\": ()=>window.removeEventListener('resize', onResize)\n            })[\"useSnapPoints.useEffect\"];\n        }\n    }[\"useSnapPoints.useEffect\"], []);\n    const isLastSnapPoint = react__WEBPACK_IMPORTED_MODULE_0__.useMemo({\n        \"useSnapPoints.useMemo[isLastSnapPoint]\": ()=>activeSnapPoint === (snapPoints == null ? void 0 : snapPoints[snapPoints.length - 1]) || null\n    }[\"useSnapPoints.useMemo[isLastSnapPoint]\"], [\n        snapPoints,\n        activeSnapPoint\n    ]);\n    const activeSnapPointIndex = react__WEBPACK_IMPORTED_MODULE_0__.useMemo({\n        \"useSnapPoints.useMemo[activeSnapPointIndex]\": ()=>{\n            var _snapPoints_findIndex;\n            return (_snapPoints_findIndex = snapPoints == null ? void 0 : snapPoints.findIndex({\n                \"useSnapPoints.useMemo[activeSnapPointIndex]\": (snapPoint)=>snapPoint === activeSnapPoint\n            }[\"useSnapPoints.useMemo[activeSnapPointIndex]\"])) != null ? _snapPoints_findIndex : null;\n        }\n    }[\"useSnapPoints.useMemo[activeSnapPointIndex]\"], [\n        snapPoints,\n        activeSnapPoint\n    ]);\n    const shouldFade = snapPoints && snapPoints.length > 0 && (fadeFromIndex || fadeFromIndex === 0) && !Number.isNaN(fadeFromIndex) && snapPoints[fadeFromIndex] === activeSnapPoint || !snapPoints;\n    const snapPointsOffset = react__WEBPACK_IMPORTED_MODULE_0__.useMemo({\n        \"useSnapPoints.useMemo[snapPointsOffset]\": ()=>{\n            const containerSize = container ? {\n                width: container.getBoundingClientRect().width,\n                height: container.getBoundingClientRect().height\n            } :  false ? 0 : {\n                width: 0,\n                height: 0\n            };\n            var _snapPoints_map;\n            return (_snapPoints_map = snapPoints == null ? void 0 : snapPoints.map({\n                \"useSnapPoints.useMemo[snapPointsOffset]\": (snapPoint)=>{\n                    const isPx = typeof snapPoint === 'string';\n                    let snapPointAsNumber = 0;\n                    if (isPx) {\n                        snapPointAsNumber = parseInt(snapPoint, 10);\n                    }\n                    if (isVertical(direction)) {\n                        const height = isPx ? snapPointAsNumber : windowDimensions ? snapPoint * containerSize.height : 0;\n                        if (windowDimensions) {\n                            return direction === 'bottom' ? containerSize.height - height : -containerSize.height + height;\n                        }\n                        return height;\n                    }\n                    const width = isPx ? snapPointAsNumber : windowDimensions ? snapPoint * containerSize.width : 0;\n                    if (windowDimensions) {\n                        return direction === 'right' ? containerSize.width - width : -containerSize.width + width;\n                    }\n                    return width;\n                }\n            }[\"useSnapPoints.useMemo[snapPointsOffset]\"])) != null ? _snapPoints_map : [];\n        }\n    }[\"useSnapPoints.useMemo[snapPointsOffset]\"], [\n        snapPoints,\n        windowDimensions,\n        container\n    ]);\n    const activeSnapPointOffset = react__WEBPACK_IMPORTED_MODULE_0__.useMemo({\n        \"useSnapPoints.useMemo[activeSnapPointOffset]\": ()=>activeSnapPointIndex !== null ? snapPointsOffset == null ? void 0 : snapPointsOffset[activeSnapPointIndex] : null\n    }[\"useSnapPoints.useMemo[activeSnapPointOffset]\"], [\n        snapPointsOffset,\n        activeSnapPointIndex\n    ]);\n    const snapToPoint = react__WEBPACK_IMPORTED_MODULE_0__.useCallback({\n        \"useSnapPoints.useCallback[snapToPoint]\": (dimension)=>{\n            var _snapPointsOffset_findIndex;\n            const newSnapPointIndex = (_snapPointsOffset_findIndex = snapPointsOffset == null ? void 0 : snapPointsOffset.findIndex({\n                \"useSnapPoints.useCallback[snapToPoint]\": (snapPointDim)=>snapPointDim === dimension\n            }[\"useSnapPoints.useCallback[snapToPoint]\"])) != null ? _snapPointsOffset_findIndex : null;\n            onSnapPointChange(newSnapPointIndex);\n            set(drawerRef.current, {\n                transition: `transform ${TRANSITIONS.DURATION}s cubic-bezier(${TRANSITIONS.EASE.join(',')})`,\n                transform: isVertical(direction) ? `translate3d(0, ${dimension}px, 0)` : `translate3d(${dimension}px, 0, 0)`\n            });\n            if (snapPointsOffset && newSnapPointIndex !== snapPointsOffset.length - 1 && fadeFromIndex !== undefined && newSnapPointIndex !== fadeFromIndex && newSnapPointIndex < fadeFromIndex) {\n                set(overlayRef.current, {\n                    transition: `opacity ${TRANSITIONS.DURATION}s cubic-bezier(${TRANSITIONS.EASE.join(',')})`,\n                    opacity: '0'\n                });\n            } else {\n                set(overlayRef.current, {\n                    transition: `opacity ${TRANSITIONS.DURATION}s cubic-bezier(${TRANSITIONS.EASE.join(',')})`,\n                    opacity: '1'\n                });\n            }\n            setActiveSnapPoint(snapPoints == null ? void 0 : snapPoints[Math.max(newSnapPointIndex, 0)]);\n        }\n    }[\"useSnapPoints.useCallback[snapToPoint]\"], [\n        drawerRef.current,\n        snapPoints,\n        snapPointsOffset,\n        fadeFromIndex,\n        overlayRef,\n        setActiveSnapPoint\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect({\n        \"useSnapPoints.useEffect\": ()=>{\n            if (activeSnapPoint || activeSnapPointProp) {\n                var _snapPoints_findIndex;\n                const newIndex = (_snapPoints_findIndex = snapPoints == null ? void 0 : snapPoints.findIndex({\n                    \"useSnapPoints.useEffect\": (snapPoint)=>snapPoint === activeSnapPointProp || snapPoint === activeSnapPoint\n                }[\"useSnapPoints.useEffect\"])) != null ? _snapPoints_findIndex : -1;\n                if (snapPointsOffset && newIndex !== -1 && typeof snapPointsOffset[newIndex] === 'number') {\n                    snapToPoint(snapPointsOffset[newIndex]);\n                }\n            }\n        }\n    }[\"useSnapPoints.useEffect\"], [\n        activeSnapPoint,\n        activeSnapPointProp,\n        snapPoints,\n        snapPointsOffset,\n        snapToPoint\n    ]);\n    function onRelease({ draggedDistance, closeDrawer, velocity, dismissible }) {\n        if (fadeFromIndex === undefined) return;\n        const currentPosition = direction === 'bottom' || direction === 'right' ? (activeSnapPointOffset != null ? activeSnapPointOffset : 0) - draggedDistance : (activeSnapPointOffset != null ? activeSnapPointOffset : 0) + draggedDistance;\n        const isOverlaySnapPoint = activeSnapPointIndex === fadeFromIndex - 1;\n        const isFirst = activeSnapPointIndex === 0;\n        const hasDraggedUp = draggedDistance > 0;\n        if (isOverlaySnapPoint) {\n            set(overlayRef.current, {\n                transition: `opacity ${TRANSITIONS.DURATION}s cubic-bezier(${TRANSITIONS.EASE.join(',')})`\n            });\n        }\n        if (!snapToSequentialPoint && velocity > 2 && !hasDraggedUp) {\n            if (dismissible) closeDrawer();\n            else snapToPoint(snapPointsOffset[0]); // snap to initial point\n            return;\n        }\n        if (!snapToSequentialPoint && velocity > 2 && hasDraggedUp && snapPointsOffset && snapPoints) {\n            snapToPoint(snapPointsOffset[snapPoints.length - 1]);\n            return;\n        }\n        // Find the closest snap point to the current position\n        const closestSnapPoint = snapPointsOffset == null ? void 0 : snapPointsOffset.reduce((prev, curr)=>{\n            if (typeof prev !== 'number' || typeof curr !== 'number') return prev;\n            return Math.abs(curr - currentPosition) < Math.abs(prev - currentPosition) ? curr : prev;\n        });\n        const dim = isVertical(direction) ? window.innerHeight : window.innerWidth;\n        if (velocity > VELOCITY_THRESHOLD && Math.abs(draggedDistance) < dim * 0.4) {\n            const dragDirection = hasDraggedUp ? 1 : -1; // 1 = up, -1 = down\n            // Don't do anything if we swipe upwards while being on the last snap point\n            if (dragDirection > 0 && isLastSnapPoint && snapPoints) {\n                snapToPoint(snapPointsOffset[snapPoints.length - 1]);\n                return;\n            }\n            if (isFirst && dragDirection < 0 && dismissible) {\n                closeDrawer();\n            }\n            if (activeSnapPointIndex === null) return;\n            snapToPoint(snapPointsOffset[activeSnapPointIndex + dragDirection]);\n            return;\n        }\n        snapToPoint(closestSnapPoint);\n    }\n    function onDrag({ draggedDistance }) {\n        if (activeSnapPointOffset === null) return;\n        const newValue = direction === 'bottom' || direction === 'right' ? activeSnapPointOffset - draggedDistance : activeSnapPointOffset + draggedDistance;\n        // Don't do anything if we exceed the last(biggest) snap point\n        if ((direction === 'bottom' || direction === 'right') && newValue < snapPointsOffset[snapPointsOffset.length - 1]) {\n            return;\n        }\n        if ((direction === 'top' || direction === 'left') && newValue > snapPointsOffset[snapPointsOffset.length - 1]) {\n            return;\n        }\n        set(drawerRef.current, {\n            transform: isVertical(direction) ? `translate3d(0, ${newValue}px, 0)` : `translate3d(${newValue}px, 0, 0)`\n        });\n    }\n    function getPercentageDragged(absDraggedDistance, isDraggingDown) {\n        if (!snapPoints || typeof activeSnapPointIndex !== 'number' || !snapPointsOffset || fadeFromIndex === undefined) return null;\n        // If this is true we are dragging to a snap point that is supposed to have an overlay\n        const isOverlaySnapPoint = activeSnapPointIndex === fadeFromIndex - 1;\n        const isOverlaySnapPointOrHigher = activeSnapPointIndex >= fadeFromIndex;\n        if (isOverlaySnapPointOrHigher && isDraggingDown) {\n            return 0;\n        }\n        // Don't animate, but still use this one if we are dragging away from the overlaySnapPoint\n        if (isOverlaySnapPoint && !isDraggingDown) return 1;\n        if (!shouldFade && !isOverlaySnapPoint) return null;\n        // Either fadeFrom index or the one before\n        const targetSnapPointIndex = isOverlaySnapPoint ? activeSnapPointIndex + 1 : activeSnapPointIndex - 1;\n        // Get the distance from overlaySnapPoint to the one before or vice-versa to calculate the opacity percentage accordingly\n        const snapPointDistance = isOverlaySnapPoint ? snapPointsOffset[targetSnapPointIndex] - snapPointsOffset[targetSnapPointIndex - 1] : snapPointsOffset[targetSnapPointIndex + 1] - snapPointsOffset[targetSnapPointIndex];\n        const percentageDragged = absDraggedDistance / Math.abs(snapPointDistance);\n        if (isOverlaySnapPoint) {\n            return 1 - percentageDragged;\n        } else {\n            return percentageDragged;\n        }\n    }\n    return {\n        isLastSnapPoint,\n        activeSnapPoint,\n        shouldFade,\n        getPercentageDragged,\n        setActiveSnapPoint,\n        activeSnapPointIndex,\n        onRelease,\n        onDrag,\n        snapPointsOffset\n    };\n}\nconst noop = ()=>()=>{};\nfunction useScaleBackground() {\n    const { direction, isOpen, shouldScaleBackground, setBackgroundColorOnScale, noBodyStyles } = useDrawerContext();\n    const timeoutIdRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const initialBackgroundColor = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"useScaleBackground.useMemo[initialBackgroundColor]\": ()=>document.body.style.backgroundColor\n    }[\"useScaleBackground.useMemo[initialBackgroundColor]\"], []);\n    function getScale() {\n        return (window.innerWidth - WINDOW_TOP_OFFSET) / window.innerWidth;\n    }\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect({\n        \"useScaleBackground.useEffect\": ()=>{\n            if (isOpen && shouldScaleBackground) {\n                if (timeoutIdRef.current) clearTimeout(timeoutIdRef.current);\n                const wrapper = document.querySelector('[data-vaul-drawer-wrapper]') || document.querySelector('[vaul-drawer-wrapper]');\n                if (!wrapper) return;\n                chain(setBackgroundColorOnScale && !noBodyStyles ? assignStyle(document.body, {\n                    background: 'black'\n                }) : noop, assignStyle(wrapper, {\n                    transformOrigin: isVertical(direction) ? 'top' : 'left',\n                    transitionProperty: 'transform, border-radius',\n                    transitionDuration: `${TRANSITIONS.DURATION}s`,\n                    transitionTimingFunction: `cubic-bezier(${TRANSITIONS.EASE.join(',')})`\n                }));\n                const wrapperStylesCleanup = assignStyle(wrapper, {\n                    borderRadius: `${BORDER_RADIUS}px`,\n                    overflow: 'hidden',\n                    ...isVertical(direction) ? {\n                        transform: `scale(${getScale()}) translate3d(0, calc(env(safe-area-inset-top) + 14px), 0)`\n                    } : {\n                        transform: `scale(${getScale()}) translate3d(calc(env(safe-area-inset-top) + 14px), 0, 0)`\n                    }\n                });\n                return ({\n                    \"useScaleBackground.useEffect\": ()=>{\n                        wrapperStylesCleanup();\n                        timeoutIdRef.current = window.setTimeout({\n                            \"useScaleBackground.useEffect\": ()=>{\n                                if (initialBackgroundColor) {\n                                    document.body.style.background = initialBackgroundColor;\n                                } else {\n                                    document.body.style.removeProperty('background');\n                                }\n                            }\n                        }[\"useScaleBackground.useEffect\"], TRANSITIONS.DURATION * 1000);\n                    }\n                })[\"useScaleBackground.useEffect\"];\n            }\n        }\n    }[\"useScaleBackground.useEffect\"], [\n        isOpen,\n        shouldScaleBackground,\n        initialBackgroundColor\n    ]);\n}\nlet previousBodyPosition = null;\n/**\n * This hook is necessary to prevent buggy behavior on iOS devices (need to test on Android).\n * I won't get into too much detail about what bugs it solves, but so far I've found that setting the body to `position: fixed` is the most reliable way to prevent those bugs.\n * Issues that this hook solves:\n * https://github.com/emilkowalski/vaul/issues/435\n * https://github.com/emilkowalski/vaul/issues/433\n * And more that I discovered, but were just not reported.\n */ function usePositionFixed({ isOpen, modal, nested, hasBeenOpened, preventScrollRestoration, noBodyStyles }) {\n    const [activeUrl, setActiveUrl] = react__WEBPACK_IMPORTED_MODULE_0__.useState({\n        \"usePositionFixed.useState\": ()=> false ? 0 : ''\n    }[\"usePositionFixed.useState\"]);\n    const scrollPos = react__WEBPACK_IMPORTED_MODULE_0__.useRef(0);\n    const setPositionFixed = react__WEBPACK_IMPORTED_MODULE_0__.useCallback({\n        \"usePositionFixed.useCallback[setPositionFixed]\": ()=>{\n            // All browsers on iOS will return true here.\n            if (!isSafari()) return;\n            // If previousBodyPosition is already set, don't set it again.\n            if (previousBodyPosition === null && isOpen && !noBodyStyles) {\n                previousBodyPosition = {\n                    position: document.body.style.position,\n                    top: document.body.style.top,\n                    left: document.body.style.left,\n                    height: document.body.style.height,\n                    right: 'unset'\n                };\n                // Update the dom inside an animation frame\n                const { scrollX, innerHeight } = window;\n                document.body.style.setProperty('position', 'fixed', 'important');\n                Object.assign(document.body.style, {\n                    top: `${-scrollPos.current}px`,\n                    left: `${-scrollX}px`,\n                    right: '0px',\n                    height: 'auto'\n                });\n                window.setTimeout({\n                    \"usePositionFixed.useCallback[setPositionFixed]\": ()=>window.requestAnimationFrame({\n                            \"usePositionFixed.useCallback[setPositionFixed]\": ()=>{\n                                // Attempt to check if the bottom bar appeared due to the position change\n                                const bottomBarHeight = innerHeight - window.innerHeight;\n                                if (bottomBarHeight && scrollPos.current >= innerHeight) {\n                                    // Move the content further up so that the bottom bar doesn't hide it\n                                    document.body.style.top = `${-(scrollPos.current + bottomBarHeight)}px`;\n                                }\n                            }\n                        }[\"usePositionFixed.useCallback[setPositionFixed]\"])\n                }[\"usePositionFixed.useCallback[setPositionFixed]\"], 300);\n            }\n        }\n    }[\"usePositionFixed.useCallback[setPositionFixed]\"], [\n        isOpen\n    ]);\n    const restorePositionSetting = react__WEBPACK_IMPORTED_MODULE_0__.useCallback({\n        \"usePositionFixed.useCallback[restorePositionSetting]\": ()=>{\n            // All browsers on iOS will return true here.\n            if (!isSafari()) return;\n            if (previousBodyPosition !== null && !noBodyStyles) {\n                // Convert the position from \"px\" to Int\n                const y = -parseInt(document.body.style.top, 10);\n                const x = -parseInt(document.body.style.left, 10);\n                // Restore styles\n                Object.assign(document.body.style, previousBodyPosition);\n                window.requestAnimationFrame({\n                    \"usePositionFixed.useCallback[restorePositionSetting]\": ()=>{\n                        if (preventScrollRestoration && activeUrl !== window.location.href) {\n                            setActiveUrl(window.location.href);\n                            return;\n                        }\n                        window.scrollTo(x, y);\n                    }\n                }[\"usePositionFixed.useCallback[restorePositionSetting]\"]);\n                previousBodyPosition = null;\n            }\n        }\n    }[\"usePositionFixed.useCallback[restorePositionSetting]\"], [\n        activeUrl\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect({\n        \"usePositionFixed.useEffect\": ()=>{\n            function onScroll() {\n                scrollPos.current = window.scrollY;\n            }\n            onScroll();\n            window.addEventListener('scroll', onScroll);\n            return ({\n                \"usePositionFixed.useEffect\": ()=>{\n                    window.removeEventListener('scroll', onScroll);\n                }\n            })[\"usePositionFixed.useEffect\"];\n        }\n    }[\"usePositionFixed.useEffect\"], []);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect({\n        \"usePositionFixed.useEffect\": ()=>{\n            if (!modal) return;\n            return ({\n                \"usePositionFixed.useEffect\": ()=>{\n                    if (typeof document === 'undefined') return;\n                    // Another drawer is opened, safe to ignore the execution\n                    const hasDrawerOpened = !!document.querySelector('[data-vaul-drawer]');\n                    if (hasDrawerOpened) return;\n                    restorePositionSetting();\n                }\n            })[\"usePositionFixed.useEffect\"];\n        }\n    }[\"usePositionFixed.useEffect\"], [\n        modal,\n        restorePositionSetting\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect({\n        \"usePositionFixed.useEffect\": ()=>{\n            if (nested || !hasBeenOpened) return;\n            // This is needed to force Safari toolbar to show **before** the drawer starts animating to prevent a gnarly shift from happening\n            if (isOpen) {\n                // avoid for standalone mode (PWA)\n                const isStandalone = window.matchMedia('(display-mode: standalone)').matches;\n                !isStandalone && setPositionFixed();\n                if (!modal) {\n                    window.setTimeout({\n                        \"usePositionFixed.useEffect\": ()=>{\n                            restorePositionSetting();\n                        }\n                    }[\"usePositionFixed.useEffect\"], 500);\n                }\n            } else {\n                restorePositionSetting();\n            }\n        }\n    }[\"usePositionFixed.useEffect\"], [\n        isOpen,\n        hasBeenOpened,\n        activeUrl,\n        modal,\n        nested,\n        setPositionFixed,\n        restorePositionSetting\n    ]);\n    return {\n        restorePositionSetting\n    };\n}\nfunction Root({ open: openProp, onOpenChange, children, onDrag: onDragProp, onRelease: onReleaseProp, snapPoints, shouldScaleBackground = false, setBackgroundColorOnScale = true, closeThreshold = CLOSE_THRESHOLD, scrollLockTimeout = SCROLL_LOCK_TIMEOUT, dismissible = true, handleOnly = false, fadeFromIndex = snapPoints && snapPoints.length - 1, activeSnapPoint: activeSnapPointProp, setActiveSnapPoint: setActiveSnapPointProp, fixed, modal = true, onClose, nested, noBodyStyles = false, direction = 'bottom', defaultOpen = false, disablePreventScroll = true, snapToSequentialPoint = false, preventScrollRestoration = false, repositionInputs = true, onAnimationEnd, container, autoFocus = false }) {\n    var _drawerRef_current, _drawerRef_current1;\n    const [isOpen = false, setIsOpen] = useControllableState({\n        defaultProp: defaultOpen,\n        prop: openProp,\n        onChange: {\n            \"Root.useControllableState\": (o)=>{\n                onOpenChange == null ? void 0 : onOpenChange(o);\n                if (!o && !nested) {\n                    restorePositionSetting();\n                }\n                setTimeout({\n                    \"Root.useControllableState\": ()=>{\n                        onAnimationEnd == null ? void 0 : onAnimationEnd(o);\n                    }\n                }[\"Root.useControllableState\"], TRANSITIONS.DURATION * 1000);\n                if (o && !modal) {\n                    if (false) {}\n                }\n                if (!o) {\n                    // This will be removed when the exit animation ends (`500ms`)\n                    document.body.style.pointerEvents = 'auto';\n                }\n            }\n        }[\"Root.useControllableState\"]\n    });\n    const [hasBeenOpened, setHasBeenOpened] = react__WEBPACK_IMPORTED_MODULE_0__.useState(false);\n    const [isDragging, setIsDragging] = react__WEBPACK_IMPORTED_MODULE_0__.useState(false);\n    const [justReleased, setJustReleased] = react__WEBPACK_IMPORTED_MODULE_0__.useState(false);\n    const overlayRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const openTime = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const dragStartTime = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const dragEndTime = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const lastTimeDragPrevented = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const isAllowedToDrag = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n    const nestedOpenChangeTimer = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const pointerStart = react__WEBPACK_IMPORTED_MODULE_0__.useRef(0);\n    const keyboardIsOpen = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n    const shouldAnimate = react__WEBPACK_IMPORTED_MODULE_0__.useRef(!defaultOpen);\n    const previousDiffFromInitial = react__WEBPACK_IMPORTED_MODULE_0__.useRef(0);\n    const drawerRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const drawerHeightRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(((_drawerRef_current = drawerRef.current) == null ? void 0 : _drawerRef_current.getBoundingClientRect().height) || 0);\n    const drawerWidthRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(((_drawerRef_current1 = drawerRef.current) == null ? void 0 : _drawerRef_current1.getBoundingClientRect().width) || 0);\n    const initialDrawerHeight = react__WEBPACK_IMPORTED_MODULE_0__.useRef(0);\n    const onSnapPointChange = react__WEBPACK_IMPORTED_MODULE_0__.useCallback({\n        \"Root.useCallback[onSnapPointChange]\": (activeSnapPointIndex)=>{\n            // Change openTime ref when we reach the last snap point to prevent dragging for 500ms incase it's scrollable.\n            if (snapPoints && activeSnapPointIndex === snapPointsOffset.length - 1) openTime.current = new Date();\n        }\n    }[\"Root.useCallback[onSnapPointChange]\"], []);\n    const { activeSnapPoint, activeSnapPointIndex, setActiveSnapPoint, onRelease: onReleaseSnapPoints, snapPointsOffset, onDrag: onDragSnapPoints, shouldFade, getPercentageDragged: getSnapPointsPercentageDragged } = useSnapPoints({\n        snapPoints,\n        activeSnapPointProp,\n        setActiveSnapPointProp,\n        drawerRef,\n        fadeFromIndex,\n        overlayRef,\n        onSnapPointChange,\n        direction,\n        container,\n        snapToSequentialPoint\n    });\n    usePreventScroll({\n        isDisabled: !isOpen || isDragging || !modal || justReleased || !hasBeenOpened || !repositionInputs || !disablePreventScroll\n    });\n    const { restorePositionSetting } = usePositionFixed({\n        isOpen,\n        modal,\n        nested: nested != null ? nested : false,\n        hasBeenOpened,\n        preventScrollRestoration,\n        noBodyStyles\n    });\n    function getScale() {\n        return (window.innerWidth - WINDOW_TOP_OFFSET) / window.innerWidth;\n    }\n    function onPress(event) {\n        var _drawerRef_current, _drawerRef_current1;\n        if (!dismissible && !snapPoints) return;\n        if (drawerRef.current && !drawerRef.current.contains(event.target)) return;\n        drawerHeightRef.current = ((_drawerRef_current = drawerRef.current) == null ? void 0 : _drawerRef_current.getBoundingClientRect().height) || 0;\n        drawerWidthRef.current = ((_drawerRef_current1 = drawerRef.current) == null ? void 0 : _drawerRef_current1.getBoundingClientRect().width) || 0;\n        setIsDragging(true);\n        dragStartTime.current = new Date();\n        // iOS doesn't trigger mouseUp after scrolling so we need to listen to touched in order to disallow dragging\n        if (isIOS()) {\n            window.addEventListener('touchend', ()=>isAllowedToDrag.current = false, {\n                once: true\n            });\n        }\n        // Ensure we maintain correct pointer capture even when going outside of the drawer\n        event.target.setPointerCapture(event.pointerId);\n        pointerStart.current = isVertical(direction) ? event.pageY : event.pageX;\n    }\n    function shouldDrag(el, isDraggingInDirection) {\n        var _window_getSelection;\n        let element = el;\n        const highlightedText = (_window_getSelection = window.getSelection()) == null ? void 0 : _window_getSelection.toString();\n        const swipeAmount = drawerRef.current ? getTranslate(drawerRef.current, direction) : null;\n        const date = new Date();\n        // Fixes https://github.com/emilkowalski/vaul/issues/483\n        if (element.tagName === 'SELECT') {\n            return false;\n        }\n        if (element.hasAttribute('data-vaul-no-drag') || element.closest('[data-vaul-no-drag]')) {\n            return false;\n        }\n        if (direction === 'right' || direction === 'left') {\n            return true;\n        }\n        // Allow scrolling when animating\n        if (openTime.current && date.getTime() - openTime.current.getTime() < 500) {\n            return false;\n        }\n        if (swipeAmount !== null) {\n            if (direction === 'bottom' ? swipeAmount > 0 : swipeAmount < 0) {\n                return true;\n            }\n        }\n        // Don't drag if there's highlighted text\n        if (highlightedText && highlightedText.length > 0) {\n            return false;\n        }\n        // Disallow dragging if drawer was scrolled within `scrollLockTimeout`\n        if (lastTimeDragPrevented.current && date.getTime() - lastTimeDragPrevented.current.getTime() < scrollLockTimeout && swipeAmount === 0) {\n            lastTimeDragPrevented.current = date;\n            return false;\n        }\n        if (isDraggingInDirection) {\n            lastTimeDragPrevented.current = date;\n            // We are dragging down so we should allow scrolling\n            return false;\n        }\n        // Keep climbing up the DOM tree as long as there's a parent\n        while(element){\n            // Check if the element is scrollable\n            if (element.scrollHeight > element.clientHeight) {\n                if (element.scrollTop !== 0) {\n                    lastTimeDragPrevented.current = new Date();\n                    // The element is scrollable and not scrolled to the top, so don't drag\n                    return false;\n                }\n                if (element.getAttribute('role') === 'dialog') {\n                    return true;\n                }\n            }\n            // Move up to the parent element\n            element = element.parentNode;\n        }\n        // No scrollable parents not scrolled to the top found, so drag\n        return true;\n    }\n    function onDrag(event) {\n        if (!drawerRef.current) {\n            return;\n        }\n        // We need to know how much of the drawer has been dragged in percentages so that we can transform background accordingly\n        if (isDragging) {\n            const directionMultiplier = direction === 'bottom' || direction === 'right' ? 1 : -1;\n            const draggedDistance = (pointerStart.current - (isVertical(direction) ? event.pageY : event.pageX)) * directionMultiplier;\n            const isDraggingInDirection = draggedDistance > 0;\n            // Pre condition for disallowing dragging in the close direction.\n            const noCloseSnapPointsPreCondition = snapPoints && !dismissible && !isDraggingInDirection;\n            // Disallow dragging down to close when first snap point is the active one and dismissible prop is set to false.\n            if (noCloseSnapPointsPreCondition && activeSnapPointIndex === 0) return;\n            // We need to capture last time when drag with scroll was triggered and have a timeout between\n            const absDraggedDistance = Math.abs(draggedDistance);\n            const wrapper = document.querySelector('[data-vaul-drawer-wrapper]');\n            const drawerDimension = direction === 'bottom' || direction === 'top' ? drawerHeightRef.current : drawerWidthRef.current;\n            // Calculate the percentage dragged, where 1 is the closed position\n            let percentageDragged = absDraggedDistance / drawerDimension;\n            const snapPointPercentageDragged = getSnapPointsPercentageDragged(absDraggedDistance, isDraggingInDirection);\n            if (snapPointPercentageDragged !== null) {\n                percentageDragged = snapPointPercentageDragged;\n            }\n            // Disallow close dragging beyond the smallest snap point.\n            if (noCloseSnapPointsPreCondition && percentageDragged >= 1) {\n                return;\n            }\n            if (!isAllowedToDrag.current && !shouldDrag(event.target, isDraggingInDirection)) return;\n            drawerRef.current.classList.add(DRAG_CLASS);\n            // If shouldDrag gave true once after pressing down on the drawer, we set isAllowedToDrag to true and it will remain true until we let go, there's no reason to disable dragging mid way, ever, and that's the solution to it\n            isAllowedToDrag.current = true;\n            set(drawerRef.current, {\n                transition: 'none'\n            });\n            set(overlayRef.current, {\n                transition: 'none'\n            });\n            if (snapPoints) {\n                onDragSnapPoints({\n                    draggedDistance\n                });\n            }\n            // Run this only if snapPoints are not defined or if we are at the last snap point (highest one)\n            if (isDraggingInDirection && !snapPoints) {\n                const dampenedDraggedDistance = dampenValue(draggedDistance);\n                const translateValue = Math.min(dampenedDraggedDistance * -1, 0) * directionMultiplier;\n                set(drawerRef.current, {\n                    transform: isVertical(direction) ? `translate3d(0, ${translateValue}px, 0)` : `translate3d(${translateValue}px, 0, 0)`\n                });\n                return;\n            }\n            const opacityValue = 1 - percentageDragged;\n            if (shouldFade || fadeFromIndex && activeSnapPointIndex === fadeFromIndex - 1) {\n                onDragProp == null ? void 0 : onDragProp(event, percentageDragged);\n                set(overlayRef.current, {\n                    opacity: `${opacityValue}`,\n                    transition: 'none'\n                }, true);\n            }\n            if (wrapper && overlayRef.current && shouldScaleBackground) {\n                // Calculate percentageDragged as a fraction (0 to 1)\n                const scaleValue = Math.min(getScale() + percentageDragged * (1 - getScale()), 1);\n                const borderRadiusValue = 8 - percentageDragged * 8;\n                const translateValue = Math.max(0, 14 - percentageDragged * 14);\n                set(wrapper, {\n                    borderRadius: `${borderRadiusValue}px`,\n                    transform: isVertical(direction) ? `scale(${scaleValue}) translate3d(0, ${translateValue}px, 0)` : `scale(${scaleValue}) translate3d(${translateValue}px, 0, 0)`,\n                    transition: 'none'\n                }, true);\n            }\n            if (!snapPoints) {\n                const translateValue = absDraggedDistance * directionMultiplier;\n                set(drawerRef.current, {\n                    transform: isVertical(direction) ? `translate3d(0, ${translateValue}px, 0)` : `translate3d(${translateValue}px, 0, 0)`\n                });\n            }\n        }\n    }\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect({\n        \"Root.useEffect\": ()=>{\n            window.requestAnimationFrame({\n                \"Root.useEffect\": ()=>{\n                    shouldAnimate.current = true;\n                }\n            }[\"Root.useEffect\"]);\n        }\n    }[\"Root.useEffect\"], []);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect({\n        \"Root.useEffect\": ()=>{\n            var _window_visualViewport;\n            function onVisualViewportChange() {\n                if (!drawerRef.current || !repositionInputs) return;\n                const focusedElement = document.activeElement;\n                if (isInput(focusedElement) || keyboardIsOpen.current) {\n                    var _window_visualViewport;\n                    const visualViewportHeight = ((_window_visualViewport = window.visualViewport) == null ? void 0 : _window_visualViewport.height) || 0;\n                    const totalHeight = window.innerHeight;\n                    // This is the height of the keyboard\n                    let diffFromInitial = totalHeight - visualViewportHeight;\n                    const drawerHeight = drawerRef.current.getBoundingClientRect().height || 0;\n                    // Adjust drawer height only if it's tall enough\n                    const isTallEnough = drawerHeight > totalHeight * 0.8;\n                    if (!initialDrawerHeight.current) {\n                        initialDrawerHeight.current = drawerHeight;\n                    }\n                    const offsetFromTop = drawerRef.current.getBoundingClientRect().top;\n                    // visualViewport height may change due to somq e subtle changes to the keyboard. Checking if the height changed by 60 or more will make sure that they keyboard really changed its open state.\n                    if (Math.abs(previousDiffFromInitial.current - diffFromInitial) > 60) {\n                        keyboardIsOpen.current = !keyboardIsOpen.current;\n                    }\n                    if (snapPoints && snapPoints.length > 0 && snapPointsOffset && activeSnapPointIndex) {\n                        const activeSnapPointHeight = snapPointsOffset[activeSnapPointIndex] || 0;\n                        diffFromInitial += activeSnapPointHeight;\n                    }\n                    previousDiffFromInitial.current = diffFromInitial;\n                    // We don't have to change the height if the input is in view, when we are here we are in the opened keyboard state so we can correctly check if the input is in view\n                    if (drawerHeight > visualViewportHeight || keyboardIsOpen.current) {\n                        const height = drawerRef.current.getBoundingClientRect().height;\n                        let newDrawerHeight = height;\n                        if (height > visualViewportHeight) {\n                            newDrawerHeight = visualViewportHeight - (isTallEnough ? offsetFromTop : WINDOW_TOP_OFFSET);\n                        }\n                        // When fixed, don't move the drawer upwards if there's space, but rather only change it's height so it's fully scrollable when the keyboard is open\n                        if (fixed) {\n                            drawerRef.current.style.height = `${height - Math.max(diffFromInitial, 0)}px`;\n                        } else {\n                            drawerRef.current.style.height = `${Math.max(newDrawerHeight, visualViewportHeight - offsetFromTop)}px`;\n                        }\n                    } else if (!isMobileFirefox()) {\n                        drawerRef.current.style.height = `${initialDrawerHeight.current}px`;\n                    }\n                    if (snapPoints && snapPoints.length > 0 && !keyboardIsOpen.current) {\n                        drawerRef.current.style.bottom = `0px`;\n                    } else {\n                        // Negative bottom value would never make sense\n                        drawerRef.current.style.bottom = `${Math.max(diffFromInitial, 0)}px`;\n                    }\n                }\n            }\n            (_window_visualViewport = window.visualViewport) == null ? void 0 : _window_visualViewport.addEventListener('resize', onVisualViewportChange);\n            return ({\n                \"Root.useEffect\": ()=>{\n                    var _window_visualViewport;\n                    return (_window_visualViewport = window.visualViewport) == null ? void 0 : _window_visualViewport.removeEventListener('resize', onVisualViewportChange);\n                }\n            })[\"Root.useEffect\"];\n        }\n    }[\"Root.useEffect\"], [\n        activeSnapPointIndex,\n        snapPoints,\n        snapPointsOffset\n    ]);\n    function closeDrawer(fromWithin) {\n        cancelDrag();\n        onClose == null ? void 0 : onClose();\n        if (!fromWithin) {\n            setIsOpen(false);\n        }\n        setTimeout(()=>{\n            if (snapPoints) {\n                setActiveSnapPoint(snapPoints[0]);\n            }\n        }, TRANSITIONS.DURATION * 1000); // seconds to ms\n    }\n    function resetDrawer() {\n        if (!drawerRef.current) return;\n        const wrapper = document.querySelector('[data-vaul-drawer-wrapper]');\n        const currentSwipeAmount = getTranslate(drawerRef.current, direction);\n        set(drawerRef.current, {\n            transform: 'translate3d(0, 0, 0)',\n            transition: `transform ${TRANSITIONS.DURATION}s cubic-bezier(${TRANSITIONS.EASE.join(',')})`\n        });\n        set(overlayRef.current, {\n            transition: `opacity ${TRANSITIONS.DURATION}s cubic-bezier(${TRANSITIONS.EASE.join(',')})`,\n            opacity: '1'\n        });\n        // Don't reset background if swiped upwards\n        if (shouldScaleBackground && currentSwipeAmount && currentSwipeAmount > 0 && isOpen) {\n            set(wrapper, {\n                borderRadius: `${BORDER_RADIUS}px`,\n                overflow: 'hidden',\n                ...isVertical(direction) ? {\n                    transform: `scale(${getScale()}) translate3d(0, calc(env(safe-area-inset-top) + 14px), 0)`,\n                    transformOrigin: 'top'\n                } : {\n                    transform: `scale(${getScale()}) translate3d(calc(env(safe-area-inset-top) + 14px), 0, 0)`,\n                    transformOrigin: 'left'\n                },\n                transitionProperty: 'transform, border-radius',\n                transitionDuration: `${TRANSITIONS.DURATION}s`,\n                transitionTimingFunction: `cubic-bezier(${TRANSITIONS.EASE.join(',')})`\n            }, true);\n        }\n    }\n    function cancelDrag() {\n        if (!isDragging || !drawerRef.current) return;\n        drawerRef.current.classList.remove(DRAG_CLASS);\n        isAllowedToDrag.current = false;\n        setIsDragging(false);\n        dragEndTime.current = new Date();\n    }\n    function onRelease(event) {\n        if (!isDragging || !drawerRef.current) return;\n        drawerRef.current.classList.remove(DRAG_CLASS);\n        isAllowedToDrag.current = false;\n        setIsDragging(false);\n        dragEndTime.current = new Date();\n        const swipeAmount = getTranslate(drawerRef.current, direction);\n        if (!event || !shouldDrag(event.target, false) || !swipeAmount || Number.isNaN(swipeAmount)) return;\n        if (dragStartTime.current === null) return;\n        const timeTaken = dragEndTime.current.getTime() - dragStartTime.current.getTime();\n        const distMoved = pointerStart.current - (isVertical(direction) ? event.pageY : event.pageX);\n        const velocity = Math.abs(distMoved) / timeTaken;\n        if (velocity > 0.05) {\n            // `justReleased` is needed to prevent the drawer from focusing on an input when the drag ends, as it's not the intent most of the time.\n            setJustReleased(true);\n            setTimeout(()=>{\n                setJustReleased(false);\n            }, 200);\n        }\n        if (snapPoints) {\n            const directionMultiplier = direction === 'bottom' || direction === 'right' ? 1 : -1;\n            onReleaseSnapPoints({\n                draggedDistance: distMoved * directionMultiplier,\n                closeDrawer,\n                velocity,\n                dismissible\n            });\n            onReleaseProp == null ? void 0 : onReleaseProp(event, true);\n            return;\n        }\n        // Moved upwards, don't do anything\n        if (direction === 'bottom' || direction === 'right' ? distMoved > 0 : distMoved < 0) {\n            resetDrawer();\n            onReleaseProp == null ? void 0 : onReleaseProp(event, true);\n            return;\n        }\n        if (velocity > VELOCITY_THRESHOLD) {\n            closeDrawer();\n            onReleaseProp == null ? void 0 : onReleaseProp(event, false);\n            return;\n        }\n        var _drawerRef_current_getBoundingClientRect_height;\n        const visibleDrawerHeight = Math.min((_drawerRef_current_getBoundingClientRect_height = drawerRef.current.getBoundingClientRect().height) != null ? _drawerRef_current_getBoundingClientRect_height : 0, window.innerHeight);\n        var _drawerRef_current_getBoundingClientRect_width;\n        const visibleDrawerWidth = Math.min((_drawerRef_current_getBoundingClientRect_width = drawerRef.current.getBoundingClientRect().width) != null ? _drawerRef_current_getBoundingClientRect_width : 0, window.innerWidth);\n        const isHorizontalSwipe = direction === 'left' || direction === 'right';\n        if (Math.abs(swipeAmount) >= (isHorizontalSwipe ? visibleDrawerWidth : visibleDrawerHeight) * closeThreshold) {\n            closeDrawer();\n            onReleaseProp == null ? void 0 : onReleaseProp(event, false);\n            return;\n        }\n        onReleaseProp == null ? void 0 : onReleaseProp(event, true);\n        resetDrawer();\n    }\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect({\n        \"Root.useEffect\": ()=>{\n            // Trigger enter animation without using CSS animation\n            if (isOpen) {\n                set(document.documentElement, {\n                    scrollBehavior: 'auto'\n                });\n                openTime.current = new Date();\n            }\n            return ({\n                \"Root.useEffect\": ()=>{\n                    reset(document.documentElement, 'scrollBehavior');\n                }\n            })[\"Root.useEffect\"];\n        }\n    }[\"Root.useEffect\"], [\n        isOpen\n    ]);\n    function onNestedOpenChange(o) {\n        const scale = o ? (window.innerWidth - NESTED_DISPLACEMENT) / window.innerWidth : 1;\n        const initialTranslate = o ? -NESTED_DISPLACEMENT : 0;\n        if (nestedOpenChangeTimer.current) {\n            window.clearTimeout(nestedOpenChangeTimer.current);\n        }\n        set(drawerRef.current, {\n            transition: `transform ${TRANSITIONS.DURATION}s cubic-bezier(${TRANSITIONS.EASE.join(',')})`,\n            transform: isVertical(direction) ? `scale(${scale}) translate3d(0, ${initialTranslate}px, 0)` : `scale(${scale}) translate3d(${initialTranslate}px, 0, 0)`\n        });\n        if (!o && drawerRef.current) {\n            nestedOpenChangeTimer.current = setTimeout(()=>{\n                const translateValue = getTranslate(drawerRef.current, direction);\n                set(drawerRef.current, {\n                    transition: 'none',\n                    transform: isVertical(direction) ? `translate3d(0, ${translateValue}px, 0)` : `translate3d(${translateValue}px, 0, 0)`\n                });\n            }, 500);\n        }\n    }\n    function onNestedDrag(_event, percentageDragged) {\n        if (percentageDragged < 0) return;\n        const initialScale = (window.innerWidth - NESTED_DISPLACEMENT) / window.innerWidth;\n        const newScale = initialScale + percentageDragged * (1 - initialScale);\n        const newTranslate = -NESTED_DISPLACEMENT + percentageDragged * NESTED_DISPLACEMENT;\n        set(drawerRef.current, {\n            transform: isVertical(direction) ? `scale(${newScale}) translate3d(0, ${newTranslate}px, 0)` : `scale(${newScale}) translate3d(${newTranslate}px, 0, 0)`,\n            transition: 'none'\n        });\n    }\n    function onNestedRelease(_event, o) {\n        const dim = isVertical(direction) ? window.innerHeight : window.innerWidth;\n        const scale = o ? (dim - NESTED_DISPLACEMENT) / dim : 1;\n        const translate = o ? -NESTED_DISPLACEMENT : 0;\n        if (o) {\n            set(drawerRef.current, {\n                transition: `transform ${TRANSITIONS.DURATION}s cubic-bezier(${TRANSITIONS.EASE.join(',')})`,\n                transform: isVertical(direction) ? `scale(${scale}) translate3d(0, ${translate}px, 0)` : `scale(${scale}) translate3d(${translate}px, 0, 0)`\n            });\n        }\n    }\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect({\n        \"Root.useEffect\": ()=>{\n            if (!modal) {\n                // Need to do this manually unfortunately\n                window.requestAnimationFrame({\n                    \"Root.useEffect\": ()=>{\n                        document.body.style.pointerEvents = 'auto';\n                    }\n                }[\"Root.useEffect\"]);\n            }\n        }\n    }[\"Root.useEffect\"], [\n        modal\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_radix_ui_react_dialog__WEBPACK_IMPORTED_MODULE_1__.Root, {\n        defaultOpen: defaultOpen,\n        onOpenChange: (open)=>{\n            if (!dismissible && !open) return;\n            if (open) {\n                setHasBeenOpened(true);\n            } else {\n                closeDrawer(true);\n            }\n            setIsOpen(open);\n        },\n        open: isOpen\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(DrawerContext.Provider, {\n        value: {\n            activeSnapPoint,\n            snapPoints,\n            setActiveSnapPoint,\n            drawerRef,\n            overlayRef,\n            onOpenChange,\n            onPress,\n            onRelease,\n            onDrag,\n            dismissible,\n            shouldAnimate,\n            handleOnly,\n            isOpen,\n            isDragging,\n            shouldFade,\n            closeDrawer,\n            onNestedDrag,\n            onNestedOpenChange,\n            onNestedRelease,\n            keyboardIsOpen,\n            modal,\n            snapPointsOffset,\n            activeSnapPointIndex,\n            direction,\n            shouldScaleBackground,\n            setBackgroundColorOnScale,\n            noBodyStyles,\n            container,\n            autoFocus\n        }\n    }, children));\n}\nconst Overlay = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function({ ...rest }, ref) {\n    const { overlayRef, snapPoints, onRelease, shouldFade, isOpen, modal, shouldAnimate } = useDrawerContext();\n    const composedRef = useComposedRefs(ref, overlayRef);\n    const hasSnapPoints = snapPoints && snapPoints.length > 0;\n    // Overlay is the component that is locking scroll, removing it will unlock the scroll without having to dig into Radix's Dialog library\n    if (!modal) {\n        return null;\n    }\n    const onMouseUp = react__WEBPACK_IMPORTED_MODULE_0__.useCallback({\n        \"Overlay.useCallback[onMouseUp]\": (event)=>onRelease(event)\n    }[\"Overlay.useCallback[onMouseUp]\"], [\n        onRelease\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_radix_ui_react_dialog__WEBPACK_IMPORTED_MODULE_1__.Overlay, {\n        onMouseUp: onMouseUp,\n        ref: composedRef,\n        \"data-vaul-overlay\": \"\",\n        \"data-vaul-snap-points\": isOpen && hasSnapPoints ? 'true' : 'false',\n        \"data-vaul-snap-points-overlay\": isOpen && shouldFade ? 'true' : 'false',\n        \"data-vaul-animate\": (shouldAnimate == null ? void 0 : shouldAnimate.current) ? 'true' : 'false',\n        ...rest\n    });\n});\nOverlay.displayName = 'Drawer.Overlay';\nconst Content = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function({ onPointerDownOutside, style, onOpenAutoFocus, ...rest }, ref) {\n    const { drawerRef, onPress, onRelease, onDrag, keyboardIsOpen, snapPointsOffset, activeSnapPointIndex, modal, isOpen, direction, snapPoints, container, handleOnly, shouldAnimate, autoFocus } = useDrawerContext();\n    // Needed to use transition instead of animations\n    const [delayedSnapPoints, setDelayedSnapPoints] = react__WEBPACK_IMPORTED_MODULE_0__.useState(false);\n    const composedRef = useComposedRefs(ref, drawerRef);\n    const pointerStartRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const lastKnownPointerEventRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const wasBeyondThePointRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n    const hasSnapPoints = snapPoints && snapPoints.length > 0;\n    useScaleBackground();\n    const isDeltaInDirection = (delta, direction, threshold = 0)=>{\n        if (wasBeyondThePointRef.current) return true;\n        const deltaY = Math.abs(delta.y);\n        const deltaX = Math.abs(delta.x);\n        const isDeltaX = deltaX > deltaY;\n        const dFactor = [\n            'bottom',\n            'right'\n        ].includes(direction) ? 1 : -1;\n        if (direction === 'left' || direction === 'right') {\n            const isReverseDirection = delta.x * dFactor < 0;\n            if (!isReverseDirection && deltaX >= 0 && deltaX <= threshold) {\n                return isDeltaX;\n            }\n        } else {\n            const isReverseDirection = delta.y * dFactor < 0;\n            if (!isReverseDirection && deltaY >= 0 && deltaY <= threshold) {\n                return !isDeltaX;\n            }\n        }\n        wasBeyondThePointRef.current = true;\n        return true;\n    };\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect({\n        \"Content.useEffect\": ()=>{\n            if (hasSnapPoints) {\n                window.requestAnimationFrame({\n                    \"Content.useEffect\": ()=>{\n                        setDelayedSnapPoints(true);\n                    }\n                }[\"Content.useEffect\"]);\n            }\n        }\n    }[\"Content.useEffect\"], []);\n    function handleOnPointerUp(event) {\n        pointerStartRef.current = null;\n        wasBeyondThePointRef.current = false;\n        onRelease(event);\n    }\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_radix_ui_react_dialog__WEBPACK_IMPORTED_MODULE_1__.Content, {\n        \"data-vaul-drawer-direction\": direction,\n        \"data-vaul-drawer\": \"\",\n        \"data-vaul-delayed-snap-points\": delayedSnapPoints ? 'true' : 'false',\n        \"data-vaul-snap-points\": isOpen && hasSnapPoints ? 'true' : 'false',\n        \"data-vaul-custom-container\": container ? 'true' : 'false',\n        \"data-vaul-animate\": (shouldAnimate == null ? void 0 : shouldAnimate.current) ? 'true' : 'false',\n        ...rest,\n        ref: composedRef,\n        style: snapPointsOffset && snapPointsOffset.length > 0 ? {\n            '--snap-point-height': `${snapPointsOffset[activeSnapPointIndex != null ? activeSnapPointIndex : 0]}px`,\n            ...style\n        } : style,\n        onPointerDown: (event)=>{\n            if (handleOnly) return;\n            rest.onPointerDown == null ? void 0 : rest.onPointerDown.call(rest, event);\n            pointerStartRef.current = {\n                x: event.pageX,\n                y: event.pageY\n            };\n            onPress(event);\n        },\n        onOpenAutoFocus: (e)=>{\n            onOpenAutoFocus == null ? void 0 : onOpenAutoFocus(e);\n            if (!autoFocus) {\n                e.preventDefault();\n            }\n        },\n        onPointerDownOutside: (e)=>{\n            onPointerDownOutside == null ? void 0 : onPointerDownOutside(e);\n            if (!modal || e.defaultPrevented) {\n                e.preventDefault();\n                return;\n            }\n            if (keyboardIsOpen.current) {\n                keyboardIsOpen.current = false;\n            }\n        },\n        onFocusOutside: (e)=>{\n            if (!modal) {\n                e.preventDefault();\n                return;\n            }\n        },\n        onPointerMove: (event)=>{\n            lastKnownPointerEventRef.current = event;\n            if (handleOnly) return;\n            rest.onPointerMove == null ? void 0 : rest.onPointerMove.call(rest, event);\n            if (!pointerStartRef.current) return;\n            const yPosition = event.pageY - pointerStartRef.current.y;\n            const xPosition = event.pageX - pointerStartRef.current.x;\n            const swipeStartThreshold = event.pointerType === 'touch' ? 10 : 2;\n            const delta = {\n                x: xPosition,\n                y: yPosition\n            };\n            const isAllowedToSwipe = isDeltaInDirection(delta, direction, swipeStartThreshold);\n            if (isAllowedToSwipe) onDrag(event);\n            else if (Math.abs(xPosition) > swipeStartThreshold || Math.abs(yPosition) > swipeStartThreshold) {\n                pointerStartRef.current = null;\n            }\n        },\n        onPointerUp: (event)=>{\n            rest.onPointerUp == null ? void 0 : rest.onPointerUp.call(rest, event);\n            pointerStartRef.current = null;\n            wasBeyondThePointRef.current = false;\n            onRelease(event);\n        },\n        onPointerOut: (event)=>{\n            rest.onPointerOut == null ? void 0 : rest.onPointerOut.call(rest, event);\n            handleOnPointerUp(lastKnownPointerEventRef.current);\n        },\n        onContextMenu: (event)=>{\n            rest.onContextMenu == null ? void 0 : rest.onContextMenu.call(rest, event);\n            if (lastKnownPointerEventRef.current) {\n                handleOnPointerUp(lastKnownPointerEventRef.current);\n            }\n        }\n    });\n});\nContent.displayName = 'Drawer.Content';\nconst LONG_HANDLE_PRESS_TIMEOUT = 250;\nconst DOUBLE_TAP_TIMEOUT = 120;\nconst Handle = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function({ preventCycle = false, children, ...rest }, ref) {\n    const { closeDrawer, isDragging, snapPoints, activeSnapPoint, setActiveSnapPoint, dismissible, handleOnly, isOpen, onPress, onDrag } = useDrawerContext();\n    const closeTimeoutIdRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const shouldCancelInteractionRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n    function handleStartCycle() {\n        // Stop if this is the second click of a double click\n        if (shouldCancelInteractionRef.current) {\n            handleCancelInteraction();\n            return;\n        }\n        window.setTimeout(()=>{\n            handleCycleSnapPoints();\n        }, DOUBLE_TAP_TIMEOUT);\n    }\n    function handleCycleSnapPoints() {\n        // Prevent accidental taps while resizing drawer\n        if (isDragging || preventCycle || shouldCancelInteractionRef.current) {\n            handleCancelInteraction();\n            return;\n        }\n        // Make sure to clear the timeout id if the user releases the handle before the cancel timeout\n        handleCancelInteraction();\n        if (!snapPoints || snapPoints.length === 0) {\n            if (!dismissible) {\n                closeDrawer();\n            }\n            return;\n        }\n        const isLastSnapPoint = activeSnapPoint === snapPoints[snapPoints.length - 1];\n        if (isLastSnapPoint && dismissible) {\n            closeDrawer();\n            return;\n        }\n        const currentSnapIndex = snapPoints.findIndex((point)=>point === activeSnapPoint);\n        if (currentSnapIndex === -1) return; // activeSnapPoint not found in snapPoints\n        const nextSnapPoint = snapPoints[currentSnapIndex + 1];\n        setActiveSnapPoint(nextSnapPoint);\n    }\n    function handleStartInteraction() {\n        closeTimeoutIdRef.current = window.setTimeout(()=>{\n            // Cancel click interaction on a long press\n            shouldCancelInteractionRef.current = true;\n        }, LONG_HANDLE_PRESS_TIMEOUT);\n    }\n    function handleCancelInteraction() {\n        if (closeTimeoutIdRef.current) {\n            window.clearTimeout(closeTimeoutIdRef.current);\n        }\n        shouldCancelInteractionRef.current = false;\n    }\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        onClick: handleStartCycle,\n        onPointerCancel: handleCancelInteraction,\n        onPointerDown: (e)=>{\n            if (handleOnly) onPress(e);\n            handleStartInteraction();\n        },\n        onPointerMove: (e)=>{\n            if (handleOnly) onDrag(e);\n        },\n        // onPointerUp is already handled by the content component\n        ref: ref,\n        \"data-vaul-drawer-visible\": isOpen ? 'true' : 'false',\n        \"data-vaul-handle\": \"\",\n        \"aria-hidden\": \"true\",\n        ...rest\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", {\n        \"data-vaul-handle-hitarea\": \"\",\n        \"aria-hidden\": \"true\"\n    }, children));\n});\nHandle.displayName = 'Drawer.Handle';\nfunction NestedRoot({ onDrag, onOpenChange, open: nestedIsOpen, ...rest }) {\n    const { onNestedDrag, onNestedOpenChange, onNestedRelease } = useDrawerContext();\n    if (!onNestedDrag) {\n        throw new Error('Drawer.NestedRoot must be placed in another drawer');\n    }\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Root, {\n        nested: true,\n        open: nestedIsOpen,\n        onClose: ()=>{\n            onNestedOpenChange(false);\n        },\n        onDrag: (e, p)=>{\n            onNestedDrag(e, p);\n            onDrag == null ? void 0 : onDrag(e, p);\n        },\n        onOpenChange: (o)=>{\n            if (o) {\n                onNestedOpenChange(o);\n            }\n            onOpenChange == null ? void 0 : onOpenChange(o);\n        },\n        onRelease: onNestedRelease,\n        ...rest\n    });\n}\nfunction Portal(props) {\n    const context = useDrawerContext();\n    const { container = context.container, ...portalProps } = props;\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_radix_ui_react_dialog__WEBPACK_IMPORTED_MODULE_1__.Portal, {\n        container: container,\n        ...portalProps\n    });\n}\nconst Drawer = {\n    Root,\n    NestedRoot,\n    Content,\n    Overlay,\n    Trigger: _radix_ui_react_dialog__WEBPACK_IMPORTED_MODULE_1__.Trigger,\n    Portal,\n    Handle,\n    Close: _radix_ui_react_dialog__WEBPACK_IMPORTED_MODULE_1__.Close,\n    Title: _radix_ui_react_dialog__WEBPACK_IMPORTED_MODULE_1__.Title,\n    Description: _radix_ui_react_dialog__WEBPACK_IMPORTED_MODULE_1__.Description\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdmF1bC9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7MEdBQ0EsU0FBU0EsWUFBWUMsSUFBSTtJQUN2QixJQUFJLENBQUNBLFFBQVEsT0FBT0MsWUFBWSxhQUFhO0lBQzdDLElBQUlDLE9BQU9ELFNBQVNDLElBQUksSUFBSUQsU0FBU0Usb0JBQW9CLENBQUMsT0FBTyxDQUFDLEVBQUU7SUFDcEUsSUFBSUMsUUFBUUgsU0FBU0ksYUFBYSxDQUFDO0lBQ25DRCxNQUFNRSxJQUFJLEdBQUc7SUFDYkosS0FBS0ssV0FBVyxDQUFDSDtJQUNoQkEsTUFBTUksVUFBVSxHQUFJSixNQUFNSSxVQUFVLENBQUNDLE9BQU8sR0FBR1QsT0FBUUksTUFBTUcsV0FBVyxDQUFDTixTQUFTUyxjQUFjLENBQUNWO0FBQ3BHO0FBRTBEO0FBQzNCO0FBQzZDO0FBRTVFLE1BQU1pQiw4QkFBZ0JKLGdEQUE0QixDQUFDO0lBQy9DTSxXQUFXO1FBQ1BDLFNBQVM7SUFDYjtJQUNBQyxZQUFZO1FBQ1JELFNBQVM7SUFDYjtJQUNBRSxTQUFTLEtBQUs7SUFDZEMsV0FBVyxLQUFLO0lBQ2hCQyxRQUFRLEtBQUs7SUFDYkMsY0FBYyxLQUFLO0lBQ25CQyxvQkFBb0IsS0FBSztJQUN6QkMsaUJBQWlCLEtBQUs7SUFDdEJDLFVBQVVDO0lBQ1ZDLGFBQWE7SUFDYkMsUUFBUTtJQUNSQyxZQUFZO0lBQ1pDLGdCQUFnQjtRQUNaYixTQUFTO0lBQ2I7SUFDQWMsa0JBQWtCO0lBQ2xCQyxZQUFZO0lBQ1pDLFlBQVk7SUFDWkMsT0FBTztJQUNQQyxZQUFZO0lBQ1pDLGlCQUFpQjtJQUNqQkMsY0FBYyxLQUFLO0lBQ25CQyxvQkFBb0IsS0FBSztJQUN6QkMsYUFBYSxLQUFLO0lBQ2xCQyxXQUFXO0lBQ1hDLGVBQWU7UUFDWHhCLFNBQVM7SUFDYjtJQUNBeUIsdUJBQXVCO0lBQ3ZCQywyQkFBMkI7SUFDM0JDLGNBQWM7SUFDZEMsV0FBVztJQUNYQyxXQUFXO0FBQ2Y7QUFDQSxNQUFNQyxtQkFBbUI7SUFDckIsTUFBTUMsVUFBVXRDLDZDQUF5QixDQUFDSTtJQUMxQyxJQUFJLENBQUNrQyxTQUFTO1FBQ1YsTUFBTSxJQUFJRSxNQUFNO0lBQ3BCO0lBQ0EsT0FBT0Y7QUFDWDtBQUVBcEQsWUFBWTtBQUVaLFNBQVN1RDtJQUNMLE1BQU1DLFlBQVlDLFVBQVVELFNBQVM7SUFDckMsT0FBTyxNQUE2QixJQUFLLEVBQ2xCQSxDQUFDLGNBQWM7SUFBaEI7QUFFMUI7QUFDQSxTQUFTRztJQUNMLE9BQU9DLGFBQWE7QUFDeEI7QUFDQSxTQUFTQztJQUNMLE9BQU9ELGFBQWE7QUFDeEI7QUFDQSxTQUFTRTtJQUNMLE9BQU8saUNBQWlDSixJQUFJLENBQUNELFVBQVVELFNBQVM7QUFDcEU7QUFDQSxTQUFTTztJQUNMLE9BQU9ILGFBQWEsWUFBWSx5RkFBeUY7SUFDekhELFdBQVdGLFVBQVVPLGNBQWMsR0FBRztBQUMxQztBQUNBLFNBQVNDO0lBQ0wsT0FBT0osY0FBY0U7QUFDekI7QUFDQSxTQUFTSCxhQUFhTSxFQUFFO0lBQ3BCLE9BQU8sTUFBeUQsR0FBR0EsQ0FBa0MsR0FBR3BDO0FBQzVHO0FBRUEsaUlBQWlJO0FBQ2pJLE1BQU11QyxrQkFBa0I7QUFDeEIsTUFBTUMsNEJBQTRCLE1BQTZCLEdBQUd2RCxDQUFlQSxHQUFHQyw0Q0FBU0E7QUFDN0YsU0FBU3VELFFBQVEsR0FBR0MsU0FBUztJQUN6QixPQUFPLENBQUMsR0FBR0M7UUFDUCxLQUFLLElBQUlDLFlBQVlGLFVBQVU7WUFDM0IsSUFBSSxPQUFPRSxhQUFhLFlBQVk7Z0JBQ2hDQSxZQUFZRDtZQUNoQjtRQUNKO0lBQ0o7QUFDSjtBQUNBLGFBQWE7QUFDYixNQUFNRSxpQkFBaUIsT0FBT3pFLGFBQWEsZUFBZWlFLE9BQU9RLGNBQWM7QUFDL0UsU0FBU0MsYUFBYUMsSUFBSTtJQUN0QixJQUFJeEUsUUFBUThELE9BQU9XLGdCQUFnQixDQUFDRDtJQUNwQyxPQUFPLGdCQUFnQm5CLElBQUksQ0FBQ3JELE1BQU0wRSxRQUFRLEdBQUcxRSxNQUFNMkUsU0FBUyxHQUFHM0UsTUFBTTRFLFNBQVM7QUFDbEY7QUFDQSxTQUFTQyxnQkFBZ0JMLElBQUk7SUFDekIsSUFBSUQsYUFBYUMsT0FBTztRQUNwQkEsT0FBT0EsS0FBS00sYUFBYTtJQUM3QjtJQUNBLE1BQU1OLFFBQVEsQ0FBQ0QsYUFBYUMsTUFBTTtRQUM5QkEsT0FBT0EsS0FBS00sYUFBYTtJQUM3QjtJQUNBLE9BQU9OLFFBQVEzRSxTQUFTa0YsZ0JBQWdCLElBQUlsRixTQUFTbUYsZUFBZTtBQUN4RTtBQUNBLHNFQUFzRTtBQUN0RSxNQUFNQyxvQkFBb0IsSUFBSUMsSUFBSTtJQUM5QjtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7Q0FDSDtBQUNELG1JQUFtSTtBQUNuSSxJQUFJQyxxQkFBcUI7QUFDekIsSUFBSUM7QUFDSjs7OztDQUlDLEdBQUcsU0FBU0MsaUJBQWlCQyxVQUFVLENBQUMsQ0FBQztJQUN0QyxJQUFJLEVBQUVDLFVBQVUsRUFBRSxHQUFHRDtJQUNyQnJCO3NEQUEwQjtZQUN0QixJQUFJc0IsWUFBWTtnQkFDWjtZQUNKO1lBQ0FKO1lBQ0EsSUFBSUEsdUJBQXVCLEdBQUc7Z0JBQzFCLElBQUl2QixTQUFTO29CQUNUd0IsVUFBVUk7Z0JBQ2Q7WUFDSjtZQUNBOzhEQUFPO29CQUNITDtvQkFDQSxJQUFJQSx1QkFBdUIsR0FBRzt3QkFDMUJDLFdBQVcsT0FBTyxLQUFLLElBQUlBO29CQUMvQjtnQkFDSjs7UUFDSjtxREFBRztRQUNDRztLQUNIO0FBQ0w7QUFDQSx3RUFBd0U7QUFDeEUsZ0RBQWdEO0FBQ2hELEVBQUU7QUFDRiw4RkFBOEY7QUFDOUYsc0dBQXNHO0FBQ3RHLG1DQUFtQztBQUNuQyw2R0FBNkc7QUFDN0csMkVBQTJFO0FBQzNFLDRHQUE0RztBQUM1RyxzR0FBc0c7QUFDdEcsRUFBRTtBQUNGLG9HQUFvRztBQUNwRyxFQUFFO0FBQ0YsK0dBQStHO0FBQy9HLG9CQUFvQjtBQUNwQiwwR0FBMEc7QUFDMUcsa0dBQWtHO0FBQ2xHLHVHQUF1RztBQUN2RyxxR0FBcUc7QUFDckcsNEdBQTRHO0FBQzVHLDREQUE0RDtBQUM1RCxrSEFBa0g7QUFDbEgsMEdBQTBHO0FBQzFHLG9GQUFvRjtBQUNwRixnSEFBZ0g7QUFDaEgsb0ZBQW9GO0FBQ3BGLFNBQVNDO0lBQ0wsSUFBSUM7SUFDSixJQUFJQyxRQUFRO0lBQ1osSUFBSUMsZUFBZSxDQUFDQztRQUNoQixzRkFBc0Y7UUFDdEZILGFBQWFaLGdCQUFnQmUsRUFBRUMsTUFBTTtRQUNyQyxJQUFJSixlQUFlNUYsU0FBU21GLGVBQWUsSUFBSVMsZUFBZTVGLFNBQVNpRyxJQUFJLEVBQUU7WUFDekU7UUFDSjtRQUNBSixRQUFRRSxFQUFFRyxjQUFjLENBQUMsRUFBRSxDQUFDQyxLQUFLO0lBQ3JDO0lBQ0EsSUFBSUMsY0FBYyxDQUFDTDtRQUNmLGdDQUFnQztRQUNoQyxJQUFJLENBQUNILGNBQWNBLGVBQWU1RixTQUFTbUYsZUFBZSxJQUFJUyxlQUFlNUYsU0FBU2lHLElBQUksRUFBRTtZQUN4RkYsRUFBRU0sY0FBYztZQUNoQjtRQUNKO1FBQ0EsNkVBQTZFO1FBQzdFLDRFQUE0RTtRQUM1RSw0RUFBNEU7UUFDNUUsdUNBQXVDO1FBQ3ZDLElBQUlDLElBQUlQLEVBQUVHLGNBQWMsQ0FBQyxFQUFFLENBQUNDLEtBQUs7UUFDakMsSUFBSUksWUFBWVgsV0FBV1csU0FBUztRQUNwQyxJQUFJQyxTQUFTWixXQUFXYSxZQUFZLEdBQUdiLFdBQVdjLFlBQVk7UUFDOUQsSUFBSUYsV0FBVyxHQUFHO1lBQ2Q7UUFDSjtRQUNBLElBQUlELGFBQWEsS0FBS0QsSUFBSVQsU0FBU1UsYUFBYUMsVUFBVUYsSUFBSVQsT0FBTztZQUNqRUUsRUFBRU0sY0FBYztRQUNwQjtRQUNBUixRQUFRUztJQUNaO0lBQ0EsSUFBSUssYUFBYSxDQUFDWjtRQUNkLElBQUlDLFNBQVNELEVBQUVDLE1BQU07UUFDckIsdUVBQXVFO1FBQ3ZFLElBQUlZLFFBQVFaLFdBQVdBLFdBQVdoRyxTQUFTNkcsYUFBYSxFQUFFO1lBQ3REZCxFQUFFTSxjQUFjO1lBQ2hCLHNGQUFzRjtZQUN0RixvRkFBb0Y7WUFDcEYsK0VBQStFO1lBQy9FTCxPQUFPN0YsS0FBSyxDQUFDMkcsU0FBUyxHQUFHO1lBQ3pCZCxPQUFPZSxLQUFLO1lBQ1pDLHNCQUFzQjtnQkFDbEJoQixPQUFPN0YsS0FBSyxDQUFDMkcsU0FBUyxHQUFHO1lBQzdCO1FBQ0o7SUFDSjtJQUNBLElBQUlHLFVBQVUsQ0FBQ2xCO1FBQ1gsSUFBSUMsU0FBU0QsRUFBRUMsTUFBTTtRQUNyQixJQUFJWSxRQUFRWixTQUFTO1lBQ2pCLG1GQUFtRjtZQUNuRixpRkFBaUY7WUFDakYsd0ZBQXdGO1lBQ3hGLCtGQUErRjtZQUMvRkEsT0FBTzdGLEtBQUssQ0FBQzJHLFNBQVMsR0FBRztZQUN6QkUsc0JBQXNCO2dCQUNsQmhCLE9BQU83RixLQUFLLENBQUMyRyxTQUFTLEdBQUc7Z0JBQ3pCLHFGQUFxRjtnQkFDckYsd0ZBQXdGO2dCQUN4RixJQUFJckMsZ0JBQWdCO29CQUNoQixJQUFJQSxlQUFleUMsTUFBTSxHQUFHakQsT0FBT2tELFdBQVcsRUFBRTt3QkFDNUMseUVBQXlFO3dCQUN6RSwyQ0FBMkM7d0JBQzNDSCxzQkFBc0I7NEJBQ2xCSSxlQUFlcEI7d0JBQ25CO29CQUNKLE9BQU87d0JBQ0gsK0VBQStFO3dCQUMvRSw2Q0FBNkM7d0JBQzdDdkIsZUFBZTRDLGdCQUFnQixDQUFDLFVBQVUsSUFBSUQsZUFBZXBCLFNBQVM7NEJBQ2xFc0IsTUFBTTt3QkFDVjtvQkFDSjtnQkFDSjtZQUNKO1FBQ0o7SUFDSjtJQUNBLElBQUlDLGlCQUFpQjtRQUNqQixrRUFBa0U7UUFDbEUsMkZBQTJGO1FBQzNGdEQsT0FBT3VELFFBQVEsQ0FBQyxHQUFHO0lBQ3ZCO0lBQ0EsNERBQTREO0lBQzVELDBGQUEwRjtJQUMxRiw2RkFBNkY7SUFDN0YsSUFBSUMsVUFBVXhELE9BQU95RCxXQUFXO0lBQ2hDLElBQUlDLFVBQVUxRCxPQUFPMkQsV0FBVztJQUNoQyxJQUFJQyxnQkFBZ0J4RCxRQUFReUQsU0FBUzlILFNBQVNtRixlQUFlLEVBQUUsZ0JBQWdCLEdBQUdsQixPQUFPOEQsVUFBVSxHQUFHL0gsU0FBU21GLGVBQWUsQ0FBQzZDLFdBQVcsQ0FBQyxFQUFFLENBQUM7SUFDOUkscUZBQXFGO0lBQ3JGL0QsT0FBT3VELFFBQVEsQ0FBQyxHQUFHO0lBQ25CLElBQUlTLGVBQWU1RCxRQUFRNkQsU0FBU2xJLFVBQVUsY0FBYzhGLGNBQWM7UUFDdEVxQyxTQUFTO1FBQ1RDLFNBQVM7SUFDYixJQUFJRixTQUFTbEksVUFBVSxhQUFhb0csYUFBYTtRQUM3QytCLFNBQVM7UUFDVEMsU0FBUztJQUNiLElBQUlGLFNBQVNsSSxVQUFVLFlBQVkyRyxZQUFZO1FBQzNDd0IsU0FBUztRQUNUQyxTQUFTO0lBQ2IsSUFBSUYsU0FBU2xJLFVBQVUsU0FBU2lILFNBQVMsT0FBT2lCLFNBQVNqRSxRQUFRLFVBQVVzRDtJQUMzRSxPQUFPO1FBQ0gsMkRBQTJEO1FBQzNETTtRQUNBSTtRQUNBaEUsT0FBT3VELFFBQVEsQ0FBQ0MsU0FBU0U7SUFDN0I7QUFDSjtBQUNBLGdHQUFnRztBQUNoRyxTQUFTRyxTQUFTTyxPQUFPLEVBQUVsSSxLQUFLLEVBQUVtSSxLQUFLO0lBQ25DLDhFQUE4RTtJQUM5RSxhQUFhO0lBQ2IsSUFBSUMsTUFBTUYsUUFBUWxJLEtBQUssQ0FBQ0EsTUFBTTtJQUM5QixhQUFhO0lBQ2JrSSxRQUFRbEksS0FBSyxDQUFDQSxNQUFNLEdBQUdtSTtJQUN2QixPQUFPO1FBQ0gsYUFBYTtRQUNiRCxRQUFRbEksS0FBSyxDQUFDQSxNQUFNLEdBQUdvSTtJQUMzQjtBQUNKO0FBQ0EsNkVBQTZFO0FBQzdFLFNBQVNMLFNBQVNsQyxNQUFNLEVBQUV3QyxLQUFLLEVBQUVDLE9BQU8sRUFBRWhELE9BQU87SUFDN0MsYUFBYTtJQUNiTyxPQUFPcUIsZ0JBQWdCLENBQUNtQixPQUFPQyxTQUFTaEQ7SUFDeEMsT0FBTztRQUNILGFBQWE7UUFDYk8sT0FBTzBDLG1CQUFtQixDQUFDRixPQUFPQyxTQUFTaEQ7SUFDL0M7QUFDSjtBQUNBLFNBQVMyQixlQUFlcEIsTUFBTTtJQUMxQixJQUFJMkMsT0FBTzNJLFNBQVNrRixnQkFBZ0IsSUFBSWxGLFNBQVNtRixlQUFlO0lBQ2hFLE1BQU1hLFVBQVVBLFdBQVcyQyxLQUFLO1FBQzVCLDBHQUEwRztRQUMxRyxJQUFJL0MsYUFBYVosZ0JBQWdCZ0I7UUFDakMsSUFBSUosZUFBZTVGLFNBQVNtRixlQUFlLElBQUlTLGVBQWU1RixTQUFTaUcsSUFBSSxJQUFJTCxlQUFlSSxRQUFRO1lBQ2xHLElBQUk0QyxnQkFBZ0JoRCxXQUFXaUQscUJBQXFCLEdBQUdDLEdBQUc7WUFDMUQsSUFBSUMsWUFBWS9DLE9BQU82QyxxQkFBcUIsR0FBR0MsR0FBRztZQUNsRCxJQUFJRSxlQUFlaEQsT0FBTzZDLHFCQUFxQixHQUFHckMsTUFBTTtZQUN4RCx1Q0FBdUM7WUFDdkMsTUFBTXlDLGlCQUFpQnJELFdBQVdpRCxxQkFBcUIsR0FBR3JDLE1BQU0sR0FBR3JDO1lBQ25FLElBQUk2RSxlQUFlQyxnQkFBZ0I7Z0JBQy9CckQsV0FBV1csU0FBUyxJQUFJd0MsWUFBWUg7WUFDeEM7UUFDSjtRQUNBLGFBQWE7UUFDYjVDLFNBQVNKLFdBQVdYLGFBQWE7SUFDckM7QUFDSjtBQUNBLFNBQVMyQixRQUFRWixNQUFNO0lBQ25CLE9BQU9BLGtCQUFrQmtELG9CQUFvQixDQUFDOUQsa0JBQWtCK0QsR0FBRyxDQUFDbkQsT0FBTzNGLElBQUksS0FBSzJGLGtCQUFrQm9ELHVCQUF1QnBELGtCQUFrQnFELGVBQWVyRCxPQUFPc0QsaUJBQWlCO0FBQzFMO0FBRUEsb0dBQW9HO0FBQ3BHOzs7Q0FHQyxHQUFHLFNBQVNDLE9BQU9DLEdBQUcsRUFBRWxCLEtBQUs7SUFDMUIsSUFBSSxPQUFPa0IsUUFBUSxZQUFZO1FBQzNCQSxJQUFJbEI7SUFDUixPQUFPLElBQUlrQixRQUFRLFFBQVFBLFFBQVE1SCxXQUFXO1FBQzFDNEgsSUFBSXJJLE9BQU8sR0FBR21IO0lBQ2xCO0FBQ0o7QUFDQTs7O0NBR0MsR0FBRyxTQUFTbUIsWUFBWSxHQUFHQyxJQUFJO0lBQzVCLE9BQU8sQ0FBQy9FLE9BQU8rRSxLQUFLQyxPQUFPLENBQUMsQ0FBQ0gsTUFBTUQsT0FBT0MsS0FBSzdFO0FBQ25EO0FBQ0E7OztDQUdDLEdBQUcsU0FBU2lGLGdCQUFnQixHQUFHRixJQUFJO0lBQ2hDLHVEQUF1RDtJQUN2RCxPQUFPL0ksOENBQWlCLENBQUM4SSxlQUFlQyxPQUFPQTtBQUNuRDtBQUVBLE1BQU1JLFFBQVEsSUFBSUM7QUFDbEIsU0FBU0MsSUFBSUMsRUFBRSxFQUFFQyxNQUFNLEVBQUVDLGNBQWMsS0FBSztJQUN4QyxJQUFJLENBQUNGLE1BQU0sQ0FBRUEsQ0FBQUEsY0FBY1osV0FBVSxHQUFJO0lBQ3pDLElBQUllLGlCQUFpQixDQUFDO0lBQ3RCQyxPQUFPQyxPQUFPLENBQUNKLFFBQVFQLE9BQU8sQ0FBQyxDQUFDLENBQUNZLEtBQUtqQyxNQUFNO1FBQ3hDLElBQUlpQyxJQUFJQyxVQUFVLENBQUMsT0FBTztZQUN0QlAsR0FBRzlKLEtBQUssQ0FBQ3NLLFdBQVcsQ0FBQ0YsS0FBS2pDO1lBQzFCO1FBQ0o7UUFDQThCLGNBQWMsQ0FBQ0csSUFBSSxHQUFHTixHQUFHOUosS0FBSyxDQUFDb0ssSUFBSTtRQUNuQ04sR0FBRzlKLEtBQUssQ0FBQ29LLElBQUksR0FBR2pDO0lBQ3BCO0lBQ0EsSUFBSTZCLGFBQWE7SUFDakJMLE1BQU1FLEdBQUcsQ0FBQ0MsSUFBSUc7QUFDbEI7QUFDQSxTQUFTTSxNQUFNVCxFQUFFLEVBQUVVLElBQUk7SUFDbkIsSUFBSSxDQUFDVixNQUFNLENBQUVBLENBQUFBLGNBQWNaLFdBQVUsR0FBSTtJQUN6QyxJQUFJZSxpQkFBaUJOLE1BQU1jLEdBQUcsQ0FBQ1g7SUFDL0IsSUFBSSxDQUFDRyxnQkFBZ0I7UUFDakI7SUFDSjtJQUNBO1FBQ0lILEdBQUc5SixLQUFLLENBQUN3SyxLQUFLLEdBQUdQLGNBQWMsQ0FBQ08sS0FBSztJQUN6QztBQUNKO0FBQ0EsTUFBTUUsYUFBYSxDQUFDbkk7SUFDaEIsT0FBT0E7UUFDSCxLQUFLO1FBQ0wsS0FBSztZQUNELE9BQU87UUFDWCxLQUFLO1FBQ0wsS0FBSztZQUNELE9BQU87UUFDWDtZQUNJLE9BQU9BO0lBQ2Y7QUFDSjtBQUNBLFNBQVNvSSxhQUFhekMsT0FBTyxFQUFFM0YsU0FBUztJQUNwQyxJQUFJLENBQUMyRixTQUFTO1FBQ1YsT0FBTztJQUNYO0lBQ0EsTUFBTWxJLFFBQVE4RCxPQUFPVyxnQkFBZ0IsQ0FBQ3lEO0lBQ3RDLE1BQU12QixZQUNOM0csTUFBTTJHLFNBQVMsSUFBSTNHLE1BQU00SyxlQUFlLElBQUk1SyxNQUFNNkssWUFBWTtJQUM5RCxJQUFJQyxNQUFNbkUsVUFBVW9FLEtBQUssQ0FBQztJQUMxQixJQUFJRCxLQUFLO1FBQ0wsK0VBQStFO1FBQy9FLE9BQU9FLFdBQVdGLEdBQUcsQ0FBQyxFQUFFLENBQUNHLEtBQUssQ0FBQyxLQUFLLENBQUNQLFdBQVduSSxhQUFhLEtBQUssR0FBRztJQUN6RTtJQUNBLDZFQUE2RTtJQUM3RXVJLE1BQU1uRSxVQUFVb0UsS0FBSyxDQUFDO0lBQ3RCLE9BQU9ELE1BQU1FLFdBQVdGLEdBQUcsQ0FBQyxFQUFFLENBQUNHLEtBQUssQ0FBQyxLQUFLLENBQUNQLFdBQVduSSxhQUFhLElBQUksRUFBRSxJQUFJO0FBQ2pGO0FBQ0EsU0FBUzJJLFlBQVlDLENBQUM7SUFDbEIsT0FBTyxJQUFLQyxDQUFBQSxLQUFLQyxHQUFHLENBQUNGLElBQUksS0FBSztBQUNsQztBQUNBLFNBQVNHLFlBQVlwRCxPQUFPLEVBQUVsSSxLQUFLO0lBQy9CLElBQUksQ0FBQ2tJLFNBQVMsT0FBTyxLQUFLO0lBQzFCLE1BQU1xRCxZQUFZckQsUUFBUWxJLEtBQUssQ0FBQ0ssT0FBTztJQUN2QzZKLE9BQU9zQixNQUFNLENBQUN0RCxRQUFRbEksS0FBSyxFQUFFQTtJQUM3QixPQUFPO1FBQ0hrSSxRQUFRbEksS0FBSyxDQUFDSyxPQUFPLEdBQUdrTDtJQUM1QjtBQUNKO0FBQ0E7O0NBRUMsR0FBRyxTQUFTRSxNQUFNLEdBQUdDLEdBQUc7SUFDckIsT0FBTyxDQUFDLEdBQUd0SDtRQUNQLEtBQUssTUFBTXVILE1BQU1ELElBQUk7WUFDakIsSUFBSSxPQUFPQyxPQUFPLFlBQVk7Z0JBQzFCLGFBQWE7Z0JBQ2JBLE1BQU12SDtZQUNWO1FBQ0o7SUFDSjtBQUNKO0FBRUEsTUFBTXdILGNBQWM7SUFDaEJDLFVBQVU7SUFDVkMsTUFBTTtRQUNGO1FBQ0E7UUFDQTtRQUNBO0tBQ0g7QUFDTDtBQUNBLE1BQU1DLHFCQUFxQjtBQUMzQixNQUFNQyxrQkFBa0I7QUFDeEIsTUFBTUMsc0JBQXNCO0FBQzVCLE1BQU1DLGdCQUFnQjtBQUN0QixNQUFNQyxzQkFBc0I7QUFDNUIsTUFBTUMsb0JBQW9CO0FBQzFCLE1BQU1DLGFBQWE7QUFFbkIsMklBQTJJO0FBQzNJLFNBQVNDLGVBQWVqSSxRQUFRO0lBQzVCLE1BQU1rSSxjQUFjOUwseUNBQXFCLENBQUM0RDtJQUMxQzVELDRDQUF3QjtvQ0FBQztZQUNyQjhMLFlBQVl2TCxPQUFPLEdBQUdxRDtRQUMxQjs7SUFDQSxpREFBaUQ7SUFDakQsT0FBTzVELDBDQUFzQjtrQ0FBQzswQ0FBSSxDQUFDLEdBQUcyRCxPQUFPbUksWUFBWXZMLE9BQU8sSUFBSSxPQUFPLEtBQUssSUFBSXVMLFlBQVl2TCxPQUFPLENBQUN5TCxJQUFJLENBQUNGLGdCQUFnQm5JOztpQ0FBTyxFQUFFO0FBQzFJO0FBQ0EsU0FBU3NJLHFCQUFxQixFQUFFQyxXQUFXLEVBQUVDLFFBQVEsRUFBRTtJQUNuRCxNQUFNQyxvQkFBb0JwTSwyQ0FBdUIsQ0FBQ2tNO0lBQ2xELE1BQU0sQ0FBQ3hFLE1BQU0sR0FBRzBFO0lBQ2hCLE1BQU1FLGVBQWV0TSx5Q0FBcUIsQ0FBQzBIO0lBQzNDLE1BQU02RSxlQUFlVixlQUFlTTtJQUNwQ25NLDRDQUF3QjswQ0FBQztZQUNyQixJQUFJc00sYUFBYS9MLE9BQU8sS0FBS21ILE9BQU87Z0JBQ2hDNkUsYUFBYTdFO2dCQUNiNEUsYUFBYS9MLE9BQU8sR0FBR21IO1lBQzNCO1FBQ0o7eUNBQUc7UUFDQ0E7UUFDQTRFO1FBQ0FDO0tBQ0g7SUFDRCxPQUFPSDtBQUNYO0FBQ0EsU0FBU0kscUJBQXFCLEVBQUV6QyxJQUFJLEVBQUVtQyxXQUFXLEVBQUVDLFdBQVcsS0FBSyxDQUFDLEVBQUU7SUFDbEUsTUFBTSxDQUFDTSxrQkFBa0JDLG9CQUFvQixHQUFHVCxxQkFBcUI7UUFDakVDO1FBQ0FDO0lBQ0o7SUFDQSxNQUFNUSxlQUFlNUMsU0FBUy9JO0lBQzlCLE1BQU0wRyxRQUFRaUYsZUFBZTVDLE9BQU8wQztJQUNwQyxNQUFNRixlQUFlVixlQUFlTTtJQUNwQyxNQUFNUyxXQUFXNU0sOENBQTBCO3NEQUFDLENBQUM2TTtZQUN6QyxJQUFJRixjQUFjO2dCQUNkLE1BQU1HLFNBQVNEO2dCQUNmLE1BQU1uRixRQUFRLE9BQU9tRixjQUFjLGFBQWFDLE9BQU8vQyxRQUFROEM7Z0JBQy9ELElBQUluRixVQUFVcUMsTUFBTXdDLGFBQWE3RTtZQUNyQyxPQUFPO2dCQUNIZ0Ysb0JBQW9CRztZQUN4QjtRQUNKO3FEQUFHO1FBQ0NGO1FBQ0E1QztRQUNBMkM7UUFDQUg7S0FDSDtJQUNELE9BQU87UUFDSDdFO1FBQ0FrRjtLQUNIO0FBQ0w7QUFFQSxTQUFTRyxjQUFjLEVBQUVDLG1CQUFtQixFQUFFQyxzQkFBc0IsRUFBRTNMLFVBQVUsRUFBRWhCLFNBQVMsRUFBRUUsVUFBVSxFQUFFME0sYUFBYSxFQUFFQyxpQkFBaUIsRUFBRXJMLFlBQVksUUFBUSxFQUFFSyxTQUFTLEVBQUVpTCxxQkFBcUIsRUFBRTtJQUMvTCxNQUFNLENBQUMxTCxpQkFBaUJFLG1CQUFtQixHQUFHNEsscUJBQXFCO1FBQy9EekMsTUFBTWlEO1FBQ05kLGFBQWE1SyxjQUFjLE9BQU8sS0FBSyxJQUFJQSxVQUFVLENBQUMsRUFBRTtRQUN4RDZLLFVBQVVjO0lBQ2Q7SUFDQSxNQUFNLENBQUNJLGtCQUFrQkMsb0JBQW9CLEdBQUd0TiwyQ0FBdUIsQ0FBQyxNQUE2QixHQUFHLENBR3ZHLEdBQUdnQjtJQUNKaEIsNENBQXdCO21DQUFDO1lBQ3JCLFNBQVN1TjtnQkFDTEQsb0JBQW9CO29CQUNoQm5HLFlBQVk5RCxPQUFPOEQsVUFBVTtvQkFDN0JaLGFBQWFsRCxPQUFPa0QsV0FBVztnQkFDbkM7WUFDSjtZQUNBbEQsT0FBT29ELGdCQUFnQixDQUFDLFVBQVU4RztZQUNsQzsyQ0FBTyxJQUFJbEssT0FBT3lFLG1CQUFtQixDQUFDLFVBQVV5Rjs7UUFDcEQ7a0NBQUcsRUFBRTtJQUNMLE1BQU1DLGtCQUFrQnhOLDBDQUFzQjtrREFBQyxJQUFJMEIsb0JBQXFCSixDQUFBQSxjQUFjLE9BQU8sS0FBSyxJQUFJQSxVQUFVLENBQUNBLFdBQVdtTSxNQUFNLEdBQUcsRUFBRSxLQUFLO2lEQUFNO1FBQzlJbk07UUFDQUk7S0FDSDtJQUNELE1BQU1nTSx1QkFBdUIxTiwwQ0FBc0I7dURBQUM7WUFDaEQsSUFBSTJOO1lBQ0osT0FBTyxDQUFDQSx3QkFBd0JyTSxjQUFjLE9BQU8sS0FBSyxJQUFJQSxXQUFXc00sU0FBUzsrREFBQyxDQUFDQyxZQUFZQSxjQUFjbk07NkRBQWUsS0FBTSxPQUFPaU0sd0JBQXdCO1FBQ3RLO3NEQUFHO1FBQ0NyTTtRQUNBSTtLQUNIO0lBQ0QsTUFBTUQsYUFBYUgsY0FBY0EsV0FBV21NLE1BQU0sR0FBRyxLQUFNUCxDQUFBQSxpQkFBaUJBLGtCQUFrQixNQUFNLENBQUNZLE9BQU9DLEtBQUssQ0FBQ2Isa0JBQWtCNUwsVUFBVSxDQUFDNEwsY0FBYyxLQUFLeEwsbUJBQW1CLENBQUNKO0lBQ3RMLE1BQU1ELG1CQUFtQnJCLDBDQUFzQjttREFBQztZQUM1QyxNQUFNZ08sZ0JBQWdCN0wsWUFBWTtnQkFDOUI4TCxPQUFPOUwsVUFBVThGLHFCQUFxQixHQUFHZ0csS0FBSztnQkFDOUMzSCxRQUFRbkUsVUFBVThGLHFCQUFxQixHQUFHM0IsTUFBTTtZQUNwRCxJQUFJLE1BQTZCLEdBQUcsQ0FHbkMsR0FBRztnQkFDQTJILE9BQU87Z0JBQ1AzSCxRQUFRO1lBQ1o7WUFDQSxJQUFJNEg7WUFDSixPQUFPLENBQUNBLGtCQUFrQjVNLGNBQWMsT0FBTyxLQUFLLElBQUlBLFdBQVc2TSxHQUFHOzJEQUFDLENBQUNOO29CQUNwRSxNQUFNTyxPQUFPLE9BQU9QLGNBQWM7b0JBQ2xDLElBQUlRLG9CQUFvQjtvQkFDeEIsSUFBSUQsTUFBTTt3QkFDTkMsb0JBQW9CQyxTQUFTVCxXQUFXO29CQUM1QztvQkFDQSxJQUFJNUQsV0FBV25JLFlBQVk7d0JBQ3ZCLE1BQU13RSxTQUFTOEgsT0FBT0Msb0JBQW9CaEIsbUJBQW1CUSxZQUFZRyxjQUFjMUgsTUFBTSxHQUFHO3dCQUNoRyxJQUFJK0csa0JBQWtCOzRCQUNsQixPQUFPdkwsY0FBYyxXQUFXa00sY0FBYzFILE1BQU0sR0FBR0EsU0FBUyxDQUFDMEgsY0FBYzFILE1BQU0sR0FBR0E7d0JBQzVGO3dCQUNBLE9BQU9BO29CQUNYO29CQUNBLE1BQU0ySCxRQUFRRyxPQUFPQyxvQkFBb0JoQixtQkFBbUJRLFlBQVlHLGNBQWNDLEtBQUssR0FBRztvQkFDOUYsSUFBSVosa0JBQWtCO3dCQUNsQixPQUFPdkwsY0FBYyxVQUFVa00sY0FBY0MsS0FBSyxHQUFHQSxRQUFRLENBQUNELGNBQWNDLEtBQUssR0FBR0E7b0JBQ3hGO29CQUNBLE9BQU9BO2dCQUNYO3lEQUFDLEtBQU0sT0FBT0Msa0JBQWtCLEVBQUU7UUFDdEM7a0RBQUc7UUFDQzVNO1FBQ0ErTDtRQUNBbEw7S0FDSDtJQUNELE1BQU1vTSx3QkFBd0J2TywwQ0FBc0I7d0RBQUMsSUFBSTBOLHlCQUF5QixPQUFPck0sb0JBQW9CLE9BQU8sS0FBSyxJQUFJQSxnQkFBZ0IsQ0FBQ3FNLHFCQUFxQixHQUFHO3VEQUFNO1FBQ3hLck07UUFDQXFNO0tBQ0g7SUFDRCxNQUFNYyxjQUFjeE8sOENBQTBCO2tEQUFDLENBQUN5TztZQUM1QyxJQUFJQztZQUNKLE1BQU1DLG9CQUFvQixDQUFDRCw4QkFBOEJyTixvQkFBb0IsT0FBTyxLQUFLLElBQUlBLGlCQUFpQnVNLFNBQVM7MERBQUMsQ0FBQ2dCLGVBQWVBLGlCQUFpQkg7d0RBQVMsS0FBTSxPQUFPQyw4QkFBOEI7WUFDN012QixrQkFBa0J3QjtZQUNsQnZGLElBQUk5SSxVQUFVQyxPQUFPLEVBQUU7Z0JBQ25Cc08sWUFBWSxDQUFDLFVBQVUsRUFBRTFELFlBQVlDLFFBQVEsQ0FBQyxlQUFlLEVBQUVELFlBQVlFLElBQUksQ0FBQ3lELElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztnQkFDNUY1SSxXQUFXK0QsV0FBV25JLGFBQWEsQ0FBQyxlQUFlLEVBQUUyTSxVQUFVLE1BQU0sQ0FBQyxHQUFHLENBQUMsWUFBWSxFQUFFQSxVQUFVLFNBQVMsQ0FBQztZQUNoSDtZQUNBLElBQUlwTixvQkFBb0JzTixzQkFBc0J0TixpQkFBaUJvTSxNQUFNLEdBQUcsS0FBS1Asa0JBQWtCbE0sYUFBYTJOLHNCQUFzQnpCLGlCQUFpQnlCLG9CQUFvQnpCLGVBQWU7Z0JBQ2xMOUQsSUFBSTVJLFdBQVdELE9BQU8sRUFBRTtvQkFDcEJzTyxZQUFZLENBQUMsUUFBUSxFQUFFMUQsWUFBWUMsUUFBUSxDQUFDLGVBQWUsRUFBRUQsWUFBWUUsSUFBSSxDQUFDeUQsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO29CQUMxRkMsU0FBUztnQkFDYjtZQUNKLE9BQU87Z0JBQ0gzRixJQUFJNUksV0FBV0QsT0FBTyxFQUFFO29CQUNwQnNPLFlBQVksQ0FBQyxRQUFRLEVBQUUxRCxZQUFZQyxRQUFRLENBQUMsZUFBZSxFQUFFRCxZQUFZRSxJQUFJLENBQUN5RCxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7b0JBQzFGQyxTQUFTO2dCQUNiO1lBQ0o7WUFDQW5OLG1CQUFtQk4sY0FBYyxPQUFPLEtBQUssSUFBSUEsVUFBVSxDQUFDcUosS0FBS3FFLEdBQUcsQ0FBQ0wsbUJBQW1CLEdBQUc7UUFDL0Y7aURBQUc7UUFDQ3JPLFVBQVVDLE9BQU87UUFDakJlO1FBQ0FEO1FBQ0E2TDtRQUNBMU07UUFDQW9CO0tBQ0g7SUFDRDVCLDRDQUF3QjttQ0FBQztZQUNyQixJQUFJMEIsbUJBQW1Cc0wscUJBQXFCO2dCQUN4QyxJQUFJVztnQkFDSixNQUFNc0IsV0FBVyxDQUFDdEIsd0JBQXdCck0sY0FBYyxPQUFPLEtBQUssSUFBSUEsV0FBV3NNLFNBQVM7K0NBQUMsQ0FBQ0MsWUFBWUEsY0FBY2IsdUJBQXVCYSxjQUFjbk07NkNBQWUsS0FBTSxPQUFPaU0sd0JBQXdCLENBQUM7Z0JBQ2xOLElBQUl0TSxvQkFBb0I0TixhQUFhLENBQUMsS0FBSyxPQUFPNU4sZ0JBQWdCLENBQUM0TixTQUFTLEtBQUssVUFBVTtvQkFDdkZULFlBQVluTixnQkFBZ0IsQ0FBQzROLFNBQVM7Z0JBQzFDO1lBQ0o7UUFDSjtrQ0FBRztRQUNDdk47UUFDQXNMO1FBQ0ExTDtRQUNBRDtRQUNBbU47S0FDSDtJQUNELFNBQVM5TixVQUFVLEVBQUV3TyxlQUFlLEVBQUVyTixXQUFXLEVBQUVzTixRQUFRLEVBQUVsTyxXQUFXLEVBQUU7UUFDdEUsSUFBSWlNLGtCQUFrQmxNLFdBQVc7UUFDakMsTUFBTW9PLGtCQUFrQnROLGNBQWMsWUFBWUEsY0FBYyxVQUFVLENBQUN5TSx5QkFBeUIsT0FBT0Esd0JBQXdCLEtBQUtXLGtCQUFrQixDQUFDWCx5QkFBeUIsT0FBT0Esd0JBQXdCLEtBQUtXO1FBQ3hOLE1BQU1HLHFCQUFxQjNCLHlCQUF5QlIsZ0JBQWdCO1FBQ3BFLE1BQU1vQyxVQUFVNUIseUJBQXlCO1FBQ3pDLE1BQU02QixlQUFlTCxrQkFBa0I7UUFDdkMsSUFBSUcsb0JBQW9CO1lBQ3BCakcsSUFBSTVJLFdBQVdELE9BQU8sRUFBRTtnQkFDcEJzTyxZQUFZLENBQUMsUUFBUSxFQUFFMUQsWUFBWUMsUUFBUSxDQUFDLGVBQWUsRUFBRUQsWUFBWUUsSUFBSSxDQUFDeUQsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBQzlGO1FBQ0o7UUFDQSxJQUFJLENBQUMxQix5QkFBeUIrQixXQUFXLEtBQUssQ0FBQ0ksY0FBYztZQUN6RCxJQUFJdE8sYUFBYVk7aUJBQ1oyTSxZQUFZbk4sZ0JBQWdCLENBQUMsRUFBRSxHQUFHLHdCQUF3QjtZQUMvRDtRQUNKO1FBQ0EsSUFBSSxDQUFDK0wseUJBQXlCK0IsV0FBVyxLQUFLSSxnQkFBZ0JsTyxvQkFBb0JDLFlBQVk7WUFDMUZrTixZQUFZbk4sZ0JBQWdCLENBQUNDLFdBQVdtTSxNQUFNLEdBQUcsRUFBRTtZQUNuRDtRQUNKO1FBQ0Esc0RBQXNEO1FBQ3RELE1BQU0rQixtQkFBbUJuTyxvQkFBb0IsT0FBTyxLQUFLLElBQUlBLGlCQUFpQm9PLE1BQU0sQ0FBQyxDQUFDQyxNQUFNQztZQUN4RixJQUFJLE9BQU9ELFNBQVMsWUFBWSxPQUFPQyxTQUFTLFVBQVUsT0FBT0Q7WUFDakUsT0FBTy9FLEtBQUtpRixHQUFHLENBQUNELE9BQU9QLG1CQUFtQnpFLEtBQUtpRixHQUFHLENBQUNGLE9BQU9OLG1CQUFtQk8sT0FBT0Q7UUFDeEY7UUFDQSxNQUFNRyxNQUFNNUYsV0FBV25JLGFBQWF1QixPQUFPa0QsV0FBVyxHQUFHbEQsT0FBTzhELFVBQVU7UUFDMUUsSUFBSWdJLFdBQVc3RCxzQkFBc0JYLEtBQUtpRixHQUFHLENBQUNWLG1CQUFtQlcsTUFBTSxLQUFLO1lBQ3hFLE1BQU1DLGdCQUFnQlAsZUFBZSxJQUFJLENBQUMsR0FBRyxvQkFBb0I7WUFDakUsMkVBQTJFO1lBQzNFLElBQUlPLGdCQUFnQixLQUFLdEMsbUJBQW1CbE0sWUFBWTtnQkFDcERrTixZQUFZbk4sZ0JBQWdCLENBQUNDLFdBQVdtTSxNQUFNLEdBQUcsRUFBRTtnQkFDbkQ7WUFDSjtZQUNBLElBQUk2QixXQUFXUSxnQkFBZ0IsS0FBSzdPLGFBQWE7Z0JBQzdDWTtZQUNKO1lBQ0EsSUFBSTZMLHlCQUF5QixNQUFNO1lBQ25DYyxZQUFZbk4sZ0JBQWdCLENBQUNxTSx1QkFBdUJvQyxjQUFjO1lBQ2xFO1FBQ0o7UUFDQXRCLFlBQVlnQjtJQUNoQjtJQUNBLFNBQVM3TyxPQUFPLEVBQUV1TyxlQUFlLEVBQUU7UUFDL0IsSUFBSVgsMEJBQTBCLE1BQU07UUFDcEMsTUFBTXdCLFdBQVdqTyxjQUFjLFlBQVlBLGNBQWMsVUFBVXlNLHdCQUF3Qlcsa0JBQWtCWCx3QkFBd0JXO1FBQ3JJLDhEQUE4RDtRQUM5RCxJQUFJLENBQUNwTixjQUFjLFlBQVlBLGNBQWMsT0FBTSxLQUFNaU8sV0FBVzFPLGdCQUFnQixDQUFDQSxpQkFBaUJvTSxNQUFNLEdBQUcsRUFBRSxFQUFFO1lBQy9HO1FBQ0o7UUFDQSxJQUFJLENBQUMzTCxjQUFjLFNBQVNBLGNBQWMsTUFBSyxLQUFNaU8sV0FBVzFPLGdCQUFnQixDQUFDQSxpQkFBaUJvTSxNQUFNLEdBQUcsRUFBRSxFQUFFO1lBQzNHO1FBQ0o7UUFDQXJFLElBQUk5SSxVQUFVQyxPQUFPLEVBQUU7WUFDbkIyRixXQUFXK0QsV0FBV25JLGFBQWEsQ0FBQyxlQUFlLEVBQUVpTyxTQUFTLE1BQU0sQ0FBQyxHQUFHLENBQUMsWUFBWSxFQUFFQSxTQUFTLFNBQVMsQ0FBQztRQUM5RztJQUNKO0lBQ0EsU0FBU0MscUJBQXFCQyxrQkFBa0IsRUFBRUMsY0FBYztRQUM1RCxJQUFJLENBQUM1TyxjQUFjLE9BQU9vTSx5QkFBeUIsWUFBWSxDQUFDck0sb0JBQW9CNkwsa0JBQWtCbE0sV0FBVyxPQUFPO1FBQ3hILHNGQUFzRjtRQUN0RixNQUFNcU8scUJBQXFCM0IseUJBQXlCUixnQkFBZ0I7UUFDcEUsTUFBTWlELDZCQUE2QnpDLHdCQUF3QlI7UUFDM0QsSUFBSWlELDhCQUE4QkQsZ0JBQWdCO1lBQzlDLE9BQU87UUFDWDtRQUNBLDBGQUEwRjtRQUMxRixJQUFJYixzQkFBc0IsQ0FBQ2EsZ0JBQWdCLE9BQU87UUFDbEQsSUFBSSxDQUFDek8sY0FBYyxDQUFDNE4sb0JBQW9CLE9BQU87UUFDL0MsMENBQTBDO1FBQzFDLE1BQU1lLHVCQUF1QmYscUJBQXFCM0IsdUJBQXVCLElBQUlBLHVCQUF1QjtRQUNwRyx5SEFBeUg7UUFDekgsTUFBTTJDLG9CQUFvQmhCLHFCQUFxQmhPLGdCQUFnQixDQUFDK08scUJBQXFCLEdBQUcvTyxnQkFBZ0IsQ0FBQytPLHVCQUF1QixFQUFFLEdBQUcvTyxnQkFBZ0IsQ0FBQytPLHVCQUF1QixFQUFFLEdBQUcvTyxnQkFBZ0IsQ0FBQytPLHFCQUFxQjtRQUN4TixNQUFNRSxvQkFBb0JMLHFCQUFxQnRGLEtBQUtpRixHQUFHLENBQUNTO1FBQ3hELElBQUloQixvQkFBb0I7WUFDcEIsT0FBTyxJQUFJaUI7UUFDZixPQUFPO1lBQ0gsT0FBT0E7UUFDWDtJQUNKO0lBQ0EsT0FBTztRQUNIOUM7UUFDQTlMO1FBQ0FEO1FBQ0F1TztRQUNBcE87UUFDQThMO1FBQ0FoTjtRQUNBQztRQUNBVTtJQUNKO0FBQ0o7QUFFQSxNQUFNa1AsT0FBTyxJQUFJLEtBQUs7QUFDdEIsU0FBU0M7SUFDTCxNQUFNLEVBQUUxTyxTQUFTLEVBQUVaLE1BQU0sRUFBRWMscUJBQXFCLEVBQUVDLHlCQUF5QixFQUFFQyxZQUFZLEVBQUUsR0FBR0c7SUFDOUYsTUFBTW9PLGVBQWV6USx5Q0FBcUIsQ0FBQztJQUMzQyxNQUFNMFEseUJBQXlCdlEsOENBQU9BOzhEQUFDLElBQUlmLFNBQVNpRyxJQUFJLENBQUM5RixLQUFLLENBQUNvUixlQUFlOzZEQUFFLEVBQUU7SUFDbEYsU0FBU0M7UUFDTCxPQUFPLENBQUN2TixPQUFPOEQsVUFBVSxHQUFHd0UsaUJBQWdCLElBQUt0SSxPQUFPOEQsVUFBVTtJQUN0RTtJQUNBbkgsNENBQXdCO3dDQUFDO1lBQ3JCLElBQUlrQixVQUFVYyx1QkFBdUI7Z0JBQ2pDLElBQUl5TyxhQUFhbFEsT0FBTyxFQUFFc1EsYUFBYUosYUFBYWxRLE9BQU87Z0JBQzNELE1BQU11USxVQUFVMVIsU0FBUzJSLGFBQWEsQ0FBQyxpQ0FBaUMzUixTQUFTMlIsYUFBYSxDQUFDO2dCQUMvRixJQUFJLENBQUNELFNBQVM7Z0JBQ2Q5RixNQUFNL0ksNkJBQTZCLENBQUNDLGVBQWUySSxZQUFZekwsU0FBU2lHLElBQUksRUFBRTtvQkFDMUUyTCxZQUFZO2dCQUNoQixLQUFLVCxNQUFNMUYsWUFBWWlHLFNBQVM7b0JBQzVCRyxpQkFBaUJoSCxXQUFXbkksYUFBYSxRQUFRO29CQUNqRG9QLG9CQUFvQjtvQkFDcEJDLG9CQUFvQixHQUFHaEcsWUFBWUMsUUFBUSxDQUFDLENBQUMsQ0FBQztvQkFDOUNnRywwQkFBMEIsQ0FBQyxhQUFhLEVBQUVqRyxZQUFZRSxJQUFJLENBQUN5RCxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7Z0JBQzNFO2dCQUNBLE1BQU11Qyx1QkFBdUJ4RyxZQUFZaUcsU0FBUztvQkFDOUNRLGNBQWMsR0FBRzdGLGNBQWMsRUFBRSxDQUFDO29CQUNsQ3hILFVBQVU7b0JBQ1YsR0FBR2dHLFdBQVduSSxhQUFhO3dCQUN2Qm9FLFdBQVcsQ0FBQyxNQUFNLEVBQUUwSyxXQUFXLDBEQUEwRCxDQUFDO29CQUM5RixJQUFJO3dCQUNBMUssV0FBVyxDQUFDLE1BQU0sRUFBRTBLLFdBQVcsMERBQTBELENBQUM7b0JBQzlGLENBQUM7Z0JBQ0w7Z0JBQ0E7b0RBQU87d0JBQ0hTO3dCQUNBWixhQUFhbFEsT0FBTyxHQUFHOEMsT0FBT2tPLFVBQVU7NERBQUM7Z0NBQ3JDLElBQUliLHdCQUF3QjtvQ0FDeEJ0UixTQUFTaUcsSUFBSSxDQUFDOUYsS0FBSyxDQUFDeVIsVUFBVSxHQUFHTjtnQ0FDckMsT0FBTztvQ0FDSHRSLFNBQVNpRyxJQUFJLENBQUM5RixLQUFLLENBQUNpUyxjQUFjLENBQUM7Z0NBQ3ZDOzRCQUNKOzJEQUFHckcsWUFBWUMsUUFBUSxHQUFHO29CQUM5Qjs7WUFDSjtRQUNKO3VDQUFHO1FBQ0NsSztRQUNBYztRQUNBME87S0FDSDtBQUNMO0FBRUEsSUFBSWUsdUJBQXVCO0FBQzNCOzs7Ozs7O0NBT0MsR0FBRyxTQUFTQyxpQkFBaUIsRUFBRXhRLE1BQU0sRUFBRU0sS0FBSyxFQUFFbVEsTUFBTSxFQUFFQyxhQUFhLEVBQUVDLHdCQUF3QixFQUFFM1AsWUFBWSxFQUFFO0lBQzFHLE1BQU0sQ0FBQzRQLFdBQVdDLGFBQWEsR0FBRy9SLDJDQUF1QjtxQ0FBQyxJQUFJLE1BQTZCLEdBQUdxRCxDQUFvQixHQUFHOztJQUNySCxNQUFNNk8sWUFBWWxTLHlDQUFxQixDQUFDO0lBQ3hDLE1BQU1tUyxtQkFBbUJuUyw4Q0FBMEI7MERBQUM7WUFDaEQsNkNBQTZDO1lBQzdDLElBQUksQ0FBQ2dELFlBQVk7WUFDakIsOERBQThEO1lBQzlELElBQUl5Tyx5QkFBeUIsUUFBUXZRLFVBQVUsQ0FBQ2dCLGNBQWM7Z0JBQzFEdVAsdUJBQXVCO29CQUNuQlcsVUFBVWhULFNBQVNpRyxJQUFJLENBQUM5RixLQUFLLENBQUM2UyxRQUFRO29CQUN0Q2xLLEtBQUs5SSxTQUFTaUcsSUFBSSxDQUFDOUYsS0FBSyxDQUFDMkksR0FBRztvQkFDNUJtSyxNQUFNalQsU0FBU2lHLElBQUksQ0FBQzlGLEtBQUssQ0FBQzhTLElBQUk7b0JBQzlCL0wsUUFBUWxILFNBQVNpRyxJQUFJLENBQUM5RixLQUFLLENBQUMrRyxNQUFNO29CQUNsQ2dNLE9BQU87Z0JBQ1g7Z0JBQ0EsMkNBQTJDO2dCQUMzQyxNQUFNLEVBQUV6TCxPQUFPLEVBQUVOLFdBQVcsRUFBRSxHQUFHbEQ7Z0JBQ2pDakUsU0FBU2lHLElBQUksQ0FBQzlGLEtBQUssQ0FBQ3NLLFdBQVcsQ0FBQyxZQUFZLFNBQVM7Z0JBQ3JESixPQUFPc0IsTUFBTSxDQUFDM0wsU0FBU2lHLElBQUksQ0FBQzlGLEtBQUssRUFBRTtvQkFDL0IySSxLQUFLLEdBQUcsQ0FBQ2dLLFVBQVUzUixPQUFPLENBQUMsRUFBRSxDQUFDO29CQUM5QjhSLE1BQU0sR0FBRyxDQUFDeEwsUUFBUSxFQUFFLENBQUM7b0JBQ3JCeUwsT0FBTztvQkFDUGhNLFFBQVE7Z0JBQ1o7Z0JBQ0FqRCxPQUFPa08sVUFBVTtzRUFBQyxJQUFJbE8sT0FBTytDLHFCQUFxQjs4RUFBQztnQ0FDM0MseUVBQXlFO2dDQUN6RSxNQUFNbU0sa0JBQWtCaE0sY0FBY2xELE9BQU9rRCxXQUFXO2dDQUN4RCxJQUFJZ00sbUJBQW1CTCxVQUFVM1IsT0FBTyxJQUFJZ0csYUFBYTtvQ0FDckQscUVBQXFFO29DQUNyRW5ILFNBQVNpRyxJQUFJLENBQUM5RixLQUFLLENBQUMySSxHQUFHLEdBQUcsR0FBRyxDQUFFZ0ssQ0FBQUEsVUFBVTNSLE9BQU8sR0FBR2dTLGVBQWMsRUFBRyxFQUFFLENBQUM7Z0NBQzNFOzRCQUNKOztxRUFBSTtZQUNaO1FBQ0o7eURBQUc7UUFDQ3JSO0tBQ0g7SUFDRCxNQUFNc1IseUJBQXlCeFMsOENBQTBCO2dFQUFDO1lBQ3RELDZDQUE2QztZQUM3QyxJQUFJLENBQUNnRCxZQUFZO1lBQ2pCLElBQUl5Tyx5QkFBeUIsUUFBUSxDQUFDdlAsY0FBYztnQkFDaEQsd0NBQXdDO2dCQUN4QyxNQUFNd0QsSUFBSSxDQUFDNEksU0FBU2xQLFNBQVNpRyxJQUFJLENBQUM5RixLQUFLLENBQUMySSxHQUFHLEVBQUU7Z0JBQzdDLE1BQU11SyxJQUFJLENBQUNuRSxTQUFTbFAsU0FBU2lHLElBQUksQ0FBQzlGLEtBQUssQ0FBQzhTLElBQUksRUFBRTtnQkFDOUMsaUJBQWlCO2dCQUNqQjVJLE9BQU9zQixNQUFNLENBQUMzTCxTQUFTaUcsSUFBSSxDQUFDOUYsS0FBSyxFQUFFa1M7Z0JBQ25DcE8sT0FBTytDLHFCQUFxQjs0RUFBQzt3QkFDekIsSUFBSXlMLDRCQUE0QkMsY0FBY3pPLE9BQU8yTyxRQUFRLENBQUNDLElBQUksRUFBRTs0QkFDaEVGLGFBQWExTyxPQUFPMk8sUUFBUSxDQUFDQyxJQUFJOzRCQUNqQzt3QkFDSjt3QkFDQTVPLE9BQU91RCxRQUFRLENBQUM2TCxHQUFHL007b0JBQ3ZCOztnQkFDQStMLHVCQUF1QjtZQUMzQjtRQUNKOytEQUFHO1FBQ0NLO0tBQ0g7SUFDRDlSLDRDQUF3QjtzQ0FBQztZQUNyQixTQUFTMFM7Z0JBQ0xSLFVBQVUzUixPQUFPLEdBQUc4QyxPQUFPMEQsT0FBTztZQUN0QztZQUNBMkw7WUFDQXJQLE9BQU9vRCxnQkFBZ0IsQ0FBQyxVQUFVaU07WUFDbEM7OENBQU87b0JBQ0hyUCxPQUFPeUUsbUJBQW1CLENBQUMsVUFBVTRLO2dCQUN6Qzs7UUFDSjtxQ0FBRyxFQUFFO0lBQ0wxUyw0Q0FBd0I7c0NBQUM7WUFDckIsSUFBSSxDQUFDd0IsT0FBTztZQUNaOzhDQUFPO29CQUNILElBQUksT0FBT3BDLGFBQWEsYUFBYTtvQkFDckMseURBQXlEO29CQUN6RCxNQUFNdVQsa0JBQWtCLENBQUMsQ0FBQ3ZULFNBQVMyUixhQUFhLENBQUM7b0JBQ2pELElBQUk0QixpQkFBaUI7b0JBQ3JCSDtnQkFDSjs7UUFDSjtxQ0FBRztRQUNDaFI7UUFDQWdSO0tBQ0g7SUFDRHhTLDRDQUF3QjtzQ0FBQztZQUNyQixJQUFJMlIsVUFBVSxDQUFDQyxlQUFlO1lBQzlCLGlJQUFpSTtZQUNqSSxJQUFJMVEsUUFBUTtnQkFDUixrQ0FBa0M7Z0JBQ2xDLE1BQU0wUixlQUFldlAsT0FBT3dQLFVBQVUsQ0FBQyw4QkFBOEJDLE9BQU87Z0JBQzVFLENBQUNGLGdCQUFnQlQ7Z0JBQ2pCLElBQUksQ0FBQzNRLE9BQU87b0JBQ1I2QixPQUFPa08sVUFBVTtzREFBQzs0QkFDZGlCO3dCQUNKO3FEQUFHO2dCQUNQO1lBQ0osT0FBTztnQkFDSEE7WUFDSjtRQUNKO3FDQUFHO1FBQ0N0UjtRQUNBMFE7UUFDQUU7UUFDQXRRO1FBQ0FtUTtRQUNBUTtRQUNBSztLQUNIO0lBQ0QsT0FBTztRQUNIQTtJQUNKO0FBQ0o7QUFFQSxTQUFTTyxLQUFLLEVBQUVDLE1BQU1qUyxRQUFRLEVBQUVZLFlBQVksRUFBRXNSLFFBQVEsRUFBRXRTLFFBQVF1UyxVQUFVLEVBQUV4UyxXQUFXeVMsYUFBYSxFQUFFN1IsVUFBVSxFQUFFVSx3QkFBd0IsS0FBSyxFQUFFQyw0QkFBNEIsSUFBSSxFQUFFbVIsaUJBQWlCN0gsZUFBZSxFQUFFOEgsb0JBQW9CN0gsbUJBQW1CLEVBQUV2SyxjQUFjLElBQUksRUFBRU0sYUFBYSxLQUFLLEVBQUUyTCxnQkFBZ0I1TCxjQUFjQSxXQUFXbU0sTUFBTSxHQUFHLENBQUMsRUFBRS9MLGlCQUFpQnNMLG1CQUFtQixFQUFFcEwsb0JBQW9CcUwsc0JBQXNCLEVBQUVxRyxLQUFLLEVBQUU5UixRQUFRLElBQUksRUFBRStSLE9BQU8sRUFBRTVCLE1BQU0sRUFBRXpQLGVBQWUsS0FBSyxFQUFFSixZQUFZLFFBQVEsRUFBRTBSLGNBQWMsS0FBSyxFQUFFQyx1QkFBdUIsSUFBSSxFQUFFckcsd0JBQXdCLEtBQUssRUFBRXlFLDJCQUEyQixLQUFLLEVBQUU2QixtQkFBbUIsSUFBSSxFQUFFQyxjQUFjLEVBQUV4UixTQUFTLEVBQUVDLFlBQVksS0FBSyxFQUFFO0lBQ3JyQixJQUFJd1Isb0JBQW9CQztJQUN4QixNQUFNLENBQUMzUyxTQUFTLEtBQUssRUFBRTRTLFVBQVUsR0FBR3RILHFCQUFxQjtRQUNyRE4sYUFBYXNIO1FBQ2J6SixNQUFNaEo7UUFDTm9MLFFBQVE7eUNBQUUsQ0FBQzRIO2dCQUNQcFMsZ0JBQWdCLE9BQU8sS0FBSyxJQUFJQSxhQUFhb1M7Z0JBQzdDLElBQUksQ0FBQ0EsS0FBSyxDQUFDcEMsUUFBUTtvQkFDZmE7Z0JBQ0o7Z0JBQ0FqQjtpREFBVzt3QkFDUG9DLGtCQUFrQixPQUFPLEtBQUssSUFBSUEsZUFBZUk7b0JBQ3JEO2dEQUFHNUksWUFBWUMsUUFBUSxHQUFHO2dCQUMxQixJQUFJMkksS0FBSyxDQUFDdlMsT0FBTztvQkFDYixJQUFJLEtBQTZCLEVBQUUsRUFJbEM7Z0JBQ0w7Z0JBQ0EsSUFBSSxDQUFDdVMsR0FBRztvQkFDSiw4REFBOEQ7b0JBQzlEM1UsU0FBU2lHLElBQUksQ0FBQzlGLEtBQUssQ0FBQ3lVLGFBQWEsR0FBRztnQkFDeEM7WUFDSjs7SUFDSjtJQUNBLE1BQU0sQ0FBQ3BDLGVBQWVxQyxpQkFBaUIsR0FBR2pVLDJDQUF1QixDQUFDO0lBQ2xFLE1BQU0sQ0FBQ21CLFlBQVkrUyxjQUFjLEdBQUdsVSwyQ0FBdUIsQ0FBQztJQUM1RCxNQUFNLENBQUNtVSxjQUFjQyxnQkFBZ0IsR0FBR3BVLDJDQUF1QixDQUFDO0lBQ2hFLE1BQU1RLGFBQWFSLHlDQUFxQixDQUFDO0lBQ3pDLE1BQU1xVSxXQUFXclUseUNBQXFCLENBQUM7SUFDdkMsTUFBTXNVLGdCQUFnQnRVLHlDQUFxQixDQUFDO0lBQzVDLE1BQU11VSxjQUFjdlUseUNBQXFCLENBQUM7SUFDMUMsTUFBTXdVLHdCQUF3QnhVLHlDQUFxQixDQUFDO0lBQ3BELE1BQU15VSxrQkFBa0J6VSx5Q0FBcUIsQ0FBQztJQUM5QyxNQUFNMFUsd0JBQXdCMVUseUNBQXFCLENBQUM7SUFDcEQsTUFBTTJVLGVBQWUzVSx5Q0FBcUIsQ0FBQztJQUMzQyxNQUFNb0IsaUJBQWlCcEIseUNBQXFCLENBQUM7SUFDN0MsTUFBTStCLGdCQUFnQi9CLHlDQUFxQixDQUFDLENBQUN3VDtJQUM3QyxNQUFNb0IsMEJBQTBCNVUseUNBQXFCLENBQUM7SUFDdEQsTUFBTU0sWUFBWU4seUNBQXFCLENBQUM7SUFDeEMsTUFBTTZVLGtCQUFrQjdVLHlDQUFxQixDQUFDLENBQUMsQ0FBQzRULHFCQUFxQnRULFVBQVVDLE9BQU8sS0FBSyxPQUFPLEtBQUssSUFBSXFULG1CQUFtQjNMLHFCQUFxQixHQUFHM0IsTUFBTSxLQUFLO0lBQ2pLLE1BQU13TyxpQkFBaUI5VSx5Q0FBcUIsQ0FBQyxDQUFDLENBQUM2VCxzQkFBc0J2VCxVQUFVQyxPQUFPLEtBQUssT0FBTyxLQUFLLElBQUlzVCxvQkFBb0I1TCxxQkFBcUIsR0FBR2dHLEtBQUssS0FBSztJQUNqSyxNQUFNOEcsc0JBQXNCL1UseUNBQXFCLENBQUM7SUFDbEQsTUFBTW1OLG9CQUFvQm5OLDhDQUEwQjsrQ0FBQyxDQUFDME47WUFDbEQsOEdBQThHO1lBQzlHLElBQUlwTSxjQUFjb00seUJBQXlCck0saUJBQWlCb00sTUFBTSxHQUFHLEdBQUc0RyxTQUFTOVQsT0FBTyxHQUFHLElBQUl5VTtRQUNuRzs4Q0FBRyxFQUFFO0lBQ0wsTUFBTSxFQUFFdFQsZUFBZSxFQUFFZ00sb0JBQW9CLEVBQUU5TCxrQkFBa0IsRUFBRWxCLFdBQVd1VSxtQkFBbUIsRUFBRTVULGdCQUFnQixFQUFFVixRQUFRdVUsZ0JBQWdCLEVBQUV6VCxVQUFVLEVBQUV1TyxzQkFBc0JtRiw4QkFBOEIsRUFBRSxHQUFHcEksY0FBYztRQUM5TnpMO1FBQ0EwTDtRQUNBQztRQUNBM007UUFDQTRNO1FBQ0ExTTtRQUNBMk07UUFDQXJMO1FBQ0FLO1FBQ0FpTDtJQUNKO0lBQ0F4SSxpQkFBaUI7UUFDYkUsWUFBWSxDQUFDNUQsVUFBVUMsY0FBYyxDQUFDSyxTQUFTMlMsZ0JBQWdCLENBQUN2QyxpQkFBaUIsQ0FBQzhCLG9CQUFvQixDQUFDRDtJQUMzRztJQUNBLE1BQU0sRUFBRWpCLHNCQUFzQixFQUFFLEdBQUdkLGlCQUFpQjtRQUNoRHhRO1FBQ0FNO1FBQ0FtUSxRQUFRQSxVQUFVLE9BQU9BLFNBQVM7UUFDbENDO1FBQ0FDO1FBQ0EzUDtJQUNKO0lBQ0EsU0FBUzBPO1FBQ0wsT0FBTyxDQUFDdk4sT0FBTzhELFVBQVUsR0FBR3dFLGlCQUFnQixJQUFLdEksT0FBTzhELFVBQVU7SUFDdEU7SUFDQSxTQUFTMUcsUUFBUW1ILEtBQUs7UUFDbEIsSUFBSWdNLG9CQUFvQkM7UUFDeEIsSUFBSSxDQUFDNVMsZUFBZSxDQUFDSyxZQUFZO1FBQ2pDLElBQUloQixVQUFVQyxPQUFPLElBQUksQ0FBQ0QsVUFBVUMsT0FBTyxDQUFDNlUsUUFBUSxDQUFDeE4sTUFBTXhDLE1BQU0sR0FBRztRQUNwRXlQLGdCQUFnQnRVLE9BQU8sR0FBRyxDQUFDLENBQUNxVCxxQkFBcUJ0VCxVQUFVQyxPQUFPLEtBQUssT0FBTyxLQUFLLElBQUlxVCxtQkFBbUIzTCxxQkFBcUIsR0FBRzNCLE1BQU0sS0FBSztRQUM3SXdPLGVBQWV2VSxPQUFPLEdBQUcsQ0FBQyxDQUFDc1Qsc0JBQXNCdlQsVUFBVUMsT0FBTyxLQUFLLE9BQU8sS0FBSyxJQUFJc1Qsb0JBQW9CNUwscUJBQXFCLEdBQUdnRyxLQUFLLEtBQUs7UUFDN0lpRyxjQUFjO1FBQ2RJLGNBQWMvVCxPQUFPLEdBQUcsSUFBSXlVO1FBQzVCLDRHQUE0RztRQUM1RyxJQUFJN1IsU0FBUztZQUNURSxPQUFPb0QsZ0JBQWdCLENBQUMsWUFBWSxJQUFJZ08sZ0JBQWdCbFUsT0FBTyxHQUFHLE9BQU87Z0JBQ3JFbUcsTUFBTTtZQUNWO1FBQ0o7UUFDQSxtRkFBbUY7UUFDbkZrQixNQUFNeEMsTUFBTSxDQUFDaVEsaUJBQWlCLENBQUN6TixNQUFNME4sU0FBUztRQUM5Q1gsYUFBYXBVLE9BQU8sR0FBRzBKLFdBQVduSSxhQUFhOEYsTUFBTXJDLEtBQUssR0FBR3FDLE1BQU0yTixLQUFLO0lBQzVFO0lBQ0EsU0FBU0MsV0FBV25NLEVBQUUsRUFBRW9NLHFCQUFxQjtRQUN6QyxJQUFJQztRQUNKLElBQUlqTyxVQUFVNEI7UUFDZCxNQUFNc00sa0JBQWtCLENBQUNELHVCQUF1QnJTLE9BQU91UyxZQUFZLEVBQUMsS0FBTSxPQUFPLEtBQUssSUFBSUYscUJBQXFCRyxRQUFRO1FBQ3ZILE1BQU1DLGNBQWN4VixVQUFVQyxPQUFPLEdBQUcySixhQUFhNUosVUFBVUMsT0FBTyxFQUFFdUIsYUFBYTtRQUNyRixNQUFNaVUsT0FBTyxJQUFJZjtRQUNqQix3REFBd0Q7UUFDeEQsSUFBSXZOLFFBQVF1TyxPQUFPLEtBQUssVUFBVTtZQUM5QixPQUFPO1FBQ1g7UUFDQSxJQUFJdk8sUUFBUXdPLFlBQVksQ0FBQyx3QkFBd0J4TyxRQUFReU8sT0FBTyxDQUFDLHdCQUF3QjtZQUNyRixPQUFPO1FBQ1g7UUFDQSxJQUFJcFUsY0FBYyxXQUFXQSxjQUFjLFFBQVE7WUFDL0MsT0FBTztRQUNYO1FBQ0EsaUNBQWlDO1FBQ2pDLElBQUl1UyxTQUFTOVQsT0FBTyxJQUFJd1YsS0FBS0ksT0FBTyxLQUFLOUIsU0FBUzlULE9BQU8sQ0FBQzRWLE9BQU8sS0FBSyxLQUFLO1lBQ3ZFLE9BQU87UUFDWDtRQUNBLElBQUlMLGdCQUFnQixNQUFNO1lBQ3RCLElBQUloVSxjQUFjLFdBQVdnVSxjQUFjLElBQUlBLGNBQWMsR0FBRztnQkFDNUQsT0FBTztZQUNYO1FBQ0o7UUFDQSx5Q0FBeUM7UUFDekMsSUFBSUgsbUJBQW1CQSxnQkFBZ0JsSSxNQUFNLEdBQUcsR0FBRztZQUMvQyxPQUFPO1FBQ1g7UUFDQSxzRUFBc0U7UUFDdEUsSUFBSStHLHNCQUFzQmpVLE9BQU8sSUFBSXdWLEtBQUtJLE9BQU8sS0FBSzNCLHNCQUFzQmpVLE9BQU8sQ0FBQzRWLE9BQU8sS0FBSzlDLHFCQUFxQnlDLGdCQUFnQixHQUFHO1lBQ3BJdEIsc0JBQXNCalUsT0FBTyxHQUFHd1Y7WUFDaEMsT0FBTztRQUNYO1FBQ0EsSUFBSU4sdUJBQXVCO1lBQ3ZCakIsc0JBQXNCalUsT0FBTyxHQUFHd1Y7WUFDaEMsb0RBQW9EO1lBQ3BELE9BQU87UUFDWDtRQUNBLDREQUE0RDtRQUM1RCxNQUFNdE8sUUFBUTtZQUNWLHFDQUFxQztZQUNyQyxJQUFJQSxRQUFRNUIsWUFBWSxHQUFHNEIsUUFBUTNCLFlBQVksRUFBRTtnQkFDN0MsSUFBSTJCLFFBQVE5QixTQUFTLEtBQUssR0FBRztvQkFDekI2TyxzQkFBc0JqVSxPQUFPLEdBQUcsSUFBSXlVO29CQUNwQyx1RUFBdUU7b0JBQ3ZFLE9BQU87Z0JBQ1g7Z0JBQ0EsSUFBSXZOLFFBQVEyTyxZQUFZLENBQUMsWUFBWSxVQUFVO29CQUMzQyxPQUFPO2dCQUNYO1lBQ0o7WUFDQSxnQ0FBZ0M7WUFDaEMzTyxVQUFVQSxRQUFRNE8sVUFBVTtRQUNoQztRQUNBLCtEQUErRDtRQUMvRCxPQUFPO0lBQ1g7SUFDQSxTQUFTMVYsT0FBT2lILEtBQUs7UUFDakIsSUFBSSxDQUFDdEgsVUFBVUMsT0FBTyxFQUFFO1lBQ3BCO1FBQ0o7UUFDQSx5SEFBeUg7UUFDekgsSUFBSVksWUFBWTtZQUNaLE1BQU1tVixzQkFBc0J4VSxjQUFjLFlBQVlBLGNBQWMsVUFBVSxJQUFJLENBQUM7WUFDbkYsTUFBTW9OLGtCQUFrQixDQUFDeUYsYUFBYXBVLE9BQU8sR0FBSTBKLENBQUFBLFdBQVduSSxhQUFhOEYsTUFBTXJDLEtBQUssR0FBR3FDLE1BQU0yTixLQUFLLEtBQUtlO1lBQ3ZHLE1BQU1iLHdCQUF3QnZHLGtCQUFrQjtZQUNoRCxpRUFBaUU7WUFDakUsTUFBTXFILGdDQUFnQ2pWLGNBQWMsQ0FBQ0wsZUFBZSxDQUFDd1U7WUFDckUsZ0hBQWdIO1lBQ2hILElBQUljLGlDQUFpQzdJLHlCQUF5QixHQUFHO1lBQ2pFLDhGQUE4RjtZQUM5RixNQUFNdUMscUJBQXFCdEYsS0FBS2lGLEdBQUcsQ0FBQ1Y7WUFDcEMsTUFBTTRCLFVBQVUxUixTQUFTMlIsYUFBYSxDQUFDO1lBQ3ZDLE1BQU15RixrQkFBa0IxVSxjQUFjLFlBQVlBLGNBQWMsUUFBUStTLGdCQUFnQnRVLE9BQU8sR0FBR3VVLGVBQWV2VSxPQUFPO1lBQ3hILG1FQUFtRTtZQUNuRSxJQUFJK1Asb0JBQW9CTCxxQkFBcUJ1RztZQUM3QyxNQUFNQyw2QkFBNkJ0QiwrQkFBK0JsRixvQkFBb0J3RjtZQUN0RixJQUFJZ0IsK0JBQStCLE1BQU07Z0JBQ3JDbkcsb0JBQW9CbUc7WUFDeEI7WUFDQSwwREFBMEQ7WUFDMUQsSUFBSUYsaUNBQWlDakcscUJBQXFCLEdBQUc7Z0JBQ3pEO1lBQ0o7WUFDQSxJQUFJLENBQUNtRSxnQkFBZ0JsVSxPQUFPLElBQUksQ0FBQ2lWLFdBQVc1TixNQUFNeEMsTUFBTSxFQUFFcVEsd0JBQXdCO1lBQ2xGblYsVUFBVUMsT0FBTyxDQUFDbVcsU0FBUyxDQUFDQyxHQUFHLENBQUMvSztZQUNoQyw2TkFBNk47WUFDN042SSxnQkFBZ0JsVSxPQUFPLEdBQUc7WUFDMUI2SSxJQUFJOUksVUFBVUMsT0FBTyxFQUFFO2dCQUNuQnNPLFlBQVk7WUFDaEI7WUFDQXpGLElBQUk1SSxXQUFXRCxPQUFPLEVBQUU7Z0JBQ3BCc08sWUFBWTtZQUNoQjtZQUNBLElBQUl2TixZQUFZO2dCQUNaNFQsaUJBQWlCO29CQUNiaEc7Z0JBQ0o7WUFDSjtZQUNBLGdHQUFnRztZQUNoRyxJQUFJdUcseUJBQXlCLENBQUNuVSxZQUFZO2dCQUN0QyxNQUFNc1YsMEJBQTBCbk0sWUFBWXlFO2dCQUM1QyxNQUFNMkgsaUJBQWlCbE0sS0FBS21NLEdBQUcsQ0FBQ0YsMEJBQTBCLENBQUMsR0FBRyxLQUFLTjtnQkFDbkVsTixJQUFJOUksVUFBVUMsT0FBTyxFQUFFO29CQUNuQjJGLFdBQVcrRCxXQUFXbkksYUFBYSxDQUFDLGVBQWUsRUFBRStVLGVBQWUsTUFBTSxDQUFDLEdBQUcsQ0FBQyxZQUFZLEVBQUVBLGVBQWUsU0FBUyxDQUFDO2dCQUMxSDtnQkFDQTtZQUNKO1lBQ0EsTUFBTUUsZUFBZSxJQUFJekc7WUFDekIsSUFBSTdPLGNBQWN5TCxpQkFBaUJRLHlCQUF5QlIsZ0JBQWdCLEdBQUc7Z0JBQzNFZ0csY0FBYyxPQUFPLEtBQUssSUFBSUEsV0FBV3RMLE9BQU8wSTtnQkFDaERsSCxJQUFJNUksV0FBV0QsT0FBTyxFQUFFO29CQUNwQndPLFNBQVMsR0FBR2dJLGNBQWM7b0JBQzFCbEksWUFBWTtnQkFDaEIsR0FBRztZQUNQO1lBQ0EsSUFBSWlDLFdBQVd0USxXQUFXRCxPQUFPLElBQUl5Qix1QkFBdUI7Z0JBQ3hELHFEQUFxRDtnQkFDckQsTUFBTWdWLGFBQWFyTSxLQUFLbU0sR0FBRyxDQUFDbEcsYUFBYU4sb0JBQXFCLEtBQUlNLFVBQVMsR0FBSTtnQkFDL0UsTUFBTXFHLG9CQUFvQixJQUFJM0csb0JBQW9CO2dCQUNsRCxNQUFNdUcsaUJBQWlCbE0sS0FBS3FFLEdBQUcsQ0FBQyxHQUFHLEtBQUtzQixvQkFBb0I7Z0JBQzVEbEgsSUFBSTBILFNBQVM7b0JBQ1RRLGNBQWMsR0FBRzJGLGtCQUFrQixFQUFFLENBQUM7b0JBQ3RDL1EsV0FBVytELFdBQVduSSxhQUFhLENBQUMsTUFBTSxFQUFFa1YsV0FBVyxpQkFBaUIsRUFBRUgsZUFBZSxNQUFNLENBQUMsR0FBRyxDQUFDLE1BQU0sRUFBRUcsV0FBVyxjQUFjLEVBQUVILGVBQWUsU0FBUyxDQUFDO29CQUNoS2hJLFlBQVk7Z0JBQ2hCLEdBQUc7WUFDUDtZQUNBLElBQUksQ0FBQ3ZOLFlBQVk7Z0JBQ2IsTUFBTXVWLGlCQUFpQjVHLHFCQUFxQnFHO2dCQUM1Q2xOLElBQUk5SSxVQUFVQyxPQUFPLEVBQUU7b0JBQ25CMkYsV0FBVytELFdBQVduSSxhQUFhLENBQUMsZUFBZSxFQUFFK1UsZUFBZSxNQUFNLENBQUMsR0FBRyxDQUFDLFlBQVksRUFBRUEsZUFBZSxTQUFTLENBQUM7Z0JBQzFIO1lBQ0o7UUFDSjtJQUNKO0lBQ0E3Vyw0Q0FBd0I7MEJBQUM7WUFDckJxRCxPQUFPK0MscUJBQXFCO2tDQUFDO29CQUN6QnJFLGNBQWN4QixPQUFPLEdBQUc7Z0JBQzVCOztRQUNKO3lCQUFHLEVBQUU7SUFDTFAsNENBQXdCOzBCQUFDO1lBQ3JCLElBQUlrWDtZQUNKLFNBQVNDO2dCQUNMLElBQUksQ0FBQzdXLFVBQVVDLE9BQU8sSUFBSSxDQUFDbVQsa0JBQWtCO2dCQUM3QyxNQUFNMEQsaUJBQWlCaFksU0FBUzZHLGFBQWE7Z0JBQzdDLElBQUlELFFBQVFvUixtQkFBbUJoVyxlQUFlYixPQUFPLEVBQUU7b0JBQ25ELElBQUkyVztvQkFDSixNQUFNRyx1QkFBdUIsQ0FBQyxDQUFDSCx5QkFBeUI3VCxPQUFPUSxjQUFjLEtBQUssT0FBTyxLQUFLLElBQUlxVCx1QkFBdUI1USxNQUFNLEtBQUs7b0JBQ3BJLE1BQU1nUixjQUFjalUsT0FBT2tELFdBQVc7b0JBQ3RDLHFDQUFxQztvQkFDckMsSUFBSWdSLGtCQUFrQkQsY0FBY0Q7b0JBQ3BDLE1BQU1HLGVBQWVsWCxVQUFVQyxPQUFPLENBQUMwSCxxQkFBcUIsR0FBRzNCLE1BQU0sSUFBSTtvQkFDekUsZ0RBQWdEO29CQUNoRCxNQUFNbVIsZUFBZUQsZUFBZUYsY0FBYztvQkFDbEQsSUFBSSxDQUFDdkMsb0JBQW9CeFUsT0FBTyxFQUFFO3dCQUM5QndVLG9CQUFvQnhVLE9BQU8sR0FBR2lYO29CQUNsQztvQkFDQSxNQUFNRSxnQkFBZ0JwWCxVQUFVQyxPQUFPLENBQUMwSCxxQkFBcUIsR0FBR0MsR0FBRztvQkFDbkUsK0xBQStMO29CQUMvTCxJQUFJeUMsS0FBS2lGLEdBQUcsQ0FBQ2dGLHdCQUF3QnJVLE9BQU8sR0FBR2dYLG1CQUFtQixJQUFJO3dCQUNsRW5XLGVBQWViLE9BQU8sR0FBRyxDQUFDYSxlQUFlYixPQUFPO29CQUNwRDtvQkFDQSxJQUFJZSxjQUFjQSxXQUFXbU0sTUFBTSxHQUFHLEtBQUtwTSxvQkFBb0JxTSxzQkFBc0I7d0JBQ2pGLE1BQU1pSyx3QkFBd0J0VyxnQkFBZ0IsQ0FBQ3FNLHFCQUFxQixJQUFJO3dCQUN4RTZKLG1CQUFtQkk7b0JBQ3ZCO29CQUNBL0Msd0JBQXdCclUsT0FBTyxHQUFHZ1g7b0JBQ2xDLHFLQUFxSztvQkFDckssSUFBSUMsZUFBZUgsd0JBQXdCalcsZUFBZWIsT0FBTyxFQUFFO3dCQUMvRCxNQUFNK0YsU0FBU2hHLFVBQVVDLE9BQU8sQ0FBQzBILHFCQUFxQixHQUFHM0IsTUFBTTt3QkFDL0QsSUFBSXNSLGtCQUFrQnRSO3dCQUN0QixJQUFJQSxTQUFTK1Esc0JBQXNCOzRCQUMvQk8sa0JBQWtCUCx1QkFBd0JJLENBQUFBLGVBQWVDLGdCQUFnQi9MLGlCQUFnQjt3QkFDN0Y7d0JBQ0Esb0pBQW9KO3dCQUNwSixJQUFJMkgsT0FBTzs0QkFDUGhULFVBQVVDLE9BQU8sQ0FBQ2hCLEtBQUssQ0FBQytHLE1BQU0sR0FBRyxHQUFHQSxTQUFTcUUsS0FBS3FFLEdBQUcsQ0FBQ3VJLGlCQUFpQixHQUFHLEVBQUUsQ0FBQzt3QkFDakYsT0FBTzs0QkFDSGpYLFVBQVVDLE9BQU8sQ0FBQ2hCLEtBQUssQ0FBQytHLE1BQU0sR0FBRyxHQUFHcUUsS0FBS3FFLEdBQUcsQ0FBQzRJLGlCQUFpQlAsdUJBQXVCSyxlQUFlLEVBQUUsQ0FBQzt3QkFDM0c7b0JBQ0osT0FBTyxJQUFJLENBQUNqVixtQkFBbUI7d0JBQzNCbkMsVUFBVUMsT0FBTyxDQUFDaEIsS0FBSyxDQUFDK0csTUFBTSxHQUFHLEdBQUd5TyxvQkFBb0J4VSxPQUFPLENBQUMsRUFBRSxDQUFDO29CQUN2RTtvQkFDQSxJQUFJZSxjQUFjQSxXQUFXbU0sTUFBTSxHQUFHLEtBQUssQ0FBQ3JNLGVBQWViLE9BQU8sRUFBRTt3QkFDaEVELFVBQVVDLE9BQU8sQ0FBQ2hCLEtBQUssQ0FBQ3FHLE1BQU0sR0FBRyxDQUFDLEdBQUcsQ0FBQztvQkFDMUMsT0FBTzt3QkFDSCwrQ0FBK0M7d0JBQy9DdEYsVUFBVUMsT0FBTyxDQUFDaEIsS0FBSyxDQUFDcUcsTUFBTSxHQUFHLEdBQUcrRSxLQUFLcUUsR0FBRyxDQUFDdUksaUJBQWlCLEdBQUcsRUFBRSxDQUFDO29CQUN4RTtnQkFDSjtZQUNKO1lBQ0NMLENBQUFBLHlCQUF5QjdULE9BQU9RLGNBQWMsS0FBSyxPQUFPLEtBQUssSUFBSXFULHVCQUF1QnpRLGdCQUFnQixDQUFDLFVBQVUwUTtZQUN0SDtrQ0FBTztvQkFDSCxJQUFJRDtvQkFDSixPQUFPLENBQUNBLHlCQUF5QjdULE9BQU9RLGNBQWMsS0FBSyxPQUFPLEtBQUssSUFBSXFULHVCQUF1QnBQLG1CQUFtQixDQUFDLFVBQVVxUDtnQkFDcEk7O1FBQ0o7eUJBQUc7UUFDQ3pKO1FBQ0FwTTtRQUNBRDtLQUNIO0lBQ0QsU0FBU1EsWUFBWWdXLFVBQVU7UUFDM0JDO1FBQ0F2RSxXQUFXLE9BQU8sS0FBSyxJQUFJQTtRQUMzQixJQUFJLENBQUNzRSxZQUFZO1lBQ2IvRCxVQUFVO1FBQ2Q7UUFDQXZDLFdBQVc7WUFDUCxJQUFJalEsWUFBWTtnQkFDWk0sbUJBQW1CTixVQUFVLENBQUMsRUFBRTtZQUNwQztRQUNKLEdBQUc2SixZQUFZQyxRQUFRLEdBQUcsT0FBTyxnQkFBZ0I7SUFDckQ7SUFDQSxTQUFTMk07UUFDTCxJQUFJLENBQUN6WCxVQUFVQyxPQUFPLEVBQUU7UUFDeEIsTUFBTXVRLFVBQVUxUixTQUFTMlIsYUFBYSxDQUFDO1FBQ3ZDLE1BQU1pSCxxQkFBcUI5TixhQUFhNUosVUFBVUMsT0FBTyxFQUFFdUI7UUFDM0RzSCxJQUFJOUksVUFBVUMsT0FBTyxFQUFFO1lBQ25CMkYsV0FBVztZQUNYMkksWUFBWSxDQUFDLFVBQVUsRUFBRTFELFlBQVlDLFFBQVEsQ0FBQyxlQUFlLEVBQUVELFlBQVlFLElBQUksQ0FBQ3lELElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUNoRztRQUNBMUYsSUFBSTVJLFdBQVdELE9BQU8sRUFBRTtZQUNwQnNPLFlBQVksQ0FBQyxRQUFRLEVBQUUxRCxZQUFZQyxRQUFRLENBQUMsZUFBZSxFQUFFRCxZQUFZRSxJQUFJLENBQUN5RCxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7WUFDMUZDLFNBQVM7UUFDYjtRQUNBLDJDQUEyQztRQUMzQyxJQUFJL00seUJBQXlCZ1csc0JBQXNCQSxxQkFBcUIsS0FBSzlXLFFBQVE7WUFDakZrSSxJQUFJMEgsU0FBUztnQkFDVFEsY0FBYyxHQUFHN0YsY0FBYyxFQUFFLENBQUM7Z0JBQ2xDeEgsVUFBVTtnQkFDVixHQUFHZ0csV0FBV25JLGFBQWE7b0JBQ3ZCb0UsV0FBVyxDQUFDLE1BQU0sRUFBRTBLLFdBQVcsMERBQTBELENBQUM7b0JBQzFGSyxpQkFBaUI7Z0JBQ3JCLElBQUk7b0JBQ0EvSyxXQUFXLENBQUMsTUFBTSxFQUFFMEssV0FBVywwREFBMEQsQ0FBQztvQkFDMUZLLGlCQUFpQjtnQkFDckIsQ0FBQztnQkFDREMsb0JBQW9CO2dCQUNwQkMsb0JBQW9CLEdBQUdoRyxZQUFZQyxRQUFRLENBQUMsQ0FBQyxDQUFDO2dCQUM5Q2dHLDBCQUEwQixDQUFDLGFBQWEsRUFBRWpHLFlBQVlFLElBQUksQ0FBQ3lELElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUMzRSxHQUFHO1FBQ1A7SUFDSjtJQUNBLFNBQVNnSjtRQUNMLElBQUksQ0FBQzNXLGNBQWMsQ0FBQ2IsVUFBVUMsT0FBTyxFQUFFO1FBQ3ZDRCxVQUFVQyxPQUFPLENBQUNtVyxTQUFTLENBQUN1QixNQUFNLENBQUNyTTtRQUNuQzZJLGdCQUFnQmxVLE9BQU8sR0FBRztRQUMxQjJULGNBQWM7UUFDZEssWUFBWWhVLE9BQU8sR0FBRyxJQUFJeVU7SUFDOUI7SUFDQSxTQUFTdFUsVUFBVWtILEtBQUs7UUFDcEIsSUFBSSxDQUFDekcsY0FBYyxDQUFDYixVQUFVQyxPQUFPLEVBQUU7UUFDdkNELFVBQVVDLE9BQU8sQ0FBQ21XLFNBQVMsQ0FBQ3VCLE1BQU0sQ0FBQ3JNO1FBQ25DNkksZ0JBQWdCbFUsT0FBTyxHQUFHO1FBQzFCMlQsY0FBYztRQUNkSyxZQUFZaFUsT0FBTyxHQUFHLElBQUl5VTtRQUMxQixNQUFNYyxjQUFjNUwsYUFBYTVKLFVBQVVDLE9BQU8sRUFBRXVCO1FBQ3BELElBQUksQ0FBQzhGLFNBQVMsQ0FBQzROLFdBQVc1TixNQUFNeEMsTUFBTSxFQUFFLFVBQVUsQ0FBQzBRLGVBQWVoSSxPQUFPQyxLQUFLLENBQUMrSCxjQUFjO1FBQzdGLElBQUl4QixjQUFjL1QsT0FBTyxLQUFLLE1BQU07UUFDcEMsTUFBTTJYLFlBQVkzRCxZQUFZaFUsT0FBTyxDQUFDNFYsT0FBTyxLQUFLN0IsY0FBYy9ULE9BQU8sQ0FBQzRWLE9BQU87UUFDL0UsTUFBTWdDLFlBQVl4RCxhQUFhcFUsT0FBTyxHQUFJMEosQ0FBQUEsV0FBV25JLGFBQWE4RixNQUFNckMsS0FBSyxHQUFHcUMsTUFBTTJOLEtBQUs7UUFDM0YsTUFBTXBHLFdBQVd4RSxLQUFLaUYsR0FBRyxDQUFDdUksYUFBYUQ7UUFDdkMsSUFBSS9JLFdBQVcsTUFBTTtZQUNqQix3SUFBd0k7WUFDeElpRixnQkFBZ0I7WUFDaEI3QyxXQUFXO2dCQUNQNkMsZ0JBQWdCO1lBQ3BCLEdBQUc7UUFDUDtRQUNBLElBQUk5UyxZQUFZO1lBQ1osTUFBTWdWLHNCQUFzQnhVLGNBQWMsWUFBWUEsY0FBYyxVQUFVLElBQUksQ0FBQztZQUNuRm1ULG9CQUFvQjtnQkFDaEIvRixpQkFBaUJpSixZQUFZN0I7Z0JBQzdCelU7Z0JBQ0FzTjtnQkFDQWxPO1lBQ0o7WUFDQWtTLGlCQUFpQixPQUFPLEtBQUssSUFBSUEsY0FBY3ZMLE9BQU87WUFDdEQ7UUFDSjtRQUNBLG1DQUFtQztRQUNuQyxJQUFJOUYsY0FBYyxZQUFZQSxjQUFjLFVBQVVxVyxZQUFZLElBQUlBLFlBQVksR0FBRztZQUNqRko7WUFDQTVFLGlCQUFpQixPQUFPLEtBQUssSUFBSUEsY0FBY3ZMLE9BQU87WUFDdEQ7UUFDSjtRQUNBLElBQUl1SCxXQUFXN0Qsb0JBQW9CO1lBQy9Ceko7WUFDQXNSLGlCQUFpQixPQUFPLEtBQUssSUFBSUEsY0FBY3ZMLE9BQU87WUFDdEQ7UUFDSjtRQUNBLElBQUl3UTtRQUNKLE1BQU1DLHNCQUFzQjFOLEtBQUttTSxHQUFHLENBQUMsQ0FBQ3NCLGtEQUFrRDlYLFVBQVVDLE9BQU8sQ0FBQzBILHFCQUFxQixHQUFHM0IsTUFBTSxLQUFLLE9BQU84UixrREFBa0QsR0FBRy9VLE9BQU9rRCxXQUFXO1FBQzNOLElBQUkrUjtRQUNKLE1BQU1DLHFCQUFxQjVOLEtBQUttTSxHQUFHLENBQUMsQ0FBQ3dCLGlEQUFpRGhZLFVBQVVDLE9BQU8sQ0FBQzBILHFCQUFxQixHQUFHZ0csS0FBSyxLQUFLLE9BQU9xSyxpREFBaUQsR0FBR2pWLE9BQU84RCxVQUFVO1FBQ3ROLE1BQU1xUixvQkFBb0IxVyxjQUFjLFVBQVVBLGNBQWM7UUFDaEUsSUFBSTZJLEtBQUtpRixHQUFHLENBQUNrRyxnQkFBZ0IsQ0FBQzBDLG9CQUFvQkQscUJBQXFCRixtQkFBa0IsSUFBS2pGLGdCQUFnQjtZQUMxR3ZSO1lBQ0FzUixpQkFBaUIsT0FBTyxLQUFLLElBQUlBLGNBQWN2TCxPQUFPO1lBQ3REO1FBQ0o7UUFDQXVMLGlCQUFpQixPQUFPLEtBQUssSUFBSUEsY0FBY3ZMLE9BQU87UUFDdERtUTtJQUNKO0lBQ0EvWCw0Q0FBd0I7MEJBQUM7WUFDckIsc0RBQXNEO1lBQ3RELElBQUlrQixRQUFRO2dCQUNSa0ksSUFBSWhLLFNBQVNtRixlQUFlLEVBQUU7b0JBQzFCa1UsZ0JBQWdCO2dCQUNwQjtnQkFDQXBFLFNBQVM5VCxPQUFPLEdBQUcsSUFBSXlVO1lBQzNCO1lBQ0E7a0NBQU87b0JBQ0hsTCxNQUFNMUssU0FBU21GLGVBQWUsRUFBRTtnQkFDcEM7O1FBQ0o7eUJBQUc7UUFDQ3JEO0tBQ0g7SUFDRCxTQUFTTCxtQkFBbUJrVCxDQUFDO1FBQ3pCLE1BQU0yRSxRQUFRM0UsSUFBSSxDQUFDMVEsT0FBTzhELFVBQVUsR0FBR3VFLG1CQUFrQixJQUFLckksT0FBTzhELFVBQVUsR0FBRztRQUNsRixNQUFNd1IsbUJBQW1CNUUsSUFBSSxDQUFDckksc0JBQXNCO1FBQ3BELElBQUlnSixzQkFBc0JuVSxPQUFPLEVBQUU7WUFDL0I4QyxPQUFPd04sWUFBWSxDQUFDNkQsc0JBQXNCblUsT0FBTztRQUNyRDtRQUNBNkksSUFBSTlJLFVBQVVDLE9BQU8sRUFBRTtZQUNuQnNPLFlBQVksQ0FBQyxVQUFVLEVBQUUxRCxZQUFZQyxRQUFRLENBQUMsZUFBZSxFQUFFRCxZQUFZRSxJQUFJLENBQUN5RCxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7WUFDNUY1SSxXQUFXK0QsV0FBV25JLGFBQWEsQ0FBQyxNQUFNLEVBQUU0VyxNQUFNLGlCQUFpQixFQUFFQyxpQkFBaUIsTUFBTSxDQUFDLEdBQUcsQ0FBQyxNQUFNLEVBQUVELE1BQU0sY0FBYyxFQUFFQyxpQkFBaUIsU0FBUyxDQUFDO1FBQzlKO1FBQ0EsSUFBSSxDQUFDNUUsS0FBS3pULFVBQVVDLE9BQU8sRUFBRTtZQUN6Qm1VLHNCQUFzQm5VLE9BQU8sR0FBR2dSLFdBQVc7Z0JBQ3ZDLE1BQU1zRixpQkFBaUIzTSxhQUFhNUosVUFBVUMsT0FBTyxFQUFFdUI7Z0JBQ3ZEc0gsSUFBSTlJLFVBQVVDLE9BQU8sRUFBRTtvQkFDbkJzTyxZQUFZO29CQUNaM0ksV0FBVytELFdBQVduSSxhQUFhLENBQUMsZUFBZSxFQUFFK1UsZUFBZSxNQUFNLENBQUMsR0FBRyxDQUFDLFlBQVksRUFBRUEsZUFBZSxTQUFTLENBQUM7Z0JBQzFIO1lBQ0osR0FBRztRQUNQO0lBQ0o7SUFDQSxTQUFTalcsYUFBYWdZLE1BQU0sRUFBRXRJLGlCQUFpQjtRQUMzQyxJQUFJQSxvQkFBb0IsR0FBRztRQUMzQixNQUFNdUksZUFBZSxDQUFDeFYsT0FBTzhELFVBQVUsR0FBR3VFLG1CQUFrQixJQUFLckksT0FBTzhELFVBQVU7UUFDbEYsTUFBTTJSLFdBQVdELGVBQWV2SSxvQkFBcUIsS0FBSXVJLFlBQVc7UUFDcEUsTUFBTUUsZUFBZSxDQUFDck4sc0JBQXNCNEUsb0JBQW9CNUU7UUFDaEV0QyxJQUFJOUksVUFBVUMsT0FBTyxFQUFFO1lBQ25CMkYsV0FBVytELFdBQVduSSxhQUFhLENBQUMsTUFBTSxFQUFFZ1gsU0FBUyxpQkFBaUIsRUFBRUMsYUFBYSxNQUFNLENBQUMsR0FBRyxDQUFDLE1BQU0sRUFBRUQsU0FBUyxjQUFjLEVBQUVDLGFBQWEsU0FBUyxDQUFDO1lBQ3hKbEssWUFBWTtRQUNoQjtJQUNKO0lBQ0EsU0FBUy9OLGdCQUFnQjhYLE1BQU0sRUFBRTdFLENBQUM7UUFDOUIsTUFBTWxFLE1BQU01RixXQUFXbkksYUFBYXVCLE9BQU9rRCxXQUFXLEdBQUdsRCxPQUFPOEQsVUFBVTtRQUMxRSxNQUFNdVIsUUFBUTNFLElBQUksQ0FBQ2xFLE1BQU1uRSxtQkFBa0IsSUFBS21FLE1BQU07UUFDdEQsTUFBTW1KLFlBQVlqRixJQUFJLENBQUNySSxzQkFBc0I7UUFDN0MsSUFBSXFJLEdBQUc7WUFDSDNLLElBQUk5SSxVQUFVQyxPQUFPLEVBQUU7Z0JBQ25Cc08sWUFBWSxDQUFDLFVBQVUsRUFBRTFELFlBQVlDLFFBQVEsQ0FBQyxlQUFlLEVBQUVELFlBQVlFLElBQUksQ0FBQ3lELElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztnQkFDNUY1SSxXQUFXK0QsV0FBV25JLGFBQWEsQ0FBQyxNQUFNLEVBQUU0VyxNQUFNLGlCQUFpQixFQUFFTSxVQUFVLE1BQU0sQ0FBQyxHQUFHLENBQUMsTUFBTSxFQUFFTixNQUFNLGNBQWMsRUFBRU0sVUFBVSxTQUFTLENBQUM7WUFDaEo7UUFDSjtJQUNKO0lBQ0FoWiw0Q0FBd0I7MEJBQUM7WUFDckIsSUFBSSxDQUFDd0IsT0FBTztnQkFDUix5Q0FBeUM7Z0JBQ3pDNkIsT0FBTytDLHFCQUFxQjtzQ0FBQzt3QkFDekJoSCxTQUFTaUcsSUFBSSxDQUFDOUYsS0FBSyxDQUFDeVUsYUFBYSxHQUFHO29CQUN4Qzs7WUFDSjtRQUNKO3lCQUFHO1FBQ0N4UztLQUNIO0lBQ0QsT0FBTyxXQUFXLEdBQUd4QixnREFBNEIsQ0FBQ0Ysd0RBQW9CLEVBQUU7UUFDcEUwVCxhQUFhQTtRQUNiN1IsY0FBYyxDQUFDcVI7WUFDWCxJQUFJLENBQUMvUixlQUFlLENBQUMrUixNQUFNO1lBQzNCLElBQUlBLE1BQU07Z0JBQ05pQixpQkFBaUI7WUFDckIsT0FBTztnQkFDSHBTLFlBQVk7WUFDaEI7WUFDQWlTLFVBQVVkO1FBQ2Q7UUFDQUEsTUFBTTlSO0lBQ1YsR0FBRyxXQUFXLEdBQUdsQixnREFBNEIsQ0FBQ0ksY0FBYzZZLFFBQVEsRUFBRTtRQUNsRXZSLE9BQU87WUFDSGhHO1lBQ0FKO1lBQ0FNO1lBQ0F0QjtZQUNBRTtZQUNBbUI7WUFDQWxCO1lBQ0FDO1lBQ0FDO1lBQ0FNO1lBQ0FjO1lBQ0FSO1lBQ0FMO1lBQ0FDO1lBQ0FNO1lBQ0FJO1lBQ0FqQjtZQUNBQztZQUNBQztZQUNBTTtZQUNBSTtZQUNBSDtZQUNBcU07WUFDQTVMO1lBQ0FFO1lBQ0FDO1lBQ0FDO1lBQ0FDO1lBQ0FDO1FBQ0o7SUFDSixHQUFHNlE7QUFDUDtBQUNBLE1BQU1pRyxVQUFVLFdBQVcsR0FBR2xaLDZDQUF5QixDQUFDLFNBQVMsRUFBRSxHQUFHb1osTUFBTSxFQUFFeFEsR0FBRztJQUM3RSxNQUFNLEVBQUVwSSxVQUFVLEVBQUVjLFVBQVUsRUFBRVosU0FBUyxFQUFFZSxVQUFVLEVBQUVQLE1BQU0sRUFBRU0sS0FBSyxFQUFFTyxhQUFhLEVBQUUsR0FBR007SUFDeEYsTUFBTWdYLGNBQWNyUSxnQkFBZ0JKLEtBQUtwSTtJQUN6QyxNQUFNOFksZ0JBQWdCaFksY0FBY0EsV0FBV21NLE1BQU0sR0FBRztJQUN4RCx3SUFBd0k7SUFDeEksSUFBSSxDQUFDak0sT0FBTztRQUNSLE9BQU87SUFDWDtJQUNBLE1BQU0rWCxZQUFZdlosOENBQTBCOzBDQUFDLENBQUM0SCxRQUFRbEgsVUFBVWtIO3lDQUFRO1FBQ3BFbEg7S0FDSDtJQUNELE9BQU8sV0FBVyxHQUFHVixnREFBNEIsQ0FBQ0YsMkRBQXVCLEVBQUU7UUFDdkV5WixXQUFXQTtRQUNYM1EsS0FBS3lRO1FBQ0wscUJBQXFCO1FBQ3JCLHlCQUF5Qm5ZLFVBQVVvWSxnQkFBZ0IsU0FBUztRQUM1RCxpQ0FBaUNwWSxVQUFVTyxhQUFhLFNBQVM7UUFDakUscUJBQXFCLENBQUNNLGlCQUFpQixPQUFPLEtBQUssSUFBSUEsY0FBY3hCLE9BQU8sSUFBSSxTQUFTO1FBQ3pGLEdBQUc2WSxJQUFJO0lBQ1g7QUFDSjtBQUNBRixRQUFRTSxXQUFXLEdBQUc7QUFDdEIsTUFBTUMsVUFBVSxXQUFXLEdBQUd6Wiw2Q0FBeUIsQ0FBQyxTQUFTLEVBQUUwWixvQkFBb0IsRUFBRW5hLEtBQUssRUFBRW9hLGVBQWUsRUFBRSxHQUFHUCxNQUFNLEVBQUV4USxHQUFHO0lBQzNILE1BQU0sRUFBRXRJLFNBQVMsRUFBRUcsT0FBTyxFQUFFQyxTQUFTLEVBQUVDLE1BQU0sRUFBRVMsY0FBYyxFQUFFQyxnQkFBZ0IsRUFBRXFNLG9CQUFvQixFQUFFbE0sS0FBSyxFQUFFTixNQUFNLEVBQUVZLFNBQVMsRUFBRVIsVUFBVSxFQUFFYSxTQUFTLEVBQUVaLFVBQVUsRUFBRVEsYUFBYSxFQUFFSyxTQUFTLEVBQUUsR0FBR0M7SUFDak0saURBQWlEO0lBQ2pELE1BQU0sQ0FBQ3VYLG1CQUFtQkMscUJBQXFCLEdBQUc3WiwyQ0FBdUIsQ0FBQztJQUMxRSxNQUFNcVosY0FBY3JRLGdCQUFnQkosS0FBS3RJO0lBQ3pDLE1BQU13WixrQkFBa0I5Wix5Q0FBcUIsQ0FBQztJQUM5QyxNQUFNK1osMkJBQTJCL1oseUNBQXFCLENBQUM7SUFDdkQsTUFBTWdhLHVCQUF1QmhhLHlDQUFxQixDQUFDO0lBQ25ELE1BQU1zWixnQkFBZ0JoWSxjQUFjQSxXQUFXbU0sTUFBTSxHQUFHO0lBQ3hEK0M7SUFDQSxNQUFNeUoscUJBQXFCLENBQUNDLE9BQU9wWSxXQUFXcVksWUFBWSxDQUFDO1FBQ3ZELElBQUlILHFCQUFxQnpaLE9BQU8sRUFBRSxPQUFPO1FBQ3pDLE1BQU02WixTQUFTelAsS0FBS2lGLEdBQUcsQ0FBQ3NLLE1BQU14VSxDQUFDO1FBQy9CLE1BQU0yVSxTQUFTMVAsS0FBS2lGLEdBQUcsQ0FBQ3NLLE1BQU16SCxDQUFDO1FBQy9CLE1BQU02SCxXQUFXRCxTQUFTRDtRQUMxQixNQUFNRyxVQUFVO1lBQ1o7WUFDQTtTQUNILENBQUNDLFFBQVEsQ0FBQzFZLGFBQWEsSUFBSSxDQUFDO1FBQzdCLElBQUlBLGNBQWMsVUFBVUEsY0FBYyxTQUFTO1lBQy9DLE1BQU0yWSxxQkFBcUJQLE1BQU16SCxDQUFDLEdBQUc4SCxVQUFVO1lBQy9DLElBQUksQ0FBQ0Usc0JBQXNCSixVQUFVLEtBQUtBLFVBQVVGLFdBQVc7Z0JBQzNELE9BQU9HO1lBQ1g7UUFDSixPQUFPO1lBQ0gsTUFBTUcscUJBQXFCUCxNQUFNeFUsQ0FBQyxHQUFHNlUsVUFBVTtZQUMvQyxJQUFJLENBQUNFLHNCQUFzQkwsVUFBVSxLQUFLQSxVQUFVRCxXQUFXO2dCQUMzRCxPQUFPLENBQUNHO1lBQ1o7UUFDSjtRQUNBTixxQkFBcUJ6WixPQUFPLEdBQUc7UUFDL0IsT0FBTztJQUNYO0lBQ0FQLDRDQUF3Qjs2QkFBQztZQUNyQixJQUFJc1osZUFBZTtnQkFDZmpXLE9BQU8rQyxxQkFBcUI7eUNBQUM7d0JBQ3pCeVQscUJBQXFCO29CQUN6Qjs7WUFDSjtRQUNKOzRCQUFHLEVBQUU7SUFDTCxTQUFTYSxrQkFBa0I5UyxLQUFLO1FBQzVCa1MsZ0JBQWdCdlosT0FBTyxHQUFHO1FBQzFCeVoscUJBQXFCelosT0FBTyxHQUFHO1FBQy9CRyxVQUFVa0g7SUFDZDtJQUNBLE9BQU8sV0FBVyxHQUFHNUgsZ0RBQTRCLENBQUNGLDJEQUF1QixFQUFFO1FBQ3ZFLDhCQUE4QmdDO1FBQzlCLG9CQUFvQjtRQUNwQixpQ0FBaUM4WCxvQkFBb0IsU0FBUztRQUM5RCx5QkFBeUIxWSxVQUFVb1ksZ0JBQWdCLFNBQVM7UUFDNUQsOEJBQThCblgsWUFBWSxTQUFTO1FBQ25ELHFCQUFxQixDQUFDSixpQkFBaUIsT0FBTyxLQUFLLElBQUlBLGNBQWN4QixPQUFPLElBQUksU0FBUztRQUN6RixHQUFHNlksSUFBSTtRQUNQeFEsS0FBS3lRO1FBQ0w5WixPQUFPOEIsb0JBQW9CQSxpQkFBaUJvTSxNQUFNLEdBQUcsSUFBSTtZQUNyRCx1QkFBdUIsR0FBR3BNLGdCQUFnQixDQUFDcU0sd0JBQXdCLE9BQU9BLHVCQUF1QixFQUFFLENBQUMsRUFBRSxDQUFDO1lBQ3ZHLEdBQUduTyxLQUFLO1FBQ1osSUFBSUE7UUFDSm9iLGVBQWUsQ0FBQy9TO1lBQ1osSUFBSXJHLFlBQVk7WUFDaEI2WCxLQUFLdUIsYUFBYSxJQUFJLE9BQU8sS0FBSyxJQUFJdkIsS0FBS3VCLGFBQWEsQ0FBQzNPLElBQUksQ0FBQ29OLE1BQU14UjtZQUNwRWtTLGdCQUFnQnZaLE9BQU8sR0FBRztnQkFDdEJrUyxHQUFHN0ssTUFBTTJOLEtBQUs7Z0JBQ2Q3UCxHQUFHa0MsTUFBTXJDLEtBQUs7WUFDbEI7WUFDQTlFLFFBQVFtSDtRQUNaO1FBQ0ErUixpQkFBaUIsQ0FBQ3hVO1lBQ2R3VSxtQkFBbUIsT0FBTyxLQUFLLElBQUlBLGdCQUFnQnhVO1lBQ25ELElBQUksQ0FBQy9DLFdBQVc7Z0JBQ1orQyxFQUFFTSxjQUFjO1lBQ3BCO1FBQ0o7UUFDQWlVLHNCQUFzQixDQUFDdlU7WUFDbkJ1VSx3QkFBd0IsT0FBTyxLQUFLLElBQUlBLHFCQUFxQnZVO1lBQzdELElBQUksQ0FBQzNELFNBQVMyRCxFQUFFeVYsZ0JBQWdCLEVBQUU7Z0JBQzlCelYsRUFBRU0sY0FBYztnQkFDaEI7WUFDSjtZQUNBLElBQUlyRSxlQUFlYixPQUFPLEVBQUU7Z0JBQ3hCYSxlQUFlYixPQUFPLEdBQUc7WUFDN0I7UUFDSjtRQUNBc2EsZ0JBQWdCLENBQUMxVjtZQUNiLElBQUksQ0FBQzNELE9BQU87Z0JBQ1IyRCxFQUFFTSxjQUFjO2dCQUNoQjtZQUNKO1FBQ0o7UUFDQXFWLGVBQWUsQ0FBQ2xUO1lBQ1ptUyx5QkFBeUJ4WixPQUFPLEdBQUdxSDtZQUNuQyxJQUFJckcsWUFBWTtZQUNoQjZYLEtBQUswQixhQUFhLElBQUksT0FBTyxLQUFLLElBQUkxQixLQUFLMEIsYUFBYSxDQUFDOU8sSUFBSSxDQUFDb04sTUFBTXhSO1lBQ3BFLElBQUksQ0FBQ2tTLGdCQUFnQnZaLE9BQU8sRUFBRTtZQUM5QixNQUFNd2EsWUFBWW5ULE1BQU1yQyxLQUFLLEdBQUd1VSxnQkFBZ0J2WixPQUFPLENBQUNtRixDQUFDO1lBQ3pELE1BQU1zVixZQUFZcFQsTUFBTTJOLEtBQUssR0FBR3VFLGdCQUFnQnZaLE9BQU8sQ0FBQ2tTLENBQUM7WUFDekQsTUFBTXdJLHNCQUFzQnJULE1BQU1zVCxXQUFXLEtBQUssVUFBVSxLQUFLO1lBQ2pFLE1BQU1oQixRQUFRO2dCQUNWekgsR0FBR3VJO2dCQUNIdFYsR0FBR3FWO1lBQ1A7WUFDQSxNQUFNSSxtQkFBbUJsQixtQkFBbUJDLE9BQU9wWSxXQUFXbVo7WUFDOUQsSUFBSUUsa0JBQWtCeGEsT0FBT2lIO2lCQUN4QixJQUFJK0MsS0FBS2lGLEdBQUcsQ0FBQ29MLGFBQWFDLHVCQUF1QnRRLEtBQUtpRixHQUFHLENBQUNtTCxhQUFhRSxxQkFBcUI7Z0JBQzdGbkIsZ0JBQWdCdlosT0FBTyxHQUFHO1lBQzlCO1FBQ0o7UUFDQTZhLGFBQWEsQ0FBQ3hUO1lBQ1Z3UixLQUFLZ0MsV0FBVyxJQUFJLE9BQU8sS0FBSyxJQUFJaEMsS0FBS2dDLFdBQVcsQ0FBQ3BQLElBQUksQ0FBQ29OLE1BQU14UjtZQUNoRWtTLGdCQUFnQnZaLE9BQU8sR0FBRztZQUMxQnlaLHFCQUFxQnpaLE9BQU8sR0FBRztZQUMvQkcsVUFBVWtIO1FBQ2Q7UUFDQXlULGNBQWMsQ0FBQ3pUO1lBQ1h3UixLQUFLaUMsWUFBWSxJQUFJLE9BQU8sS0FBSyxJQUFJakMsS0FBS2lDLFlBQVksQ0FBQ3JQLElBQUksQ0FBQ29OLE1BQU14UjtZQUNsRThTLGtCQUFrQlgseUJBQXlCeFosT0FBTztRQUN0RDtRQUNBK2EsZUFBZSxDQUFDMVQ7WUFDWndSLEtBQUtrQyxhQUFhLElBQUksT0FBTyxLQUFLLElBQUlsQyxLQUFLa0MsYUFBYSxDQUFDdFAsSUFBSSxDQUFDb04sTUFBTXhSO1lBQ3BFLElBQUltUyx5QkFBeUJ4WixPQUFPLEVBQUU7Z0JBQ2xDbWEsa0JBQWtCWCx5QkFBeUJ4WixPQUFPO1lBQ3REO1FBQ0o7SUFDSjtBQUNKO0FBQ0FrWixRQUFRRCxXQUFXLEdBQUc7QUFDdEIsTUFBTStCLDRCQUE0QjtBQUNsQyxNQUFNQyxxQkFBcUI7QUFDM0IsTUFBTUMsU0FBUyxXQUFXLEdBQUd6Yiw2Q0FBeUIsQ0FBQyxTQUFTLEVBQUUwYixlQUFlLEtBQUssRUFBRXpJLFFBQVEsRUFBRSxHQUFHbUcsTUFBTSxFQUFFeFEsR0FBRztJQUM1RyxNQUFNLEVBQUUvRyxXQUFXLEVBQUVWLFVBQVUsRUFBRUcsVUFBVSxFQUFFSSxlQUFlLEVBQUVFLGtCQUFrQixFQUFFWCxXQUFXLEVBQUVNLFVBQVUsRUFBRUwsTUFBTSxFQUFFVCxPQUFPLEVBQUVFLE1BQU0sRUFBRSxHQUFHMEI7SUFDdkksTUFBTXNaLG9CQUFvQjNiLHlDQUFxQixDQUFDO0lBQ2hELE1BQU00Yiw2QkFBNkI1Yix5Q0FBcUIsQ0FBQztJQUN6RCxTQUFTNmI7UUFDTCxxREFBcUQ7UUFDckQsSUFBSUQsMkJBQTJCcmIsT0FBTyxFQUFFO1lBQ3BDdWI7WUFDQTtRQUNKO1FBQ0F6WSxPQUFPa08sVUFBVSxDQUFDO1lBQ2R3SztRQUNKLEdBQUdQO0lBQ1A7SUFDQSxTQUFTTztRQUNMLGdEQUFnRDtRQUNoRCxJQUFJNWEsY0FBY3VhLGdCQUFnQkUsMkJBQTJCcmIsT0FBTyxFQUFFO1lBQ2xFdWI7WUFDQTtRQUNKO1FBQ0EsOEZBQThGO1FBQzlGQTtRQUNBLElBQUksQ0FBQ3hhLGNBQWNBLFdBQVdtTSxNQUFNLEtBQUssR0FBRztZQUN4QyxJQUFJLENBQUN4TSxhQUFhO2dCQUNkWTtZQUNKO1lBQ0E7UUFDSjtRQUNBLE1BQU0yTCxrQkFBa0I5TCxvQkFBb0JKLFVBQVUsQ0FBQ0EsV0FBV21NLE1BQU0sR0FBRyxFQUFFO1FBQzdFLElBQUlELG1CQUFtQnZNLGFBQWE7WUFDaENZO1lBQ0E7UUFDSjtRQUNBLE1BQU1tYSxtQkFBbUIxYSxXQUFXc00sU0FBUyxDQUFDLENBQUNxTyxRQUFRQSxVQUFVdmE7UUFDakUsSUFBSXNhLHFCQUFxQixDQUFDLEdBQUcsUUFBUSwwQ0FBMEM7UUFDL0UsTUFBTUUsZ0JBQWdCNWEsVUFBVSxDQUFDMGEsbUJBQW1CLEVBQUU7UUFDdERwYSxtQkFBbUJzYTtJQUN2QjtJQUNBLFNBQVNDO1FBQ0xSLGtCQUFrQnBiLE9BQU8sR0FBRzhDLE9BQU9rTyxVQUFVLENBQUM7WUFDMUMsMkNBQTJDO1lBQzNDcUssMkJBQTJCcmIsT0FBTyxHQUFHO1FBQ3pDLEdBQUdnYjtJQUNQO0lBQ0EsU0FBU087UUFDTCxJQUFJSCxrQkFBa0JwYixPQUFPLEVBQUU7WUFDM0I4QyxPQUFPd04sWUFBWSxDQUFDOEssa0JBQWtCcGIsT0FBTztRQUNqRDtRQUNBcWIsMkJBQTJCcmIsT0FBTyxHQUFHO0lBQ3pDO0lBQ0EsT0FBTyxXQUFXLEdBQUdQLGdEQUE0QixDQUFDLE9BQU87UUFDckRvYyxTQUFTUDtRQUNUUSxpQkFBaUJQO1FBQ2pCbkIsZUFBZSxDQUFDeFY7WUFDWixJQUFJNUQsWUFBWWQsUUFBUTBFO1lBQ3hCZ1g7UUFDSjtRQUNBckIsZUFBZSxDQUFDM1Y7WUFDWixJQUFJNUQsWUFBWVosT0FBT3dFO1FBQzNCO1FBQ0EsMERBQTBEO1FBQzFEeUQsS0FBS0E7UUFDTCw0QkFBNEIxSCxTQUFTLFNBQVM7UUFDOUMsb0JBQW9CO1FBQ3BCLGVBQWU7UUFDZixHQUFHa1ksSUFBSTtJQUNYLEdBQUcsV0FBVyxHQUFHcFosZ0RBQTRCLENBQUMsUUFBUTtRQUNsRCw0QkFBNEI7UUFDNUIsZUFBZTtJQUNuQixHQUFHaVQ7QUFDUDtBQUNBd0ksT0FBT2pDLFdBQVcsR0FBRztBQUNyQixTQUFTOEMsV0FBVyxFQUFFM2IsTUFBTSxFQUFFZ0IsWUFBWSxFQUFFcVIsTUFBTXVKLFlBQVksRUFBRSxHQUFHbkQsTUFBTTtJQUNyRSxNQUFNLEVBQUV4WSxZQUFZLEVBQUVDLGtCQUFrQixFQUFFQyxlQUFlLEVBQUUsR0FBR3VCO0lBQzlELElBQUksQ0FBQ3pCLGNBQWM7UUFDZixNQUFNLElBQUk0QixNQUFNO0lBQ3BCO0lBQ0EsT0FBTyxXQUFXLEdBQUd4QyxnREFBNEIsQ0FBQytTLE1BQU07UUFDcERwQixRQUFRO1FBQ1JxQixNQUFNdUo7UUFDTmhKLFNBQVM7WUFDTDFTLG1CQUFtQjtRQUN2QjtRQUNBRixRQUFRLENBQUN3RSxHQUFHcVg7WUFDUjViLGFBQWF1RSxHQUFHcVg7WUFDaEI3YixVQUFVLE9BQU8sS0FBSyxJQUFJQSxPQUFPd0UsR0FBR3FYO1FBQ3hDO1FBQ0E3YSxjQUFjLENBQUNvUztZQUNYLElBQUlBLEdBQUc7Z0JBQ0hsVCxtQkFBbUJrVDtZQUN2QjtZQUNBcFMsZ0JBQWdCLE9BQU8sS0FBSyxJQUFJQSxhQUFhb1M7UUFDakQ7UUFDQXJULFdBQVdJO1FBQ1gsR0FBR3NZLElBQUk7SUFDWDtBQUNKO0FBQ0EsU0FBU3FELE9BQU9DLEtBQUs7SUFDakIsTUFBTXBhLFVBQVVEO0lBQ2hCLE1BQU0sRUFBRUYsWUFBWUcsUUFBUUgsU0FBUyxFQUFFLEdBQUd3YSxhQUFhLEdBQUdEO0lBQzFELE9BQU8sV0FBVyxHQUFHMWMsZ0RBQTRCLENBQUNGLDBEQUFzQixFQUFFO1FBQ3RFcUMsV0FBV0E7UUFDWCxHQUFHd2EsV0FBVztJQUNsQjtBQUNKO0FBQ0EsTUFBTUMsU0FBUztJQUNYN0o7SUFDQXVKO0lBQ0E3QztJQUNBUDtJQUNBMkQsU0FBUy9jLDJEQUF1QjtJQUNoQzJjO0lBQ0FoQjtJQUNBcUIsT0FBT2hkLHlEQUFxQjtJQUM1QmlkLE9BQU9qZCx5REFBcUI7SUFDNUJrZCxhQUFhbGQsK0RBQTJCO0FBQzVDO0FBRXNFIiwic291cmNlcyI6WyJEOlxcTmV3IGZvbGRlclxcTXkgYnVzaW5lc3NcXEFpIEVjb21tZXJjZVxcZS1jb21tZXJjZVxcbm9kZV9tb2R1bGVzXFx2YXVsXFxkaXN0XFxpbmRleC5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnO1xuZnVuY3Rpb24gX19pbnNlcnRDU1MoY29kZSkge1xuICBpZiAoIWNvZGUgfHwgdHlwZW9mIGRvY3VtZW50ID09ICd1bmRlZmluZWQnKSByZXR1cm5cbiAgbGV0IGhlYWQgPSBkb2N1bWVudC5oZWFkIHx8IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF1cbiAgbGV0IHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKVxuICBzdHlsZS50eXBlID0gJ3RleHQvY3NzJ1xuICBoZWFkLmFwcGVuZENoaWxkKHN0eWxlKVxuICA7c3R5bGUuc3R5bGVTaGVldCA/IChzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSBjb2RlKSA6IHN0eWxlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNvZGUpKVxufVxuXG5pbXBvcnQgKiBhcyBEaWFsb2dQcmltaXRpdmUgZnJvbSAnQHJhZGl4LXVpL3JlYWN0LWRpYWxvZyc7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUmVhY3RfX2RlZmF1bHQsIHsgdXNlTGF5b3V0RWZmZWN0LCB1c2VFZmZlY3QsIHVzZU1lbW8gfSBmcm9tICdyZWFjdCc7XG5cbmNvbnN0IERyYXdlckNvbnRleHQgPSBSZWFjdF9fZGVmYXVsdC5jcmVhdGVDb250ZXh0KHtcbiAgICBkcmF3ZXJSZWY6IHtcbiAgICAgICAgY3VycmVudDogbnVsbFxuICAgIH0sXG4gICAgb3ZlcmxheVJlZjoge1xuICAgICAgICBjdXJyZW50OiBudWxsXG4gICAgfSxcbiAgICBvblByZXNzOiAoKT0+e30sXG4gICAgb25SZWxlYXNlOiAoKT0+e30sXG4gICAgb25EcmFnOiAoKT0+e30sXG4gICAgb25OZXN0ZWREcmFnOiAoKT0+e30sXG4gICAgb25OZXN0ZWRPcGVuQ2hhbmdlOiAoKT0+e30sXG4gICAgb25OZXN0ZWRSZWxlYXNlOiAoKT0+e30sXG4gICAgb3BlblByb3A6IHVuZGVmaW5lZCxcbiAgICBkaXNtaXNzaWJsZTogZmFsc2UsXG4gICAgaXNPcGVuOiBmYWxzZSxcbiAgICBpc0RyYWdnaW5nOiBmYWxzZSxcbiAgICBrZXlib2FyZElzT3Blbjoge1xuICAgICAgICBjdXJyZW50OiBmYWxzZVxuICAgIH0sXG4gICAgc25hcFBvaW50c09mZnNldDogbnVsbCxcbiAgICBzbmFwUG9pbnRzOiBudWxsLFxuICAgIGhhbmRsZU9ubHk6IGZhbHNlLFxuICAgIG1vZGFsOiBmYWxzZSxcbiAgICBzaG91bGRGYWRlOiBmYWxzZSxcbiAgICBhY3RpdmVTbmFwUG9pbnQ6IG51bGwsXG4gICAgb25PcGVuQ2hhbmdlOiAoKT0+e30sXG4gICAgc2V0QWN0aXZlU25hcFBvaW50OiAoKT0+e30sXG4gICAgY2xvc2VEcmF3ZXI6ICgpPT57fSxcbiAgICBkaXJlY3Rpb246ICdib3R0b20nLFxuICAgIHNob3VsZEFuaW1hdGU6IHtcbiAgICAgICAgY3VycmVudDogdHJ1ZVxuICAgIH0sXG4gICAgc2hvdWxkU2NhbGVCYWNrZ3JvdW5kOiBmYWxzZSxcbiAgICBzZXRCYWNrZ3JvdW5kQ29sb3JPblNjYWxlOiB0cnVlLFxuICAgIG5vQm9keVN0eWxlczogZmFsc2UsXG4gICAgY29udGFpbmVyOiBudWxsLFxuICAgIGF1dG9Gb2N1czogZmFsc2Vcbn0pO1xuY29uc3QgdXNlRHJhd2VyQ29udGV4dCA9ICgpPT57XG4gICAgY29uc3QgY29udGV4dCA9IFJlYWN0X19kZWZhdWx0LnVzZUNvbnRleHQoRHJhd2VyQ29udGV4dCk7XG4gICAgaWYgKCFjb250ZXh0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndXNlRHJhd2VyQ29udGV4dCBtdXN0IGJlIHVzZWQgd2l0aGluIGEgRHJhd2VyLlJvb3QnKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnRleHQ7XG59O1xuXG5fX2luc2VydENTUyhcIltkYXRhLXZhdWwtZHJhd2VyXXt0b3VjaC1hY3Rpb246bm9uZTt3aWxsLWNoYW5nZTp0cmFuc2Zvcm07dHJhbnNpdGlvbjp0cmFuc2Zvcm0gLjVzIGN1YmljLWJlemllciguMzIsIC43MiwgMCwgMSk7YW5pbWF0aW9uLWR1cmF0aW9uOi41czthbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOmN1YmljLWJlemllcigwLjMyLDAuNzIsMCwxKX1bZGF0YS12YXVsLWRyYXdlcl1bZGF0YS12YXVsLXNuYXAtcG9pbnRzPWZhbHNlXVtkYXRhLXZhdWwtZHJhd2VyLWRpcmVjdGlvbj1ib3R0b21dW2RhdGEtc3RhdGU9b3Blbl17YW5pbWF0aW9uLW5hbWU6c2xpZGVGcm9tQm90dG9tfVtkYXRhLXZhdWwtZHJhd2VyXVtkYXRhLXZhdWwtc25hcC1wb2ludHM9ZmFsc2VdW2RhdGEtdmF1bC1kcmF3ZXItZGlyZWN0aW9uPWJvdHRvbV1bZGF0YS1zdGF0ZT1jbG9zZWRde2FuaW1hdGlvbi1uYW1lOnNsaWRlVG9Cb3R0b219W2RhdGEtdmF1bC1kcmF3ZXJdW2RhdGEtdmF1bC1zbmFwLXBvaW50cz1mYWxzZV1bZGF0YS12YXVsLWRyYXdlci1kaXJlY3Rpb249dG9wXVtkYXRhLXN0YXRlPW9wZW5de2FuaW1hdGlvbi1uYW1lOnNsaWRlRnJvbVRvcH1bZGF0YS12YXVsLWRyYXdlcl1bZGF0YS12YXVsLXNuYXAtcG9pbnRzPWZhbHNlXVtkYXRhLXZhdWwtZHJhd2VyLWRpcmVjdGlvbj10b3BdW2RhdGEtc3RhdGU9Y2xvc2VkXXthbmltYXRpb24tbmFtZTpzbGlkZVRvVG9wfVtkYXRhLXZhdWwtZHJhd2VyXVtkYXRhLXZhdWwtc25hcC1wb2ludHM9ZmFsc2VdW2RhdGEtdmF1bC1kcmF3ZXItZGlyZWN0aW9uPWxlZnRdW2RhdGEtc3RhdGU9b3Blbl17YW5pbWF0aW9uLW5hbWU6c2xpZGVGcm9tTGVmdH1bZGF0YS12YXVsLWRyYXdlcl1bZGF0YS12YXVsLXNuYXAtcG9pbnRzPWZhbHNlXVtkYXRhLXZhdWwtZHJhd2VyLWRpcmVjdGlvbj1sZWZ0XVtkYXRhLXN0YXRlPWNsb3NlZF17YW5pbWF0aW9uLW5hbWU6c2xpZGVUb0xlZnR9W2RhdGEtdmF1bC1kcmF3ZXJdW2RhdGEtdmF1bC1zbmFwLXBvaW50cz1mYWxzZV1bZGF0YS12YXVsLWRyYXdlci1kaXJlY3Rpb249cmlnaHRdW2RhdGEtc3RhdGU9b3Blbl17YW5pbWF0aW9uLW5hbWU6c2xpZGVGcm9tUmlnaHR9W2RhdGEtdmF1bC1kcmF3ZXJdW2RhdGEtdmF1bC1zbmFwLXBvaW50cz1mYWxzZV1bZGF0YS12YXVsLWRyYXdlci1kaXJlY3Rpb249cmlnaHRdW2RhdGEtc3RhdGU9Y2xvc2VkXXthbmltYXRpb24tbmFtZTpzbGlkZVRvUmlnaHR9W2RhdGEtdmF1bC1kcmF3ZXJdW2RhdGEtdmF1bC1zbmFwLXBvaW50cz10cnVlXVtkYXRhLXZhdWwtZHJhd2VyLWRpcmVjdGlvbj1ib3R0b21de3RyYW5zZm9ybTp0cmFuc2xhdGUzZCgwLHZhcigtLWluaXRpYWwtdHJhbnNmb3JtLDEwMCUpLDApfVtkYXRhLXZhdWwtZHJhd2VyXVtkYXRhLXZhdWwtc25hcC1wb2ludHM9dHJ1ZV1bZGF0YS12YXVsLWRyYXdlci1kaXJlY3Rpb249dG9wXXt0cmFuc2Zvcm06dHJhbnNsYXRlM2QoMCxjYWxjKHZhcigtLWluaXRpYWwtdHJhbnNmb3JtLDEwMCUpICogLTEpLDApfVtkYXRhLXZhdWwtZHJhd2VyXVtkYXRhLXZhdWwtc25hcC1wb2ludHM9dHJ1ZV1bZGF0YS12YXVsLWRyYXdlci1kaXJlY3Rpb249bGVmdF17dHJhbnNmb3JtOnRyYW5zbGF0ZTNkKGNhbGModmFyKC0taW5pdGlhbC10cmFuc2Zvcm0sMTAwJSkgKiAtMSksMCwwKX1bZGF0YS12YXVsLWRyYXdlcl1bZGF0YS12YXVsLXNuYXAtcG9pbnRzPXRydWVdW2RhdGEtdmF1bC1kcmF3ZXItZGlyZWN0aW9uPXJpZ2h0XXt0cmFuc2Zvcm06dHJhbnNsYXRlM2QodmFyKC0taW5pdGlhbC10cmFuc2Zvcm0sMTAwJSksMCwwKX1bZGF0YS12YXVsLWRyYXdlcl1bZGF0YS12YXVsLWRlbGF5ZWQtc25hcC1wb2ludHM9dHJ1ZV1bZGF0YS12YXVsLWRyYXdlci1kaXJlY3Rpb249dG9wXXt0cmFuc2Zvcm06dHJhbnNsYXRlM2QoMCx2YXIoLS1zbmFwLXBvaW50LWhlaWdodCwwKSwwKX1bZGF0YS12YXVsLWRyYXdlcl1bZGF0YS12YXVsLWRlbGF5ZWQtc25hcC1wb2ludHM9dHJ1ZV1bZGF0YS12YXVsLWRyYXdlci1kaXJlY3Rpb249Ym90dG9tXXt0cmFuc2Zvcm06dHJhbnNsYXRlM2QoMCx2YXIoLS1zbmFwLXBvaW50LWhlaWdodCwwKSwwKX1bZGF0YS12YXVsLWRyYXdlcl1bZGF0YS12YXVsLWRlbGF5ZWQtc25hcC1wb2ludHM9dHJ1ZV1bZGF0YS12YXVsLWRyYXdlci1kaXJlY3Rpb249bGVmdF17dHJhbnNmb3JtOnRyYW5zbGF0ZTNkKHZhcigtLXNuYXAtcG9pbnQtaGVpZ2h0LDApLDAsMCl9W2RhdGEtdmF1bC1kcmF3ZXJdW2RhdGEtdmF1bC1kZWxheWVkLXNuYXAtcG9pbnRzPXRydWVdW2RhdGEtdmF1bC1kcmF3ZXItZGlyZWN0aW9uPXJpZ2h0XXt0cmFuc2Zvcm06dHJhbnNsYXRlM2QodmFyKC0tc25hcC1wb2ludC1oZWlnaHQsMCksMCwwKX1bZGF0YS12YXVsLW92ZXJsYXldW2RhdGEtdmF1bC1zbmFwLXBvaW50cz1mYWxzZV17YW5pbWF0aW9uLWR1cmF0aW9uOi41czthbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOmN1YmljLWJlemllcigwLjMyLDAuNzIsMCwxKX1bZGF0YS12YXVsLW92ZXJsYXldW2RhdGEtdmF1bC1zbmFwLXBvaW50cz1mYWxzZV1bZGF0YS1zdGF0ZT1vcGVuXXthbmltYXRpb24tbmFtZTpmYWRlSW59W2RhdGEtdmF1bC1vdmVybGF5XVtkYXRhLXN0YXRlPWNsb3NlZF17YW5pbWF0aW9uLW5hbWU6ZmFkZU91dH1bZGF0YS12YXVsLWFuaW1hdGU9ZmFsc2Vde2FuaW1hdGlvbjpub25lIWltcG9ydGFudH1bZGF0YS12YXVsLW92ZXJsYXldW2RhdGEtdmF1bC1zbmFwLXBvaW50cz10cnVlXXtvcGFjaXR5OjA7dHJhbnNpdGlvbjpvcGFjaXR5IC41cyBjdWJpYy1iZXppZXIoLjMyLCAuNzIsIDAsIDEpfVtkYXRhLXZhdWwtb3ZlcmxheV1bZGF0YS12YXVsLXNuYXAtcG9pbnRzPXRydWVde29wYWNpdHk6MX1bZGF0YS12YXVsLWRyYXdlcl06bm90KFtkYXRhLXZhdWwtY3VzdG9tLWNvbnRhaW5lcj10cnVlXSk6OmFmdGVye2NvbnRlbnQ6Jyc7cG9zaXRpb246YWJzb2x1dGU7YmFja2dyb3VuZDppbmhlcml0O2JhY2tncm91bmQtY29sb3I6aW5oZXJpdH1bZGF0YS12YXVsLWRyYXdlcl1bZGF0YS12YXVsLWRyYXdlci1kaXJlY3Rpb249dG9wXTo6YWZ0ZXJ7dG9wOmluaXRpYWw7Ym90dG9tOjEwMCU7bGVmdDowO3JpZ2h0OjA7aGVpZ2h0OjIwMCV9W2RhdGEtdmF1bC1kcmF3ZXJdW2RhdGEtdmF1bC1kcmF3ZXItZGlyZWN0aW9uPWJvdHRvbV06OmFmdGVye3RvcDoxMDAlO2JvdHRvbTppbml0aWFsO2xlZnQ6MDtyaWdodDowO2hlaWdodDoyMDAlfVtkYXRhLXZhdWwtZHJhd2VyXVtkYXRhLXZhdWwtZHJhd2VyLWRpcmVjdGlvbj1sZWZ0XTo6YWZ0ZXJ7bGVmdDppbml0aWFsO3JpZ2h0OjEwMCU7dG9wOjA7Ym90dG9tOjA7d2lkdGg6MjAwJX1bZGF0YS12YXVsLWRyYXdlcl1bZGF0YS12YXVsLWRyYXdlci1kaXJlY3Rpb249cmlnaHRdOjphZnRlcntsZWZ0OjEwMCU7cmlnaHQ6aW5pdGlhbDt0b3A6MDtib3R0b206MDt3aWR0aDoyMDAlfVtkYXRhLXZhdWwtb3ZlcmxheV1bZGF0YS12YXVsLXNuYXAtcG9pbnRzPXRydWVdOm5vdChbZGF0YS12YXVsLXNuYXAtcG9pbnRzLW92ZXJsYXk9dHJ1ZV0pOm5vdChcXG5bZGF0YS1zdGF0ZT1jbG9zZWRdXFxuKXtvcGFjaXR5OjB9W2RhdGEtdmF1bC1vdmVybGF5XVtkYXRhLXZhdWwtc25hcC1wb2ludHMtb3ZlcmxheT10cnVlXXtvcGFjaXR5OjF9W2RhdGEtdmF1bC1oYW5kbGVde2Rpc3BsYXk6YmxvY2s7cG9zaXRpb246cmVsYXRpdmU7b3BhY2l0eTouNztiYWNrZ3JvdW5kOiNlMmUyZTQ7bWFyZ2luLWxlZnQ6YXV0bzttYXJnaW4tcmlnaHQ6YXV0bztoZWlnaHQ6NXB4O3dpZHRoOjMycHg7Ym9yZGVyLXJhZGl1czoxcmVtO3RvdWNoLWFjdGlvbjpwYW4teX1bZGF0YS12YXVsLWhhbmRsZV06YWN0aXZlLFtkYXRhLXZhdWwtaGFuZGxlXTpob3ZlcntvcGFjaXR5OjF9W2RhdGEtdmF1bC1oYW5kbGUtaGl0YXJlYV17cG9zaXRpb246YWJzb2x1dGU7bGVmdDo1MCU7dG9wOjUwJTt0cmFuc2Zvcm06dHJhbnNsYXRlKC01MCUsLTUwJSk7d2lkdGg6bWF4KDEwMCUsMi43NXJlbSk7aGVpZ2h0Om1heCgxMDAlLDIuNzVyZW0pO3RvdWNoLWFjdGlvbjppbmhlcml0fUBtZWRpYSAoaG92ZXI6aG92ZXIpIGFuZCAocG9pbnRlcjpmaW5lKXtbZGF0YS12YXVsLWRyYXdlcl17dXNlci1zZWxlY3Q6bm9uZX19QG1lZGlhIChwb2ludGVyOmZpbmUpe1tkYXRhLXZhdWwtaGFuZGxlLWhpdGFyZWFdOnt3aWR0aDoxMDAlO2hlaWdodDoxMDAlfX1Aa2V5ZnJhbWVzIGZhZGVJbntmcm9te29wYWNpdHk6MH10b3tvcGFjaXR5OjF9fUBrZXlmcmFtZXMgZmFkZU91dHt0b3tvcGFjaXR5OjB9fUBrZXlmcmFtZXMgc2xpZGVGcm9tQm90dG9te2Zyb217dHJhbnNmb3JtOnRyYW5zbGF0ZTNkKDAsdmFyKC0taW5pdGlhbC10cmFuc2Zvcm0sMTAwJSksMCl9dG97dHJhbnNmb3JtOnRyYW5zbGF0ZTNkKDAsMCwwKX19QGtleWZyYW1lcyBzbGlkZVRvQm90dG9te3Rve3RyYW5zZm9ybTp0cmFuc2xhdGUzZCgwLHZhcigtLWluaXRpYWwtdHJhbnNmb3JtLDEwMCUpLDApfX1Aa2V5ZnJhbWVzIHNsaWRlRnJvbVRvcHtmcm9te3RyYW5zZm9ybTp0cmFuc2xhdGUzZCgwLGNhbGModmFyKC0taW5pdGlhbC10cmFuc2Zvcm0sMTAwJSkgKiAtMSksMCl9dG97dHJhbnNmb3JtOnRyYW5zbGF0ZTNkKDAsMCwwKX19QGtleWZyYW1lcyBzbGlkZVRvVG9we3Rve3RyYW5zZm9ybTp0cmFuc2xhdGUzZCgwLGNhbGModmFyKC0taW5pdGlhbC10cmFuc2Zvcm0sMTAwJSkgKiAtMSksMCl9fUBrZXlmcmFtZXMgc2xpZGVGcm9tTGVmdHtmcm9te3RyYW5zZm9ybTp0cmFuc2xhdGUzZChjYWxjKHZhcigtLWluaXRpYWwtdHJhbnNmb3JtLDEwMCUpICogLTEpLDAsMCl9dG97dHJhbnNmb3JtOnRyYW5zbGF0ZTNkKDAsMCwwKX19QGtleWZyYW1lcyBzbGlkZVRvTGVmdHt0b3t0cmFuc2Zvcm06dHJhbnNsYXRlM2QoY2FsYyh2YXIoLS1pbml0aWFsLXRyYW5zZm9ybSwxMDAlKSAqIC0xKSwwLDApfX1Aa2V5ZnJhbWVzIHNsaWRlRnJvbVJpZ2h0e2Zyb217dHJhbnNmb3JtOnRyYW5zbGF0ZTNkKHZhcigtLWluaXRpYWwtdHJhbnNmb3JtLDEwMCUpLDAsMCl9dG97dHJhbnNmb3JtOnRyYW5zbGF0ZTNkKDAsMCwwKX19QGtleWZyYW1lcyBzbGlkZVRvUmlnaHR7dG97dHJhbnNmb3JtOnRyYW5zbGF0ZTNkKHZhcigtLWluaXRpYWwtdHJhbnNmb3JtLDEwMCUpLDAsMCl9fVwiKTtcblxuZnVuY3Rpb24gaXNNb2JpbGVGaXJlZm94KCkge1xuICAgIGNvbnN0IHVzZXJBZ2VudCA9IG5hdmlnYXRvci51c2VyQWdlbnQ7XG4gICAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmICgvRmlyZWZveC8udGVzdCh1c2VyQWdlbnQpICYmIC9Nb2JpbGUvLnRlc3QodXNlckFnZW50KSB8fCAvLyBBbmRyb2lkIEZpcmVmb3hcbiAgICAvRnhpT1MvLnRlc3QodXNlckFnZW50KSAvLyBpT1MgRmlyZWZveFxuICAgICk7XG59XG5mdW5jdGlvbiBpc01hYygpIHtcbiAgICByZXR1cm4gdGVzdFBsYXRmb3JtKC9eTWFjLyk7XG59XG5mdW5jdGlvbiBpc0lQaG9uZSgpIHtcbiAgICByZXR1cm4gdGVzdFBsYXRmb3JtKC9eaVBob25lLyk7XG59XG5mdW5jdGlvbiBpc1NhZmFyaSgpIHtcbiAgICByZXR1cm4gL14oKD8hY2hyb21lfGFuZHJvaWQpLikqc2FmYXJpL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbn1cbmZ1bmN0aW9uIGlzSVBhZCgpIHtcbiAgICByZXR1cm4gdGVzdFBsYXRmb3JtKC9eaVBhZC8pIHx8IC8vIGlQYWRPUyAxMyBsaWVzIGFuZCBzYXlzIGl0J3MgYSBNYWMsIGJ1dCB3ZSBjYW4gZGlzdGluZ3Vpc2ggYnkgZGV0ZWN0aW5nIHRvdWNoIHN1cHBvcnQuXG4gICAgaXNNYWMoKSAmJiBuYXZpZ2F0b3IubWF4VG91Y2hQb2ludHMgPiAxO1xufVxuZnVuY3Rpb24gaXNJT1MoKSB7XG4gICAgcmV0dXJuIGlzSVBob25lKCkgfHwgaXNJUGFkKCk7XG59XG5mdW5jdGlvbiB0ZXN0UGxhdGZvcm0ocmUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Lm5hdmlnYXRvciAhPSBudWxsID8gcmUudGVzdCh3aW5kb3cubmF2aWdhdG9yLnBsYXRmb3JtKSA6IHVuZGVmaW5lZDtcbn1cblxuLy8gVGhpcyBjb2RlIGNvbWVzIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2Fkb2JlL3JlYWN0LXNwZWN0cnVtL2Jsb2IvbWFpbi9wYWNrYWdlcy8lNDByZWFjdC1hcmlhL292ZXJsYXlzL3NyYy91c2VQcmV2ZW50U2Nyb2xsLnRzXG5jb25zdCBLRVlCT0FSRF9CVUZGRVIgPSAyNDtcbmNvbnN0IHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHVzZUxheW91dEVmZmVjdCA6IHVzZUVmZmVjdDtcbmZ1bmN0aW9uIGNoYWluJDEoLi4uY2FsbGJhY2tzKSB7XG4gICAgcmV0dXJuICguLi5hcmdzKT0+e1xuICAgICAgICBmb3IgKGxldCBjYWxsYmFjayBvZiBjYWxsYmFja3Mpe1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKC4uLmFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbn1cbi8vIEB0cy1pZ25vcmVcbmNvbnN0IHZpc3VhbFZpZXdwb3J0ID0gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cudmlzdWFsVmlld3BvcnQ7XG5mdW5jdGlvbiBpc1Njcm9sbGFibGUobm9kZSkge1xuICAgIGxldCBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKG5vZGUpO1xuICAgIHJldHVybiAvKGF1dG98c2Nyb2xsKS8udGVzdChzdHlsZS5vdmVyZmxvdyArIHN0eWxlLm92ZXJmbG93WCArIHN0eWxlLm92ZXJmbG93WSk7XG59XG5mdW5jdGlvbiBnZXRTY3JvbGxQYXJlbnQobm9kZSkge1xuICAgIGlmIChpc1Njcm9sbGFibGUobm9kZSkpIHtcbiAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50RWxlbWVudDtcbiAgICB9XG4gICAgd2hpbGUobm9kZSAmJiAhaXNTY3JvbGxhYmxlKG5vZGUpKXtcbiAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50RWxlbWVudDtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGUgfHwgZG9jdW1lbnQuc2Nyb2xsaW5nRWxlbWVudCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG59XG4vLyBIVE1MIGlucHV0IHR5cGVzIHRoYXQgZG8gbm90IGNhdXNlIHRoZSBzb2Z0d2FyZSBrZXlib2FyZCB0byBhcHBlYXIuXG5jb25zdCBub25UZXh0SW5wdXRUeXBlcyA9IG5ldyBTZXQoW1xuICAgICdjaGVja2JveCcsXG4gICAgJ3JhZGlvJyxcbiAgICAncmFuZ2UnLFxuICAgICdjb2xvcicsXG4gICAgJ2ZpbGUnLFxuICAgICdpbWFnZScsXG4gICAgJ2J1dHRvbicsXG4gICAgJ3N1Ym1pdCcsXG4gICAgJ3Jlc2V0J1xuXSk7XG4vLyBUaGUgbnVtYmVyIG9mIGFjdGl2ZSB1c2VQcmV2ZW50U2Nyb2xsIGNhbGxzLiBVc2VkIHRvIGRldGVybWluZSB3aGV0aGVyIHRvIHJldmVydCBiYWNrIHRvIHRoZSBvcmlnaW5hbCBwYWdlIHN0eWxlL3Njcm9sbCBwb3NpdGlvblxubGV0IHByZXZlbnRTY3JvbGxDb3VudCA9IDA7XG5sZXQgcmVzdG9yZTtcbi8qKlxuICogUHJldmVudHMgc2Nyb2xsaW5nIG9uIHRoZSBkb2N1bWVudCBib2R5IG9uIG1vdW50LCBhbmRcbiAqIHJlc3RvcmVzIGl0IG9uIHVubW91bnQuIEFsc28gZW5zdXJlcyB0aGF0IGNvbnRlbnQgZG9lcyBub3RcbiAqIHNoaWZ0IGR1ZSB0byB0aGUgc2Nyb2xsYmFycyBkaXNhcHBlYXJpbmcuXG4gKi8gZnVuY3Rpb24gdXNlUHJldmVudFNjcm9sbChvcHRpb25zID0ge30pIHtcbiAgICBsZXQgeyBpc0Rpc2FibGVkIH0gPSBvcHRpb25zO1xuICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCk9PntcbiAgICAgICAgaWYgKGlzRGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBwcmV2ZW50U2Nyb2xsQ291bnQrKztcbiAgICAgICAgaWYgKHByZXZlbnRTY3JvbGxDb3VudCA9PT0gMSkge1xuICAgICAgICAgICAgaWYgKGlzSU9TKCkpIHtcbiAgICAgICAgICAgICAgICByZXN0b3JlID0gcHJldmVudFNjcm9sbE1vYmlsZVNhZmFyaSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoKT0+e1xuICAgICAgICAgICAgcHJldmVudFNjcm9sbENvdW50LS07XG4gICAgICAgICAgICBpZiAocHJldmVudFNjcm9sbENvdW50ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmVzdG9yZSA9PSBudWxsID8gdm9pZCAwIDogcmVzdG9yZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0sIFtcbiAgICAgICAgaXNEaXNhYmxlZFxuICAgIF0pO1xufVxuLy8gTW9iaWxlIFNhZmFyaSBpcyBhIHdob2xlIGRpZmZlcmVudCBiZWFzdC4gRXZlbiB3aXRoIG92ZXJmbG93OiBoaWRkZW4sXG4vLyBpdCBzdGlsbCBzY3JvbGxzIHRoZSBwYWdlIGluIG1hbnkgc2l0dWF0aW9uczpcbi8vXG4vLyAxLiBXaGVuIHRoZSBib3R0b20gdG9vbGJhciBhbmQgYWRkcmVzcyBiYXIgYXJlIGNvbGxhcHNlZCwgcGFnZSBzY3JvbGxpbmcgaXMgYWx3YXlzIGFsbG93ZWQuXG4vLyAyLiBXaGVuIHRoZSBrZXlib2FyZCBpcyB2aXNpYmxlLCB0aGUgdmlld3BvcnQgZG9lcyBub3QgcmVzaXplLiBJbnN0ZWFkLCB0aGUga2V5Ym9hcmQgY292ZXJzIHBhcnQgb2Zcbi8vICAgIGl0LCBzbyBpdCBiZWNvbWVzIHNjcm9sbGFibGUuXG4vLyAzLiBXaGVuIHRhcHBpbmcgb24gYW4gaW5wdXQsIHRoZSBwYWdlIGFsd2F5cyBzY3JvbGxzIHNvIHRoYXQgdGhlIGlucHV0IGlzIGNlbnRlcmVkIGluIHRoZSB2aXN1YWwgdmlld3BvcnQuXG4vLyAgICBUaGlzIG1heSBjYXVzZSBldmVuIGZpeGVkIHBvc2l0aW9uIGVsZW1lbnRzIHRvIHNjcm9sbCBvZmYgdGhlIHNjcmVlbi5cbi8vIDQuIFdoZW4gdXNpbmcgdGhlIG5leHQvcHJldmlvdXMgYnV0dG9ucyBpbiB0aGUga2V5Ym9hcmQgdG8gbmF2aWdhdGUgYmV0d2VlbiBpbnB1dHMsIHRoZSB3aG9sZSBwYWdlIGFsd2F5c1xuLy8gICAgc2Nyb2xscywgZXZlbiBpZiB0aGUgaW5wdXQgaXMgaW5zaWRlIGEgbmVzdGVkIHNjcm9sbGFibGUgZWxlbWVudCB0aGF0IGNvdWxkIGJlIHNjcm9sbGVkIGluc3RlYWQuXG4vL1xuLy8gSW4gb3JkZXIgdG8gd29yayBhcm91bmQgdGhlc2UgY2FzZXMsIGFuZCBwcmV2ZW50IHNjcm9sbGluZyB3aXRob3V0IGphbmtpbmVzcywgd2UgZG8gYSBmZXcgdGhpbmdzOlxuLy9cbi8vIDEuIFByZXZlbnQgZGVmYXVsdCBvbiBgdG91Y2htb3ZlYCBldmVudHMgdGhhdCBhcmUgbm90IGluIGEgc2Nyb2xsYWJsZSBlbGVtZW50LiBUaGlzIHByZXZlbnRzIHRvdWNoIHNjcm9sbGluZ1xuLy8gICAgb24gdGhlIHdpbmRvdy5cbi8vIDIuIFByZXZlbnQgZGVmYXVsdCBvbiBgdG91Y2htb3ZlYCBldmVudHMgaW5zaWRlIGEgc2Nyb2xsYWJsZSBlbGVtZW50IHdoZW4gdGhlIHNjcm9sbCBwb3NpdGlvbiBpcyBhdCB0aGVcbi8vICAgIHRvcCBvciBib3R0b20uIFRoaXMgYXZvaWRzIHRoZSB3aG9sZSBwYWdlIHNjcm9sbGluZyBpbnN0ZWFkLCBidXQgZG9lcyBwcmV2ZW50IG92ZXJzY3JvbGxpbmcuXG4vLyAzLiBQcmV2ZW50IGRlZmF1bHQgb24gYHRvdWNoZW5kYCBldmVudHMgb24gaW5wdXQgZWxlbWVudHMgYW5kIGhhbmRsZSBmb2N1c2luZyB0aGUgZWxlbWVudCBvdXJzZWx2ZXMuXG4vLyA0LiBXaGVuIGZvY3VzaW5nIGFuIGlucHV0LCBhcHBseSBhIHRyYW5zZm9ybSB0byB0cmljayBTYWZhcmkgaW50byB0aGlua2luZyB0aGUgaW5wdXQgaXMgYXQgdGhlIHRvcFxuLy8gICAgb2YgdGhlIHBhZ2UsIHdoaWNoIHByZXZlbnRzIGl0IGZyb20gc2Nyb2xsaW5nIHRoZSBwYWdlLiBBZnRlciB0aGUgaW5wdXQgaXMgZm9jdXNlZCwgc2Nyb2xsIHRoZSBlbGVtZW50XG4vLyAgICBpbnRvIHZpZXcgb3Vyc2VsdmVzLCB3aXRob3V0IHNjcm9sbGluZyB0aGUgd2hvbGUgcGFnZS5cbi8vIDUuIE9mZnNldCB0aGUgYm9keSBieSB0aGUgc2Nyb2xsIHBvc2l0aW9uIHVzaW5nIGEgbmVnYXRpdmUgbWFyZ2luIGFuZCBzY3JvbGwgdG8gdGhlIHRvcC4gVGhpcyBzaG91bGQgYXBwZWFyIHRoZVxuLy8gICAgc2FtZSB2aXN1YWxseSwgYnV0IG1ha2VzIHRoZSBhY3R1YWwgc2Nyb2xsIHBvc2l0aW9uIGFsd2F5cyB6ZXJvLiBUaGlzIGlzIHJlcXVpcmVkIHRvIG1ha2UgYWxsIG9mIHRoZVxuLy8gICAgYWJvdmUgd29yayBvciBTYWZhcmkgd2lsbCBzdGlsbCB0cnkgdG8gc2Nyb2xsIHRoZSBwYWdlIHdoZW4gZm9jdXNpbmcgYW4gaW5wdXQuXG4vLyA2LiBBcyBhIGxhc3QgcmVzb3J0LCBoYW5kbGUgd2luZG93IHNjcm9sbCBldmVudHMsIGFuZCBzY3JvbGwgYmFjayB0byB0aGUgdG9wLiBUaGlzIGNhbiBoYXBwZW4gd2hlbiBhdHRlbXB0aW5nXG4vLyAgICB0byBuYXZpZ2F0ZSB0byBhbiBpbnB1dCB3aXRoIHRoZSBuZXh0L3ByZXZpb3VzIGJ1dHRvbnMgdGhhdCdzIG91dHNpZGUgYSBtb2RhbC5cbmZ1bmN0aW9uIHByZXZlbnRTY3JvbGxNb2JpbGVTYWZhcmkoKSB7XG4gICAgbGV0IHNjcm9sbGFibGU7XG4gICAgbGV0IGxhc3RZID0gMDtcbiAgICBsZXQgb25Ub3VjaFN0YXJ0ID0gKGUpPT57XG4gICAgICAgIC8vIFN0b3JlIHRoZSBuZWFyZXN0IHNjcm9sbGFibGUgcGFyZW50IGVsZW1lbnQgZnJvbSB0aGUgZWxlbWVudCB0aGF0IHRoZSB1c2VyIHRvdWNoZWQuXG4gICAgICAgIHNjcm9sbGFibGUgPSBnZXRTY3JvbGxQYXJlbnQoZS50YXJnZXQpO1xuICAgICAgICBpZiAoc2Nyb2xsYWJsZSA9PT0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmIHNjcm9sbGFibGUgPT09IGRvY3VtZW50LmJvZHkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsYXN0WSA9IGUuY2hhbmdlZFRvdWNoZXNbMF0ucGFnZVk7XG4gICAgfTtcbiAgICBsZXQgb25Ub3VjaE1vdmUgPSAoZSk9PntcbiAgICAgICAgLy8gUHJldmVudCBzY3JvbGxpbmcgdGhlIHdpbmRvdy5cbiAgICAgICAgaWYgKCFzY3JvbGxhYmxlIHx8IHNjcm9sbGFibGUgPT09IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCB8fCBzY3JvbGxhYmxlID09PSBkb2N1bWVudC5ib2R5KSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gUHJldmVudCBzY3JvbGxpbmcgdXAgd2hlbiBhdCB0aGUgdG9wIGFuZCBzY3JvbGxpbmcgZG93biB3aGVuIGF0IHRoZSBib3R0b21cbiAgICAgICAgLy8gb2YgYSBuZXN0ZWQgc2Nyb2xsYWJsZSBhcmVhLCBvdGhlcndpc2UgbW9iaWxlIFNhZmFyaSB3aWxsIHN0YXJ0IHNjcm9sbGluZ1xuICAgICAgICAvLyB0aGUgd2luZG93IGluc3RlYWQuIFVuZm9ydHVuYXRlbHksIHRoaXMgZGlzYWJsZXMgYm91bmNlIHNjcm9sbGluZyB3aGVuIGF0XG4gICAgICAgIC8vIHRoZSB0b3AgYnV0IGl0J3MgdGhlIGJlc3Qgd2UgY2FuIGRvLlxuICAgICAgICBsZXQgeSA9IGUuY2hhbmdlZFRvdWNoZXNbMF0ucGFnZVk7XG4gICAgICAgIGxldCBzY3JvbGxUb3AgPSBzY3JvbGxhYmxlLnNjcm9sbFRvcDtcbiAgICAgICAgbGV0IGJvdHRvbSA9IHNjcm9sbGFibGUuc2Nyb2xsSGVpZ2h0IC0gc2Nyb2xsYWJsZS5jbGllbnRIZWlnaHQ7XG4gICAgICAgIGlmIChib3R0b20gPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2Nyb2xsVG9wIDw9IDAgJiYgeSA+IGxhc3RZIHx8IHNjcm9sbFRvcCA+PSBib3R0b20gJiYgeSA8IGxhc3RZKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdFkgPSB5O1xuICAgIH07XG4gICAgbGV0IG9uVG91Y2hFbmQgPSAoZSk9PntcbiAgICAgICAgbGV0IHRhcmdldCA9IGUudGFyZ2V0O1xuICAgICAgICAvLyBBcHBseSB0aGlzIGNoYW5nZSBpZiB3ZSdyZSBub3QgYWxyZWFkeSBmb2N1c2VkIG9uIHRoZSB0YXJnZXQgZWxlbWVudFxuICAgICAgICBpZiAoaXNJbnB1dCh0YXJnZXQpICYmIHRhcmdldCAhPT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgLy8gQXBwbHkgYSB0cmFuc2Zvcm0gdG8gdHJpY2sgU2FmYXJpIGludG8gdGhpbmtpbmcgdGhlIGlucHV0IGlzIGF0IHRoZSB0b3Agb2YgdGhlIHBhZ2VcbiAgICAgICAgICAgIC8vIHNvIGl0IGRvZXNuJ3QgdHJ5IHRvIHNjcm9sbCBpdCBpbnRvIHZpZXcuIFdoZW4gdGFwcGluZyBvbiBhbiBpbnB1dCwgdGhpcyBuZWVkcyB0b1xuICAgICAgICAgICAgLy8gYmUgZG9uZSBiZWZvcmUgdGhlIFwiZm9jdXNcIiBldmVudCwgc28gd2UgaGF2ZSB0byBmb2N1cyB0aGUgZWxlbWVudCBvdXJzZWx2ZXMuXG4gICAgICAgICAgICB0YXJnZXQuc3R5bGUudHJhbnNmb3JtID0gJ3RyYW5zbGF0ZVkoLTIwMDBweCknO1xuICAgICAgICAgICAgdGFyZ2V0LmZvY3VzKCk7XG4gICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCk9PntcbiAgICAgICAgICAgICAgICB0YXJnZXQuc3R5bGUudHJhbnNmb3JtID0gJyc7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgbGV0IG9uRm9jdXMgPSAoZSk9PntcbiAgICAgICAgbGV0IHRhcmdldCA9IGUudGFyZ2V0O1xuICAgICAgICBpZiAoaXNJbnB1dCh0YXJnZXQpKSB7XG4gICAgICAgICAgICAvLyBUcmFuc2Zvcm0gYWxzbyBuZWVkcyB0byBiZSBhcHBsaWVkIGluIHRoZSBmb2N1cyBldmVudCBpbiBjYXNlcyB3aGVyZSBmb2N1cyBtb3Zlc1xuICAgICAgICAgICAgLy8gb3RoZXIgdGhhbiB0YXBwaW5nIG9uIGFuIGlucHV0IGRpcmVjdGx5LCBlLmcuIHRoZSBuZXh0L3ByZXZpb3VzIGJ1dHRvbnMgaW4gdGhlXG4gICAgICAgICAgICAvLyBzb2Z0d2FyZSBrZXlib2FyZC4gSW4gdGhlc2UgY2FzZXMsIGl0IHNlZW1zIGFwcGx5aW5nIHRoZSB0cmFuc2Zvcm0gaW4gdGhlIGZvY3VzIGV2ZW50XG4gICAgICAgICAgICAvLyBpcyBnb29kIGVub3VnaCwgd2hlcmVhcyB3aGVuIHRhcHBpbmcgYW4gaW5wdXQsIGl0IG11c3QgYmUgZG9uZSBiZWZvcmUgdGhlIGZvY3VzIGV2ZW50LiDwn6S34oCN4pmC77iPXG4gICAgICAgICAgICB0YXJnZXQuc3R5bGUudHJhbnNmb3JtID0gJ3RyYW5zbGF0ZVkoLTIwMDBweCknO1xuICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpPT57XG4gICAgICAgICAgICAgICAgdGFyZ2V0LnN0eWxlLnRyYW5zZm9ybSA9ICcnO1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgd2lsbCBoYXZlIHByZXZlbnRlZCB0aGUgYnJvd3NlciBmcm9tIHNjcm9sbGluZyB0aGUgZm9jdXNlZCBlbGVtZW50IGludG8gdmlldyxcbiAgICAgICAgICAgICAgICAvLyBzbyB3ZSBuZWVkIHRvIGRvIHRoaXMgb3Vyc2VsdmVzIGluIGEgd2F5IHRoYXQgZG9lc24ndCBjYXVzZSB0aGUgd2hvbGUgcGFnZSB0byBzY3JvbGwuXG4gICAgICAgICAgICAgICAgaWYgKHZpc3VhbFZpZXdwb3J0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2aXN1YWxWaWV3cG9ydC5oZWlnaHQgPCB3aW5kb3cuaW5uZXJIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBrZXlib2FyZCBpcyBhbHJlYWR5IHZpc2libGUsIGRvIHRoaXMgYWZ0ZXIgb25lIGFkZGl0aW9uYWwgZnJhbWVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRvIHdhaXQgZm9yIHRoZSB0cmFuc2Zvcm0gdG8gYmUgcmVtb3ZlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKT0+e1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbEludG9WaWV3KHRhcmdldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgd2FpdCBmb3IgdGhlIHZpc3VhbCB2aWV3cG9ydCB0byByZXNpemUgYmVmb3JlIHNjcm9sbGluZyBzbyB3ZSBjYW5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1lYXN1cmUgdGhlIGNvcnJlY3QgcG9zaXRpb24gdG8gc2Nyb2xsIHRvLlxuICAgICAgICAgICAgICAgICAgICAgICAgdmlzdWFsVmlld3BvcnQuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgKCk9PnNjcm9sbEludG9WaWV3KHRhcmdldCksIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbmNlOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBsZXQgb25XaW5kb3dTY3JvbGwgPSAoKT0+e1xuICAgICAgICAvLyBMYXN0IHJlc29ydC4gSWYgdGhlIHdpbmRvdyBzY3JvbGxlZCwgc2Nyb2xsIGl0IGJhY2sgdG8gdGhlIHRvcC5cbiAgICAgICAgLy8gSXQgc2hvdWxkIGFsd2F5cyBiZSBhdCB0aGUgdG9wIGJlY2F1c2UgdGhlIGJvZHkgd2lsbCBoYXZlIGEgbmVnYXRpdmUgbWFyZ2luIChzZWUgYmVsb3cpLlxuICAgICAgICB3aW5kb3cuc2Nyb2xsVG8oMCwgMCk7XG4gICAgfTtcbiAgICAvLyBSZWNvcmQgdGhlIG9yaWdpbmFsIHNjcm9sbCBwb3NpdGlvbiBzbyB3ZSBjYW4gcmVzdG9yZSBpdC5cbiAgICAvLyBUaGVuIGFwcGx5IGEgbmVnYXRpdmUgbWFyZ2luIHRvIHRoZSBib2R5IHRvIG9mZnNldCBpdCBieSB0aGUgc2Nyb2xsIHBvc2l0aW9uLiBUaGlzIHdpbGxcbiAgICAvLyBlbmFibGUgdXMgdG8gc2Nyb2xsIHRoZSB3aW5kb3cgdG8gdGhlIHRvcCwgd2hpY2ggaXMgcmVxdWlyZWQgZm9yIHRoZSByZXN0IG9mIHRoaXMgdG8gd29yay5cbiAgICBsZXQgc2Nyb2xsWCA9IHdpbmRvdy5wYWdlWE9mZnNldDtcbiAgICBsZXQgc2Nyb2xsWSA9IHdpbmRvdy5wYWdlWU9mZnNldDtcbiAgICBsZXQgcmVzdG9yZVN0eWxlcyA9IGNoYWluJDEoc2V0U3R5bGUoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCAncGFkZGluZ1JpZ2h0JywgYCR7d2luZG93LmlubmVyV2lkdGggLSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGh9cHhgKSk7XG4gICAgLy8gU2Nyb2xsIHRvIHRoZSB0b3AuIFRoZSBuZWdhdGl2ZSBtYXJnaW4gb24gdGhlIGJvZHkgd2lsbCBtYWtlIHRoaXMgYXBwZWFyIHRoZSBzYW1lLlxuICAgIHdpbmRvdy5zY3JvbGxUbygwLCAwKTtcbiAgICBsZXQgcmVtb3ZlRXZlbnRzID0gY2hhaW4kMShhZGRFdmVudChkb2N1bWVudCwgJ3RvdWNoc3RhcnQnLCBvblRvdWNoU3RhcnQsIHtcbiAgICAgICAgcGFzc2l2ZTogZmFsc2UsXG4gICAgICAgIGNhcHR1cmU6IHRydWVcbiAgICB9KSwgYWRkRXZlbnQoZG9jdW1lbnQsICd0b3VjaG1vdmUnLCBvblRvdWNoTW92ZSwge1xuICAgICAgICBwYXNzaXZlOiBmYWxzZSxcbiAgICAgICAgY2FwdHVyZTogdHJ1ZVxuICAgIH0pLCBhZGRFdmVudChkb2N1bWVudCwgJ3RvdWNoZW5kJywgb25Ub3VjaEVuZCwge1xuICAgICAgICBwYXNzaXZlOiBmYWxzZSxcbiAgICAgICAgY2FwdHVyZTogdHJ1ZVxuICAgIH0pLCBhZGRFdmVudChkb2N1bWVudCwgJ2ZvY3VzJywgb25Gb2N1cywgdHJ1ZSksIGFkZEV2ZW50KHdpbmRvdywgJ3Njcm9sbCcsIG9uV2luZG93U2Nyb2xsKSk7XG4gICAgcmV0dXJuICgpPT57XG4gICAgICAgIC8vIFJlc3RvcmUgc3R5bGVzIGFuZCBzY3JvbGwgdGhlIHBhZ2UgYmFjayB0byB3aGVyZSBpdCB3YXMuXG4gICAgICAgIHJlc3RvcmVTdHlsZXMoKTtcbiAgICAgICAgcmVtb3ZlRXZlbnRzKCk7XG4gICAgICAgIHdpbmRvdy5zY3JvbGxUbyhzY3JvbGxYLCBzY3JvbGxZKTtcbiAgICB9O1xufVxuLy8gU2V0cyBhIENTUyBwcm9wZXJ0eSBvbiBhbiBlbGVtZW50LCBhbmQgcmV0dXJucyBhIGZ1bmN0aW9uIHRvIHJldmVydCBpdCB0byB0aGUgcHJldmlvdXMgdmFsdWUuXG5mdW5jdGlvbiBzZXRTdHlsZShlbGVtZW50LCBzdHlsZSwgdmFsdWUpIHtcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L1R5cGVTY3JpcHQvaXNzdWVzLzE3ODI3I2lzc3VlY29tbWVudC0zOTE2NjMzMTBcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgbGV0IGN1ciA9IGVsZW1lbnQuc3R5bGVbc3R5bGVdO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBlbGVtZW50LnN0eWxlW3N0eWxlXSA9IHZhbHVlO1xuICAgIHJldHVybiAoKT0+e1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGVsZW1lbnQuc3R5bGVbc3R5bGVdID0gY3VyO1xuICAgIH07XG59XG4vLyBBZGRzIGFuIGV2ZW50IGxpc3RlbmVyIHRvIGFuIGVsZW1lbnQsIGFuZCByZXR1cm5zIGEgZnVuY3Rpb24gdG8gcmVtb3ZlIGl0LlxuZnVuY3Rpb24gYWRkRXZlbnQodGFyZ2V0LCBldmVudCwgaGFuZGxlciwgb3B0aW9ucykge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlciwgb3B0aW9ucyk7XG4gICAgcmV0dXJuICgpPT57XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpO1xuICAgIH07XG59XG5mdW5jdGlvbiBzY3JvbGxJbnRvVmlldyh0YXJnZXQpIHtcbiAgICBsZXQgcm9vdCA9IGRvY3VtZW50LnNjcm9sbGluZ0VsZW1lbnQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgIHdoaWxlKHRhcmdldCAmJiB0YXJnZXQgIT09IHJvb3Qpe1xuICAgICAgICAvLyBGaW5kIHRoZSBwYXJlbnQgc2Nyb2xsYWJsZSBlbGVtZW50IGFuZCBhZGp1c3QgdGhlIHNjcm9sbCBwb3NpdGlvbiBpZiB0aGUgdGFyZ2V0IGlzIG5vdCBhbHJlYWR5IGluIHZpZXcuXG4gICAgICAgIGxldCBzY3JvbGxhYmxlID0gZ2V0U2Nyb2xsUGFyZW50KHRhcmdldCk7XG4gICAgICAgIGlmIChzY3JvbGxhYmxlICE9PSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgc2Nyb2xsYWJsZSAhPT0gZG9jdW1lbnQuYm9keSAmJiBzY3JvbGxhYmxlICE9PSB0YXJnZXQpIHtcbiAgICAgICAgICAgIGxldCBzY3JvbGxhYmxlVG9wID0gc2Nyb2xsYWJsZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3A7XG4gICAgICAgICAgICBsZXQgdGFyZ2V0VG9wID0gdGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcDtcbiAgICAgICAgICAgIGxldCB0YXJnZXRCb3R0b20gPSB0YXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuYm90dG9tO1xuICAgICAgICAgICAgLy8gQnVmZmVyIGlzIG5lZWRlZCBmb3Igc29tZSBlZGdlIGNhc2VzXG4gICAgICAgICAgICBjb25zdCBrZXlib2FyZEhlaWdodCA9IHNjcm9sbGFibGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuYm90dG9tICsgS0VZQk9BUkRfQlVGRkVSO1xuICAgICAgICAgICAgaWYgKHRhcmdldEJvdHRvbSA+IGtleWJvYXJkSGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgc2Nyb2xsYWJsZS5zY3JvbGxUb3AgKz0gdGFyZ2V0VG9wIC0gc2Nyb2xsYWJsZVRvcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHRhcmdldCA9IHNjcm9sbGFibGUucGFyZW50RWxlbWVudDtcbiAgICB9XG59XG5mdW5jdGlvbiBpc0lucHV0KHRhcmdldCkge1xuICAgIHJldHVybiB0YXJnZXQgaW5zdGFuY2VvZiBIVE1MSW5wdXRFbGVtZW50ICYmICFub25UZXh0SW5wdXRUeXBlcy5oYXModGFyZ2V0LnR5cGUpIHx8IHRhcmdldCBpbnN0YW5jZW9mIEhUTUxUZXh0QXJlYUVsZW1lbnQgfHwgdGFyZ2V0IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgJiYgdGFyZ2V0LmlzQ29udGVudEVkaXRhYmxlO1xufVxuXG4vLyBUaGlzIGNvZGUgY29tZXMgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vcmFkaXgtdWkvcHJpbWl0aXZlcy90cmVlL21haW4vcGFja2FnZXMvcmVhY3QvY29tcG9zZS1yZWZzXG4vKipcbiAqIFNldCBhIGdpdmVuIHJlZiB0byBhIGdpdmVuIHZhbHVlXG4gKiBUaGlzIHV0aWxpdHkgdGFrZXMgY2FyZSBvZiBkaWZmZXJlbnQgdHlwZXMgb2YgcmVmczogY2FsbGJhY2sgcmVmcyBhbmQgUmVmT2JqZWN0KHMpXG4gKi8gZnVuY3Rpb24gc2V0UmVmKHJlZiwgdmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHJlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZWYodmFsdWUpO1xuICAgIH0gZWxzZSBpZiAocmVmICE9PSBudWxsICYmIHJlZiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJlZi5jdXJyZW50ID0gdmFsdWU7XG4gICAgfVxufVxuLyoqXG4gKiBBIHV0aWxpdHkgdG8gY29tcG9zZSBtdWx0aXBsZSByZWZzIHRvZ2V0aGVyXG4gKiBBY2NlcHRzIGNhbGxiYWNrIHJlZnMgYW5kIFJlZk9iamVjdChzKVxuICovIGZ1bmN0aW9uIGNvbXBvc2VSZWZzKC4uLnJlZnMpIHtcbiAgICByZXR1cm4gKG5vZGUpPT5yZWZzLmZvckVhY2goKHJlZik9PnNldFJlZihyZWYsIG5vZGUpKTtcbn1cbi8qKlxuICogQSBjdXN0b20gaG9vayB0aGF0IGNvbXBvc2VzIG11bHRpcGxlIHJlZnNcbiAqIEFjY2VwdHMgY2FsbGJhY2sgcmVmcyBhbmQgUmVmT2JqZWN0KHMpXG4gKi8gZnVuY3Rpb24gdXNlQ29tcG9zZWRSZWZzKC4uLnJlZnMpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gICAgcmV0dXJuIFJlYWN0LnVzZUNhbGxiYWNrKGNvbXBvc2VSZWZzKC4uLnJlZnMpLCByZWZzKTtcbn1cblxuY29uc3QgY2FjaGUgPSBuZXcgV2Vha01hcCgpO1xuZnVuY3Rpb24gc2V0KGVsLCBzdHlsZXMsIGlnbm9yZUNhY2hlID0gZmFsc2UpIHtcbiAgICBpZiAoIWVsIHx8ICEoZWwgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkpIHJldHVybjtcbiAgICBsZXQgb3JpZ2luYWxTdHlsZXMgPSB7fTtcbiAgICBPYmplY3QuZW50cmllcyhzdHlsZXMpLmZvckVhY2goKFtrZXksIHZhbHVlXSk9PntcbiAgICAgICAgaWYgKGtleS5zdGFydHNXaXRoKCctLScpKSB7XG4gICAgICAgICAgICBlbC5zdHlsZS5zZXRQcm9wZXJ0eShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBvcmlnaW5hbFN0eWxlc1trZXldID0gZWwuc3R5bGVba2V5XTtcbiAgICAgICAgZWwuc3R5bGVba2V5XSA9IHZhbHVlO1xuICAgIH0pO1xuICAgIGlmIChpZ25vcmVDYWNoZSkgcmV0dXJuO1xuICAgIGNhY2hlLnNldChlbCwgb3JpZ2luYWxTdHlsZXMpO1xufVxuZnVuY3Rpb24gcmVzZXQoZWwsIHByb3ApIHtcbiAgICBpZiAoIWVsIHx8ICEoZWwgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkpIHJldHVybjtcbiAgICBsZXQgb3JpZ2luYWxTdHlsZXMgPSBjYWNoZS5nZXQoZWwpO1xuICAgIGlmICghb3JpZ2luYWxTdHlsZXMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB7XG4gICAgICAgIGVsLnN0eWxlW3Byb3BdID0gb3JpZ2luYWxTdHlsZXNbcHJvcF07XG4gICAgfVxufVxuY29uc3QgaXNWZXJ0aWNhbCA9IChkaXJlY3Rpb24pPT57XG4gICAgc3dpdGNoKGRpcmVjdGlvbil7XG4gICAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBkaXJlY3Rpb247XG4gICAgfVxufTtcbmZ1bmN0aW9uIGdldFRyYW5zbGF0ZShlbGVtZW50LCBkaXJlY3Rpb24pIHtcbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG4gICAgY29uc3QgdHJhbnNmb3JtID0gLy8gQHRzLWlnbm9yZVxuICAgIHN0eWxlLnRyYW5zZm9ybSB8fCBzdHlsZS53ZWJraXRUcmFuc2Zvcm0gfHwgc3R5bGUubW96VHJhbnNmb3JtO1xuICAgIGxldCBtYXQgPSB0cmFuc2Zvcm0ubWF0Y2goL15tYXRyaXgzZFxcKCguKylcXCkkLyk7XG4gICAgaWYgKG1hdCkge1xuICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvdHJhbnNmb3JtLWZ1bmN0aW9uL21hdHJpeDNkXG4gICAgICAgIHJldHVybiBwYXJzZUZsb2F0KG1hdFsxXS5zcGxpdCgnLCAnKVtpc1ZlcnRpY2FsKGRpcmVjdGlvbikgPyAxMyA6IDEyXSk7XG4gICAgfVxuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy90cmFuc2Zvcm0tZnVuY3Rpb24vbWF0cml4XG4gICAgbWF0ID0gdHJhbnNmb3JtLm1hdGNoKC9ebWF0cml4XFwoKC4rKVxcKSQvKTtcbiAgICByZXR1cm4gbWF0ID8gcGFyc2VGbG9hdChtYXRbMV0uc3BsaXQoJywgJylbaXNWZXJ0aWNhbChkaXJlY3Rpb24pID8gNSA6IDRdKSA6IG51bGw7XG59XG5mdW5jdGlvbiBkYW1wZW5WYWx1ZSh2KSB7XG4gICAgcmV0dXJuIDggKiAoTWF0aC5sb2codiArIDEpIC0gMik7XG59XG5mdW5jdGlvbiBhc3NpZ25TdHlsZShlbGVtZW50LCBzdHlsZSkge1xuICAgIGlmICghZWxlbWVudCkgcmV0dXJuICgpPT57fTtcbiAgICBjb25zdCBwcmV2U3R5bGUgPSBlbGVtZW50LnN0eWxlLmNzc1RleHQ7XG4gICAgT2JqZWN0LmFzc2lnbihlbGVtZW50LnN0eWxlLCBzdHlsZSk7XG4gICAgcmV0dXJuICgpPT57XG4gICAgICAgIGVsZW1lbnQuc3R5bGUuY3NzVGV4dCA9IHByZXZTdHlsZTtcbiAgICB9O1xufVxuLyoqXG4gKiBSZWNlaXZlcyBmdW5jdGlvbnMgYXMgYXJndW1lbnRzIGFuZCByZXR1cm5zIGEgbmV3IGZ1bmN0aW9uIHRoYXQgY2FsbHMgYWxsLlxuICovIGZ1bmN0aW9uIGNoYWluKC4uLmZucykge1xuICAgIHJldHVybiAoLi4uYXJncyk9PntcbiAgICAgICAgZm9yIChjb25zdCBmbiBvZiBmbnMpe1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICBmbiguLi5hcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG59XG5cbmNvbnN0IFRSQU5TSVRJT05TID0ge1xuICAgIERVUkFUSU9OOiAwLjUsXG4gICAgRUFTRTogW1xuICAgICAgICAwLjMyLFxuICAgICAgICAwLjcyLFxuICAgICAgICAwLFxuICAgICAgICAxXG4gICAgXVxufTtcbmNvbnN0IFZFTE9DSVRZX1RIUkVTSE9MRCA9IDAuNDtcbmNvbnN0IENMT1NFX1RIUkVTSE9MRCA9IDAuMjU7XG5jb25zdCBTQ1JPTExfTE9DS19USU1FT1VUID0gMTAwO1xuY29uc3QgQk9SREVSX1JBRElVUyA9IDg7XG5jb25zdCBORVNURURfRElTUExBQ0VNRU5UID0gMTY7XG5jb25zdCBXSU5ET1dfVE9QX09GRlNFVCA9IDI2O1xuY29uc3QgRFJBR19DTEFTUyA9ICd2YXVsLWRyYWdnaW5nJztcblxuLy8gVGhpcyBjb2RlIGNvbWVzIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL3JhZGl4LXVpL3ByaW1pdGl2ZXMvYmxvYi9tYWluL3BhY2thZ2VzL3JlYWN0L3VzZS1jb250cm9sbGFibGUtc3RhdGUvc3JjL3VzZUNvbnRyb2xsYWJsZVN0YXRlLnRzeFxuZnVuY3Rpb24gdXNlQ2FsbGJhY2tSZWYoY2FsbGJhY2spIHtcbiAgICBjb25zdCBjYWxsYmFja1JlZiA9IFJlYWN0X19kZWZhdWx0LnVzZVJlZihjYWxsYmFjayk7XG4gICAgUmVhY3RfX2RlZmF1bHQudXNlRWZmZWN0KCgpPT57XG4gICAgICAgIGNhbGxiYWNrUmVmLmN1cnJlbnQgPSBjYWxsYmFjaztcbiAgICB9KTtcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzE5MjQwXG4gICAgcmV0dXJuIFJlYWN0X19kZWZhdWx0LnVzZU1lbW8oKCk9PiguLi5hcmdzKT0+Y2FsbGJhY2tSZWYuY3VycmVudCA9PSBudWxsID8gdm9pZCAwIDogY2FsbGJhY2tSZWYuY3VycmVudC5jYWxsKGNhbGxiYWNrUmVmLCAuLi5hcmdzKSwgW10pO1xufVxuZnVuY3Rpb24gdXNlVW5jb250cm9sbGVkU3RhdGUoeyBkZWZhdWx0UHJvcCwgb25DaGFuZ2UgfSkge1xuICAgIGNvbnN0IHVuY29udHJvbGxlZFN0YXRlID0gUmVhY3RfX2RlZmF1bHQudXNlU3RhdGUoZGVmYXVsdFByb3ApO1xuICAgIGNvbnN0IFt2YWx1ZV0gPSB1bmNvbnRyb2xsZWRTdGF0ZTtcbiAgICBjb25zdCBwcmV2VmFsdWVSZWYgPSBSZWFjdF9fZGVmYXVsdC51c2VSZWYodmFsdWUpO1xuICAgIGNvbnN0IGhhbmRsZUNoYW5nZSA9IHVzZUNhbGxiYWNrUmVmKG9uQ2hhbmdlKTtcbiAgICBSZWFjdF9fZGVmYXVsdC51c2VFZmZlY3QoKCk9PntcbiAgICAgICAgaWYgKHByZXZWYWx1ZVJlZi5jdXJyZW50ICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAgaGFuZGxlQ2hhbmdlKHZhbHVlKTtcbiAgICAgICAgICAgIHByZXZWYWx1ZVJlZi5jdXJyZW50ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9LCBbXG4gICAgICAgIHZhbHVlLFxuICAgICAgICBwcmV2VmFsdWVSZWYsXG4gICAgICAgIGhhbmRsZUNoYW5nZVxuICAgIF0pO1xuICAgIHJldHVybiB1bmNvbnRyb2xsZWRTdGF0ZTtcbn1cbmZ1bmN0aW9uIHVzZUNvbnRyb2xsYWJsZVN0YXRlKHsgcHJvcCwgZGVmYXVsdFByb3AsIG9uQ2hhbmdlID0gKCk9Pnt9IH0pIHtcbiAgICBjb25zdCBbdW5jb250cm9sbGVkUHJvcCwgc2V0VW5jb250cm9sbGVkUHJvcF0gPSB1c2VVbmNvbnRyb2xsZWRTdGF0ZSh7XG4gICAgICAgIGRlZmF1bHRQcm9wLFxuICAgICAgICBvbkNoYW5nZVxuICAgIH0pO1xuICAgIGNvbnN0IGlzQ29udHJvbGxlZCA9IHByb3AgIT09IHVuZGVmaW5lZDtcbiAgICBjb25zdCB2YWx1ZSA9IGlzQ29udHJvbGxlZCA/IHByb3AgOiB1bmNvbnRyb2xsZWRQcm9wO1xuICAgIGNvbnN0IGhhbmRsZUNoYW5nZSA9IHVzZUNhbGxiYWNrUmVmKG9uQ2hhbmdlKTtcbiAgICBjb25zdCBzZXRWYWx1ZSA9IFJlYWN0X19kZWZhdWx0LnVzZUNhbGxiYWNrKChuZXh0VmFsdWUpPT57XG4gICAgICAgIGlmIChpc0NvbnRyb2xsZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHNldHRlciA9IG5leHRWYWx1ZTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdHlwZW9mIG5leHRWYWx1ZSA9PT0gJ2Z1bmN0aW9uJyA/IHNldHRlcihwcm9wKSA6IG5leHRWYWx1ZTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gcHJvcCkgaGFuZGxlQ2hhbmdlKHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNldFVuY29udHJvbGxlZFByb3AobmV4dFZhbHVlKTtcbiAgICAgICAgfVxuICAgIH0sIFtcbiAgICAgICAgaXNDb250cm9sbGVkLFxuICAgICAgICBwcm9wLFxuICAgICAgICBzZXRVbmNvbnRyb2xsZWRQcm9wLFxuICAgICAgICBoYW5kbGVDaGFuZ2VcbiAgICBdKTtcbiAgICByZXR1cm4gW1xuICAgICAgICB2YWx1ZSxcbiAgICAgICAgc2V0VmFsdWVcbiAgICBdO1xufVxuXG5mdW5jdGlvbiB1c2VTbmFwUG9pbnRzKHsgYWN0aXZlU25hcFBvaW50UHJvcCwgc2V0QWN0aXZlU25hcFBvaW50UHJvcCwgc25hcFBvaW50cywgZHJhd2VyUmVmLCBvdmVybGF5UmVmLCBmYWRlRnJvbUluZGV4LCBvblNuYXBQb2ludENoYW5nZSwgZGlyZWN0aW9uID0gJ2JvdHRvbScsIGNvbnRhaW5lciwgc25hcFRvU2VxdWVudGlhbFBvaW50IH0pIHtcbiAgICBjb25zdCBbYWN0aXZlU25hcFBvaW50LCBzZXRBY3RpdmVTbmFwUG9pbnRdID0gdXNlQ29udHJvbGxhYmxlU3RhdGUoe1xuICAgICAgICBwcm9wOiBhY3RpdmVTbmFwUG9pbnRQcm9wLFxuICAgICAgICBkZWZhdWx0UHJvcDogc25hcFBvaW50cyA9PSBudWxsID8gdm9pZCAwIDogc25hcFBvaW50c1swXSxcbiAgICAgICAgb25DaGFuZ2U6IHNldEFjdGl2ZVNuYXBQb2ludFByb3BcbiAgICB9KTtcbiAgICBjb25zdCBbd2luZG93RGltZW5zaW9ucywgc2V0V2luZG93RGltZW5zaW9uc10gPSBSZWFjdF9fZGVmYXVsdC51c2VTdGF0ZSh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHtcbiAgICAgICAgaW5uZXJXaWR0aDogd2luZG93LmlubmVyV2lkdGgsXG4gICAgICAgIGlubmVySGVpZ2h0OiB3aW5kb3cuaW5uZXJIZWlnaHRcbiAgICB9IDogdW5kZWZpbmVkKTtcbiAgICBSZWFjdF9fZGVmYXVsdC51c2VFZmZlY3QoKCk9PntcbiAgICAgICAgZnVuY3Rpb24gb25SZXNpemUoKSB7XG4gICAgICAgICAgICBzZXRXaW5kb3dEaW1lbnNpb25zKHtcbiAgICAgICAgICAgICAgICBpbm5lcldpZHRoOiB3aW5kb3cuaW5uZXJXaWR0aCxcbiAgICAgICAgICAgICAgICBpbm5lckhlaWdodDogd2luZG93LmlubmVySGVpZ2h0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgb25SZXNpemUpO1xuICAgICAgICByZXR1cm4gKCk9PndpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCBvblJlc2l6ZSk7XG4gICAgfSwgW10pO1xuICAgIGNvbnN0IGlzTGFzdFNuYXBQb2ludCA9IFJlYWN0X19kZWZhdWx0LnVzZU1lbW8oKCk9PmFjdGl2ZVNuYXBQb2ludCA9PT0gKHNuYXBQb2ludHMgPT0gbnVsbCA/IHZvaWQgMCA6IHNuYXBQb2ludHNbc25hcFBvaW50cy5sZW5ndGggLSAxXSkgfHwgbnVsbCwgW1xuICAgICAgICBzbmFwUG9pbnRzLFxuICAgICAgICBhY3RpdmVTbmFwUG9pbnRcbiAgICBdKTtcbiAgICBjb25zdCBhY3RpdmVTbmFwUG9pbnRJbmRleCA9IFJlYWN0X19kZWZhdWx0LnVzZU1lbW8oKCk9PntcbiAgICAgICAgdmFyIF9zbmFwUG9pbnRzX2ZpbmRJbmRleDtcbiAgICAgICAgcmV0dXJuIChfc25hcFBvaW50c19maW5kSW5kZXggPSBzbmFwUG9pbnRzID09IG51bGwgPyB2b2lkIDAgOiBzbmFwUG9pbnRzLmZpbmRJbmRleCgoc25hcFBvaW50KT0+c25hcFBvaW50ID09PSBhY3RpdmVTbmFwUG9pbnQpKSAhPSBudWxsID8gX3NuYXBQb2ludHNfZmluZEluZGV4IDogbnVsbDtcbiAgICB9LCBbXG4gICAgICAgIHNuYXBQb2ludHMsXG4gICAgICAgIGFjdGl2ZVNuYXBQb2ludFxuICAgIF0pO1xuICAgIGNvbnN0IHNob3VsZEZhZGUgPSBzbmFwUG9pbnRzICYmIHNuYXBQb2ludHMubGVuZ3RoID4gMCAmJiAoZmFkZUZyb21JbmRleCB8fCBmYWRlRnJvbUluZGV4ID09PSAwKSAmJiAhTnVtYmVyLmlzTmFOKGZhZGVGcm9tSW5kZXgpICYmIHNuYXBQb2ludHNbZmFkZUZyb21JbmRleF0gPT09IGFjdGl2ZVNuYXBQb2ludCB8fCAhc25hcFBvaW50cztcbiAgICBjb25zdCBzbmFwUG9pbnRzT2Zmc2V0ID0gUmVhY3RfX2RlZmF1bHQudXNlTWVtbygoKT0+e1xuICAgICAgICBjb25zdCBjb250YWluZXJTaXplID0gY29udGFpbmVyID8ge1xuICAgICAgICAgICAgd2lkdGg6IGNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodFxuICAgICAgICB9IDogdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB7XG4gICAgICAgICAgICB3aWR0aDogd2luZG93LmlubmVyV2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IHdpbmRvdy5pbm5lckhlaWdodFxuICAgICAgICB9IDoge1xuICAgICAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgICAgICBoZWlnaHQ6IDBcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIF9zbmFwUG9pbnRzX21hcDtcbiAgICAgICAgcmV0dXJuIChfc25hcFBvaW50c19tYXAgPSBzbmFwUG9pbnRzID09IG51bGwgPyB2b2lkIDAgOiBzbmFwUG9pbnRzLm1hcCgoc25hcFBvaW50KT0+e1xuICAgICAgICAgICAgY29uc3QgaXNQeCA9IHR5cGVvZiBzbmFwUG9pbnQgPT09ICdzdHJpbmcnO1xuICAgICAgICAgICAgbGV0IHNuYXBQb2ludEFzTnVtYmVyID0gMDtcbiAgICAgICAgICAgIGlmIChpc1B4KSB7XG4gICAgICAgICAgICAgICAgc25hcFBvaW50QXNOdW1iZXIgPSBwYXJzZUludChzbmFwUG9pbnQsIDEwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1ZlcnRpY2FsKGRpcmVjdGlvbikpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBoZWlnaHQgPSBpc1B4ID8gc25hcFBvaW50QXNOdW1iZXIgOiB3aW5kb3dEaW1lbnNpb25zID8gc25hcFBvaW50ICogY29udGFpbmVyU2l6ZS5oZWlnaHQgOiAwO1xuICAgICAgICAgICAgICAgIGlmICh3aW5kb3dEaW1lbnNpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkaXJlY3Rpb24gPT09ICdib3R0b20nID8gY29udGFpbmVyU2l6ZS5oZWlnaHQgLSBoZWlnaHQgOiAtY29udGFpbmVyU2l6ZS5oZWlnaHQgKyBoZWlnaHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBoZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB3aWR0aCA9IGlzUHggPyBzbmFwUG9pbnRBc051bWJlciA6IHdpbmRvd0RpbWVuc2lvbnMgPyBzbmFwUG9pbnQgKiBjb250YWluZXJTaXplLndpZHRoIDogMDtcbiAgICAgICAgICAgIGlmICh3aW5kb3dEaW1lbnNpb25zKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRpcmVjdGlvbiA9PT0gJ3JpZ2h0JyA/IGNvbnRhaW5lclNpemUud2lkdGggLSB3aWR0aCA6IC1jb250YWluZXJTaXplLndpZHRoICsgd2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gd2lkdGg7XG4gICAgICAgIH0pKSAhPSBudWxsID8gX3NuYXBQb2ludHNfbWFwIDogW107XG4gICAgfSwgW1xuICAgICAgICBzbmFwUG9pbnRzLFxuICAgICAgICB3aW5kb3dEaW1lbnNpb25zLFxuICAgICAgICBjb250YWluZXJcbiAgICBdKTtcbiAgICBjb25zdCBhY3RpdmVTbmFwUG9pbnRPZmZzZXQgPSBSZWFjdF9fZGVmYXVsdC51c2VNZW1vKCgpPT5hY3RpdmVTbmFwUG9pbnRJbmRleCAhPT0gbnVsbCA/IHNuYXBQb2ludHNPZmZzZXQgPT0gbnVsbCA/IHZvaWQgMCA6IHNuYXBQb2ludHNPZmZzZXRbYWN0aXZlU25hcFBvaW50SW5kZXhdIDogbnVsbCwgW1xuICAgICAgICBzbmFwUG9pbnRzT2Zmc2V0LFxuICAgICAgICBhY3RpdmVTbmFwUG9pbnRJbmRleFxuICAgIF0pO1xuICAgIGNvbnN0IHNuYXBUb1BvaW50ID0gUmVhY3RfX2RlZmF1bHQudXNlQ2FsbGJhY2soKGRpbWVuc2lvbik9PntcbiAgICAgICAgdmFyIF9zbmFwUG9pbnRzT2Zmc2V0X2ZpbmRJbmRleDtcbiAgICAgICAgY29uc3QgbmV3U25hcFBvaW50SW5kZXggPSAoX3NuYXBQb2ludHNPZmZzZXRfZmluZEluZGV4ID0gc25hcFBvaW50c09mZnNldCA9PSBudWxsID8gdm9pZCAwIDogc25hcFBvaW50c09mZnNldC5maW5kSW5kZXgoKHNuYXBQb2ludERpbSk9PnNuYXBQb2ludERpbSA9PT0gZGltZW5zaW9uKSkgIT0gbnVsbCA/IF9zbmFwUG9pbnRzT2Zmc2V0X2ZpbmRJbmRleCA6IG51bGw7XG4gICAgICAgIG9uU25hcFBvaW50Q2hhbmdlKG5ld1NuYXBQb2ludEluZGV4KTtcbiAgICAgICAgc2V0KGRyYXdlclJlZi5jdXJyZW50LCB7XG4gICAgICAgICAgICB0cmFuc2l0aW9uOiBgdHJhbnNmb3JtICR7VFJBTlNJVElPTlMuRFVSQVRJT059cyBjdWJpYy1iZXppZXIoJHtUUkFOU0lUSU9OUy5FQVNFLmpvaW4oJywnKX0pYCxcbiAgICAgICAgICAgIHRyYW5zZm9ybTogaXNWZXJ0aWNhbChkaXJlY3Rpb24pID8gYHRyYW5zbGF0ZTNkKDAsICR7ZGltZW5zaW9ufXB4LCAwKWAgOiBgdHJhbnNsYXRlM2QoJHtkaW1lbnNpb259cHgsIDAsIDApYFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHNuYXBQb2ludHNPZmZzZXQgJiYgbmV3U25hcFBvaW50SW5kZXggIT09IHNuYXBQb2ludHNPZmZzZXQubGVuZ3RoIC0gMSAmJiBmYWRlRnJvbUluZGV4ICE9PSB1bmRlZmluZWQgJiYgbmV3U25hcFBvaW50SW5kZXggIT09IGZhZGVGcm9tSW5kZXggJiYgbmV3U25hcFBvaW50SW5kZXggPCBmYWRlRnJvbUluZGV4KSB7XG4gICAgICAgICAgICBzZXQob3ZlcmxheVJlZi5jdXJyZW50LCB7XG4gICAgICAgICAgICAgICAgdHJhbnNpdGlvbjogYG9wYWNpdHkgJHtUUkFOU0lUSU9OUy5EVVJBVElPTn1zIGN1YmljLWJlemllcigke1RSQU5TSVRJT05TLkVBU0Uuam9pbignLCcpfSlgLFxuICAgICAgICAgICAgICAgIG9wYWNpdHk6ICcwJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZXQob3ZlcmxheVJlZi5jdXJyZW50LCB7XG4gICAgICAgICAgICAgICAgdHJhbnNpdGlvbjogYG9wYWNpdHkgJHtUUkFOU0lUSU9OUy5EVVJBVElPTn1zIGN1YmljLWJlemllcigke1RSQU5TSVRJT05TLkVBU0Uuam9pbignLCcpfSlgLFxuICAgICAgICAgICAgICAgIG9wYWNpdHk6ICcxJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0QWN0aXZlU25hcFBvaW50KHNuYXBQb2ludHMgPT0gbnVsbCA/IHZvaWQgMCA6IHNuYXBQb2ludHNbTWF0aC5tYXgobmV3U25hcFBvaW50SW5kZXgsIDApXSk7XG4gICAgfSwgW1xuICAgICAgICBkcmF3ZXJSZWYuY3VycmVudCxcbiAgICAgICAgc25hcFBvaW50cyxcbiAgICAgICAgc25hcFBvaW50c09mZnNldCxcbiAgICAgICAgZmFkZUZyb21JbmRleCxcbiAgICAgICAgb3ZlcmxheVJlZixcbiAgICAgICAgc2V0QWN0aXZlU25hcFBvaW50XG4gICAgXSk7XG4gICAgUmVhY3RfX2RlZmF1bHQudXNlRWZmZWN0KCgpPT57XG4gICAgICAgIGlmIChhY3RpdmVTbmFwUG9pbnQgfHwgYWN0aXZlU25hcFBvaW50UHJvcCkge1xuICAgICAgICAgICAgdmFyIF9zbmFwUG9pbnRzX2ZpbmRJbmRleDtcbiAgICAgICAgICAgIGNvbnN0IG5ld0luZGV4ID0gKF9zbmFwUG9pbnRzX2ZpbmRJbmRleCA9IHNuYXBQb2ludHMgPT0gbnVsbCA/IHZvaWQgMCA6IHNuYXBQb2ludHMuZmluZEluZGV4KChzbmFwUG9pbnQpPT5zbmFwUG9pbnQgPT09IGFjdGl2ZVNuYXBQb2ludFByb3AgfHwgc25hcFBvaW50ID09PSBhY3RpdmVTbmFwUG9pbnQpKSAhPSBudWxsID8gX3NuYXBQb2ludHNfZmluZEluZGV4IDogLTE7XG4gICAgICAgICAgICBpZiAoc25hcFBvaW50c09mZnNldCAmJiBuZXdJbmRleCAhPT0gLTEgJiYgdHlwZW9mIHNuYXBQb2ludHNPZmZzZXRbbmV3SW5kZXhdID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIHNuYXBUb1BvaW50KHNuYXBQb2ludHNPZmZzZXRbbmV3SW5kZXhdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIFtcbiAgICAgICAgYWN0aXZlU25hcFBvaW50LFxuICAgICAgICBhY3RpdmVTbmFwUG9pbnRQcm9wLFxuICAgICAgICBzbmFwUG9pbnRzLFxuICAgICAgICBzbmFwUG9pbnRzT2Zmc2V0LFxuICAgICAgICBzbmFwVG9Qb2ludFxuICAgIF0pO1xuICAgIGZ1bmN0aW9uIG9uUmVsZWFzZSh7IGRyYWdnZWREaXN0YW5jZSwgY2xvc2VEcmF3ZXIsIHZlbG9jaXR5LCBkaXNtaXNzaWJsZSB9KSB7XG4gICAgICAgIGlmIChmYWRlRnJvbUluZGV4ID09PSB1bmRlZmluZWQpIHJldHVybjtcbiAgICAgICAgY29uc3QgY3VycmVudFBvc2l0aW9uID0gZGlyZWN0aW9uID09PSAnYm90dG9tJyB8fCBkaXJlY3Rpb24gPT09ICdyaWdodCcgPyAoYWN0aXZlU25hcFBvaW50T2Zmc2V0ICE9IG51bGwgPyBhY3RpdmVTbmFwUG9pbnRPZmZzZXQgOiAwKSAtIGRyYWdnZWREaXN0YW5jZSA6IChhY3RpdmVTbmFwUG9pbnRPZmZzZXQgIT0gbnVsbCA/IGFjdGl2ZVNuYXBQb2ludE9mZnNldCA6IDApICsgZHJhZ2dlZERpc3RhbmNlO1xuICAgICAgICBjb25zdCBpc092ZXJsYXlTbmFwUG9pbnQgPSBhY3RpdmVTbmFwUG9pbnRJbmRleCA9PT0gZmFkZUZyb21JbmRleCAtIDE7XG4gICAgICAgIGNvbnN0IGlzRmlyc3QgPSBhY3RpdmVTbmFwUG9pbnRJbmRleCA9PT0gMDtcbiAgICAgICAgY29uc3QgaGFzRHJhZ2dlZFVwID0gZHJhZ2dlZERpc3RhbmNlID4gMDtcbiAgICAgICAgaWYgKGlzT3ZlcmxheVNuYXBQb2ludCkge1xuICAgICAgICAgICAgc2V0KG92ZXJsYXlSZWYuY3VycmVudCwge1xuICAgICAgICAgICAgICAgIHRyYW5zaXRpb246IGBvcGFjaXR5ICR7VFJBTlNJVElPTlMuRFVSQVRJT059cyBjdWJpYy1iZXppZXIoJHtUUkFOU0lUSU9OUy5FQVNFLmpvaW4oJywnKX0pYFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzbmFwVG9TZXF1ZW50aWFsUG9pbnQgJiYgdmVsb2NpdHkgPiAyICYmICFoYXNEcmFnZ2VkVXApIHtcbiAgICAgICAgICAgIGlmIChkaXNtaXNzaWJsZSkgY2xvc2VEcmF3ZXIoKTtcbiAgICAgICAgICAgIGVsc2Ugc25hcFRvUG9pbnQoc25hcFBvaW50c09mZnNldFswXSk7IC8vIHNuYXAgdG8gaW5pdGlhbCBwb2ludFxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc25hcFRvU2VxdWVudGlhbFBvaW50ICYmIHZlbG9jaXR5ID4gMiAmJiBoYXNEcmFnZ2VkVXAgJiYgc25hcFBvaW50c09mZnNldCAmJiBzbmFwUG9pbnRzKSB7XG4gICAgICAgICAgICBzbmFwVG9Qb2ludChzbmFwUG9pbnRzT2Zmc2V0W3NuYXBQb2ludHMubGVuZ3RoIC0gMV0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZpbmQgdGhlIGNsb3Nlc3Qgc25hcCBwb2ludCB0byB0aGUgY3VycmVudCBwb3NpdGlvblxuICAgICAgICBjb25zdCBjbG9zZXN0U25hcFBvaW50ID0gc25hcFBvaW50c09mZnNldCA9PSBudWxsID8gdm9pZCAwIDogc25hcFBvaW50c09mZnNldC5yZWR1Y2UoKHByZXYsIGN1cnIpPT57XG4gICAgICAgICAgICBpZiAodHlwZW9mIHByZXYgIT09ICdudW1iZXInIHx8IHR5cGVvZiBjdXJyICE9PSAnbnVtYmVyJykgcmV0dXJuIHByZXY7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5hYnMoY3VyciAtIGN1cnJlbnRQb3NpdGlvbikgPCBNYXRoLmFicyhwcmV2IC0gY3VycmVudFBvc2l0aW9uKSA/IGN1cnIgOiBwcmV2O1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgZGltID0gaXNWZXJ0aWNhbChkaXJlY3Rpb24pID8gd2luZG93LmlubmVySGVpZ2h0IDogd2luZG93LmlubmVyV2lkdGg7XG4gICAgICAgIGlmICh2ZWxvY2l0eSA+IFZFTE9DSVRZX1RIUkVTSE9MRCAmJiBNYXRoLmFicyhkcmFnZ2VkRGlzdGFuY2UpIDwgZGltICogMC40KSB7XG4gICAgICAgICAgICBjb25zdCBkcmFnRGlyZWN0aW9uID0gaGFzRHJhZ2dlZFVwID8gMSA6IC0xOyAvLyAxID0gdXAsIC0xID0gZG93blxuICAgICAgICAgICAgLy8gRG9uJ3QgZG8gYW55dGhpbmcgaWYgd2Ugc3dpcGUgdXB3YXJkcyB3aGlsZSBiZWluZyBvbiB0aGUgbGFzdCBzbmFwIHBvaW50XG4gICAgICAgICAgICBpZiAoZHJhZ0RpcmVjdGlvbiA+IDAgJiYgaXNMYXN0U25hcFBvaW50ICYmIHNuYXBQb2ludHMpIHtcbiAgICAgICAgICAgICAgICBzbmFwVG9Qb2ludChzbmFwUG9pbnRzT2Zmc2V0W3NuYXBQb2ludHMubGVuZ3RoIC0gMV0pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0ZpcnN0ICYmIGRyYWdEaXJlY3Rpb24gPCAwICYmIGRpc21pc3NpYmxlKSB7XG4gICAgICAgICAgICAgICAgY2xvc2VEcmF3ZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhY3RpdmVTbmFwUG9pbnRJbmRleCA9PT0gbnVsbCkgcmV0dXJuO1xuICAgICAgICAgICAgc25hcFRvUG9pbnQoc25hcFBvaW50c09mZnNldFthY3RpdmVTbmFwUG9pbnRJbmRleCArIGRyYWdEaXJlY3Rpb25dKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzbmFwVG9Qb2ludChjbG9zZXN0U25hcFBvaW50KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gb25EcmFnKHsgZHJhZ2dlZERpc3RhbmNlIH0pIHtcbiAgICAgICAgaWYgKGFjdGl2ZVNuYXBQb2ludE9mZnNldCA9PT0gbnVsbCkgcmV0dXJuO1xuICAgICAgICBjb25zdCBuZXdWYWx1ZSA9IGRpcmVjdGlvbiA9PT0gJ2JvdHRvbScgfHwgZGlyZWN0aW9uID09PSAncmlnaHQnID8gYWN0aXZlU25hcFBvaW50T2Zmc2V0IC0gZHJhZ2dlZERpc3RhbmNlIDogYWN0aXZlU25hcFBvaW50T2Zmc2V0ICsgZHJhZ2dlZERpc3RhbmNlO1xuICAgICAgICAvLyBEb24ndCBkbyBhbnl0aGluZyBpZiB3ZSBleGNlZWQgdGhlIGxhc3QoYmlnZ2VzdCkgc25hcCBwb2ludFxuICAgICAgICBpZiAoKGRpcmVjdGlvbiA9PT0gJ2JvdHRvbScgfHwgZGlyZWN0aW9uID09PSAncmlnaHQnKSAmJiBuZXdWYWx1ZSA8IHNuYXBQb2ludHNPZmZzZXRbc25hcFBvaW50c09mZnNldC5sZW5ndGggLSAxXSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoZGlyZWN0aW9uID09PSAndG9wJyB8fCBkaXJlY3Rpb24gPT09ICdsZWZ0JykgJiYgbmV3VmFsdWUgPiBzbmFwUG9pbnRzT2Zmc2V0W3NuYXBQb2ludHNPZmZzZXQubGVuZ3RoIC0gMV0pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzZXQoZHJhd2VyUmVmLmN1cnJlbnQsIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogaXNWZXJ0aWNhbChkaXJlY3Rpb24pID8gYHRyYW5zbGF0ZTNkKDAsICR7bmV3VmFsdWV9cHgsIDApYCA6IGB0cmFuc2xhdGUzZCgke25ld1ZhbHVlfXB4LCAwLCAwKWBcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFBlcmNlbnRhZ2VEcmFnZ2VkKGFic0RyYWdnZWREaXN0YW5jZSwgaXNEcmFnZ2luZ0Rvd24pIHtcbiAgICAgICAgaWYgKCFzbmFwUG9pbnRzIHx8IHR5cGVvZiBhY3RpdmVTbmFwUG9pbnRJbmRleCAhPT0gJ251bWJlcicgfHwgIXNuYXBQb2ludHNPZmZzZXQgfHwgZmFkZUZyb21JbmRleCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gbnVsbDtcbiAgICAgICAgLy8gSWYgdGhpcyBpcyB0cnVlIHdlIGFyZSBkcmFnZ2luZyB0byBhIHNuYXAgcG9pbnQgdGhhdCBpcyBzdXBwb3NlZCB0byBoYXZlIGFuIG92ZXJsYXlcbiAgICAgICAgY29uc3QgaXNPdmVybGF5U25hcFBvaW50ID0gYWN0aXZlU25hcFBvaW50SW5kZXggPT09IGZhZGVGcm9tSW5kZXggLSAxO1xuICAgICAgICBjb25zdCBpc092ZXJsYXlTbmFwUG9pbnRPckhpZ2hlciA9IGFjdGl2ZVNuYXBQb2ludEluZGV4ID49IGZhZGVGcm9tSW5kZXg7XG4gICAgICAgIGlmIChpc092ZXJsYXlTbmFwUG9pbnRPckhpZ2hlciAmJiBpc0RyYWdnaW5nRG93bikge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRG9uJ3QgYW5pbWF0ZSwgYnV0IHN0aWxsIHVzZSB0aGlzIG9uZSBpZiB3ZSBhcmUgZHJhZ2dpbmcgYXdheSBmcm9tIHRoZSBvdmVybGF5U25hcFBvaW50XG4gICAgICAgIGlmIChpc092ZXJsYXlTbmFwUG9pbnQgJiYgIWlzRHJhZ2dpbmdEb3duKSByZXR1cm4gMTtcbiAgICAgICAgaWYgKCFzaG91bGRGYWRlICYmICFpc092ZXJsYXlTbmFwUG9pbnQpIHJldHVybiBudWxsO1xuICAgICAgICAvLyBFaXRoZXIgZmFkZUZyb20gaW5kZXggb3IgdGhlIG9uZSBiZWZvcmVcbiAgICAgICAgY29uc3QgdGFyZ2V0U25hcFBvaW50SW5kZXggPSBpc092ZXJsYXlTbmFwUG9pbnQgPyBhY3RpdmVTbmFwUG9pbnRJbmRleCArIDEgOiBhY3RpdmVTbmFwUG9pbnRJbmRleCAtIDE7XG4gICAgICAgIC8vIEdldCB0aGUgZGlzdGFuY2UgZnJvbSBvdmVybGF5U25hcFBvaW50IHRvIHRoZSBvbmUgYmVmb3JlIG9yIHZpY2UtdmVyc2EgdG8gY2FsY3VsYXRlIHRoZSBvcGFjaXR5IHBlcmNlbnRhZ2UgYWNjb3JkaW5nbHlcbiAgICAgICAgY29uc3Qgc25hcFBvaW50RGlzdGFuY2UgPSBpc092ZXJsYXlTbmFwUG9pbnQgPyBzbmFwUG9pbnRzT2Zmc2V0W3RhcmdldFNuYXBQb2ludEluZGV4XSAtIHNuYXBQb2ludHNPZmZzZXRbdGFyZ2V0U25hcFBvaW50SW5kZXggLSAxXSA6IHNuYXBQb2ludHNPZmZzZXRbdGFyZ2V0U25hcFBvaW50SW5kZXggKyAxXSAtIHNuYXBQb2ludHNPZmZzZXRbdGFyZ2V0U25hcFBvaW50SW5kZXhdO1xuICAgICAgICBjb25zdCBwZXJjZW50YWdlRHJhZ2dlZCA9IGFic0RyYWdnZWREaXN0YW5jZSAvIE1hdGguYWJzKHNuYXBQb2ludERpc3RhbmNlKTtcbiAgICAgICAgaWYgKGlzT3ZlcmxheVNuYXBQb2ludCkge1xuICAgICAgICAgICAgcmV0dXJuIDEgLSBwZXJjZW50YWdlRHJhZ2dlZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBwZXJjZW50YWdlRHJhZ2dlZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBpc0xhc3RTbmFwUG9pbnQsXG4gICAgICAgIGFjdGl2ZVNuYXBQb2ludCxcbiAgICAgICAgc2hvdWxkRmFkZSxcbiAgICAgICAgZ2V0UGVyY2VudGFnZURyYWdnZWQsXG4gICAgICAgIHNldEFjdGl2ZVNuYXBQb2ludCxcbiAgICAgICAgYWN0aXZlU25hcFBvaW50SW5kZXgsXG4gICAgICAgIG9uUmVsZWFzZSxcbiAgICAgICAgb25EcmFnLFxuICAgICAgICBzbmFwUG9pbnRzT2Zmc2V0XG4gICAgfTtcbn1cblxuY29uc3Qgbm9vcCA9ICgpPT4oKT0+e307XG5mdW5jdGlvbiB1c2VTY2FsZUJhY2tncm91bmQoKSB7XG4gICAgY29uc3QgeyBkaXJlY3Rpb24sIGlzT3Blbiwgc2hvdWxkU2NhbGVCYWNrZ3JvdW5kLCBzZXRCYWNrZ3JvdW5kQ29sb3JPblNjYWxlLCBub0JvZHlTdHlsZXMgfSA9IHVzZURyYXdlckNvbnRleHQoKTtcbiAgICBjb25zdCB0aW1lb3V0SWRSZWYgPSBSZWFjdF9fZGVmYXVsdC51c2VSZWYobnVsbCk7XG4gICAgY29uc3QgaW5pdGlhbEJhY2tncm91bmRDb2xvciA9IHVzZU1lbW8oKCk9PmRvY3VtZW50LmJvZHkuc3R5bGUuYmFja2dyb3VuZENvbG9yLCBbXSk7XG4gICAgZnVuY3Rpb24gZ2V0U2NhbGUoKSB7XG4gICAgICAgIHJldHVybiAod2luZG93LmlubmVyV2lkdGggLSBXSU5ET1dfVE9QX09GRlNFVCkgLyB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICB9XG4gICAgUmVhY3RfX2RlZmF1bHQudXNlRWZmZWN0KCgpPT57XG4gICAgICAgIGlmIChpc09wZW4gJiYgc2hvdWxkU2NhbGVCYWNrZ3JvdW5kKSB7XG4gICAgICAgICAgICBpZiAodGltZW91dElkUmVmLmN1cnJlbnQpIGNsZWFyVGltZW91dCh0aW1lb3V0SWRSZWYuY3VycmVudCk7XG4gICAgICAgICAgICBjb25zdCB3cmFwcGVyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignW2RhdGEtdmF1bC1kcmF3ZXItd3JhcHBlcl0nKSB8fCBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdbdmF1bC1kcmF3ZXItd3JhcHBlcl0nKTtcbiAgICAgICAgICAgIGlmICghd3JhcHBlcikgcmV0dXJuO1xuICAgICAgICAgICAgY2hhaW4oc2V0QmFja2dyb3VuZENvbG9yT25TY2FsZSAmJiAhbm9Cb2R5U3R5bGVzID8gYXNzaWduU3R5bGUoZG9jdW1lbnQuYm9keSwge1xuICAgICAgICAgICAgICAgIGJhY2tncm91bmQ6ICdibGFjaydcbiAgICAgICAgICAgIH0pIDogbm9vcCwgYXNzaWduU3R5bGUod3JhcHBlciwge1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybU9yaWdpbjogaXNWZXJ0aWNhbChkaXJlY3Rpb24pID8gJ3RvcCcgOiAnbGVmdCcsXG4gICAgICAgICAgICAgICAgdHJhbnNpdGlvblByb3BlcnR5OiAndHJhbnNmb3JtLCBib3JkZXItcmFkaXVzJyxcbiAgICAgICAgICAgICAgICB0cmFuc2l0aW9uRHVyYXRpb246IGAke1RSQU5TSVRJT05TLkRVUkFUSU9OfXNgLFxuICAgICAgICAgICAgICAgIHRyYW5zaXRpb25UaW1pbmdGdW5jdGlvbjogYGN1YmljLWJlemllcigke1RSQU5TSVRJT05TLkVBU0Uuam9pbignLCcpfSlgXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICBjb25zdCB3cmFwcGVyU3R5bGVzQ2xlYW51cCA9IGFzc2lnblN0eWxlKHdyYXBwZXIsIHtcbiAgICAgICAgICAgICAgICBib3JkZXJSYWRpdXM6IGAke0JPUkRFUl9SQURJVVN9cHhgLFxuICAgICAgICAgICAgICAgIG92ZXJmbG93OiAnaGlkZGVuJyxcbiAgICAgICAgICAgICAgICAuLi5pc1ZlcnRpY2FsKGRpcmVjdGlvbikgPyB7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogYHNjYWxlKCR7Z2V0U2NhbGUoKX0pIHRyYW5zbGF0ZTNkKDAsIGNhbGMoZW52KHNhZmUtYXJlYS1pbnNldC10b3ApICsgMTRweCksIDApYFxuICAgICAgICAgICAgICAgIH0gOiB7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogYHNjYWxlKCR7Z2V0U2NhbGUoKX0pIHRyYW5zbGF0ZTNkKGNhbGMoZW52KHNhZmUtYXJlYS1pbnNldC10b3ApICsgMTRweCksIDAsIDApYFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuICgpPT57XG4gICAgICAgICAgICAgICAgd3JhcHBlclN0eWxlc0NsZWFudXAoKTtcbiAgICAgICAgICAgICAgICB0aW1lb3V0SWRSZWYuY3VycmVudCA9IHdpbmRvdy5zZXRUaW1lb3V0KCgpPT57XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbml0aWFsQmFja2dyb3VuZENvbG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LnN0eWxlLmJhY2tncm91bmQgPSBpbml0aWFsQmFja2dyb3VuZENvbG9yO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5zdHlsZS5yZW1vdmVQcm9wZXJ0eSgnYmFja2dyb3VuZCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgVFJBTlNJVElPTlMuRFVSQVRJT04gKiAxMDAwKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9LCBbXG4gICAgICAgIGlzT3BlbixcbiAgICAgICAgc2hvdWxkU2NhbGVCYWNrZ3JvdW5kLFxuICAgICAgICBpbml0aWFsQmFja2dyb3VuZENvbG9yXG4gICAgXSk7XG59XG5cbmxldCBwcmV2aW91c0JvZHlQb3NpdGlvbiA9IG51bGw7XG4vKipcbiAqIFRoaXMgaG9vayBpcyBuZWNlc3NhcnkgdG8gcHJldmVudCBidWdneSBiZWhhdmlvciBvbiBpT1MgZGV2aWNlcyAobmVlZCB0byB0ZXN0IG9uIEFuZHJvaWQpLlxuICogSSB3b24ndCBnZXQgaW50byB0b28gbXVjaCBkZXRhaWwgYWJvdXQgd2hhdCBidWdzIGl0IHNvbHZlcywgYnV0IHNvIGZhciBJJ3ZlIGZvdW5kIHRoYXQgc2V0dGluZyB0aGUgYm9keSB0byBgcG9zaXRpb246IGZpeGVkYCBpcyB0aGUgbW9zdCByZWxpYWJsZSB3YXkgdG8gcHJldmVudCB0aG9zZSBidWdzLlxuICogSXNzdWVzIHRoYXQgdGhpcyBob29rIHNvbHZlczpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9lbWlsa293YWxza2kvdmF1bC9pc3N1ZXMvNDM1XG4gKiBodHRwczovL2dpdGh1Yi5jb20vZW1pbGtvd2Fsc2tpL3ZhdWwvaXNzdWVzLzQzM1xuICogQW5kIG1vcmUgdGhhdCBJIGRpc2NvdmVyZWQsIGJ1dCB3ZXJlIGp1c3Qgbm90IHJlcG9ydGVkLlxuICovIGZ1bmN0aW9uIHVzZVBvc2l0aW9uRml4ZWQoeyBpc09wZW4sIG1vZGFsLCBuZXN0ZWQsIGhhc0JlZW5PcGVuZWQsIHByZXZlbnRTY3JvbGxSZXN0b3JhdGlvbiwgbm9Cb2R5U3R5bGVzIH0pIHtcbiAgICBjb25zdCBbYWN0aXZlVXJsLCBzZXRBY3RpdmVVcmxdID0gUmVhY3RfX2RlZmF1bHQudXNlU3RhdGUoKCk9PnR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93LmxvY2F0aW9uLmhyZWYgOiAnJyk7XG4gICAgY29uc3Qgc2Nyb2xsUG9zID0gUmVhY3RfX2RlZmF1bHQudXNlUmVmKDApO1xuICAgIGNvbnN0IHNldFBvc2l0aW9uRml4ZWQgPSBSZWFjdF9fZGVmYXVsdC51c2VDYWxsYmFjaygoKT0+e1xuICAgICAgICAvLyBBbGwgYnJvd3NlcnMgb24gaU9TIHdpbGwgcmV0dXJuIHRydWUgaGVyZS5cbiAgICAgICAgaWYgKCFpc1NhZmFyaSgpKSByZXR1cm47XG4gICAgICAgIC8vIElmIHByZXZpb3VzQm9keVBvc2l0aW9uIGlzIGFscmVhZHkgc2V0LCBkb24ndCBzZXQgaXQgYWdhaW4uXG4gICAgICAgIGlmIChwcmV2aW91c0JvZHlQb3NpdGlvbiA9PT0gbnVsbCAmJiBpc09wZW4gJiYgIW5vQm9keVN0eWxlcykge1xuICAgICAgICAgICAgcHJldmlvdXNCb2R5UG9zaXRpb24gPSB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb246IGRvY3VtZW50LmJvZHkuc3R5bGUucG9zaXRpb24sXG4gICAgICAgICAgICAgICAgdG9wOiBkb2N1bWVudC5ib2R5LnN0eWxlLnRvcCxcbiAgICAgICAgICAgICAgICBsZWZ0OiBkb2N1bWVudC5ib2R5LnN0eWxlLmxlZnQsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBkb2N1bWVudC5ib2R5LnN0eWxlLmhlaWdodCxcbiAgICAgICAgICAgICAgICByaWdodDogJ3Vuc2V0J1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgZG9tIGluc2lkZSBhbiBhbmltYXRpb24gZnJhbWVcbiAgICAgICAgICAgIGNvbnN0IHsgc2Nyb2xsWCwgaW5uZXJIZWlnaHQgfSA9IHdpbmRvdztcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuc3R5bGUuc2V0UHJvcGVydHkoJ3Bvc2l0aW9uJywgJ2ZpeGVkJywgJ2ltcG9ydGFudCcpO1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihkb2N1bWVudC5ib2R5LnN0eWxlLCB7XG4gICAgICAgICAgICAgICAgdG9wOiBgJHstc2Nyb2xsUG9zLmN1cnJlbnR9cHhgLFxuICAgICAgICAgICAgICAgIGxlZnQ6IGAkey1zY3JvbGxYfXB4YCxcbiAgICAgICAgICAgICAgICByaWdodDogJzBweCcsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAnYXV0bydcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgd2luZG93LnNldFRpbWVvdXQoKCk9PndpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCk9PntcbiAgICAgICAgICAgICAgICAgICAgLy8gQXR0ZW1wdCB0byBjaGVjayBpZiB0aGUgYm90dG9tIGJhciBhcHBlYXJlZCBkdWUgdG8gdGhlIHBvc2l0aW9uIGNoYW5nZVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBib3R0b21CYXJIZWlnaHQgPSBpbm5lckhlaWdodCAtIHdpbmRvdy5pbm5lckhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJvdHRvbUJhckhlaWdodCAmJiBzY3JvbGxQb3MuY3VycmVudCA+PSBpbm5lckhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTW92ZSB0aGUgY29udGVudCBmdXJ0aGVyIHVwIHNvIHRoYXQgdGhlIGJvdHRvbSBiYXIgZG9lc24ndCBoaWRlIGl0XG4gICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LnN0eWxlLnRvcCA9IGAkey0oc2Nyb2xsUG9zLmN1cnJlbnQgKyBib3R0b21CYXJIZWlnaHQpfXB4YDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pLCAzMDApO1xuICAgICAgICB9XG4gICAgfSwgW1xuICAgICAgICBpc09wZW5cbiAgICBdKTtcbiAgICBjb25zdCByZXN0b3JlUG9zaXRpb25TZXR0aW5nID0gUmVhY3RfX2RlZmF1bHQudXNlQ2FsbGJhY2soKCk9PntcbiAgICAgICAgLy8gQWxsIGJyb3dzZXJzIG9uIGlPUyB3aWxsIHJldHVybiB0cnVlIGhlcmUuXG4gICAgICAgIGlmICghaXNTYWZhcmkoKSkgcmV0dXJuO1xuICAgICAgICBpZiAocHJldmlvdXNCb2R5UG9zaXRpb24gIT09IG51bGwgJiYgIW5vQm9keVN0eWxlcykge1xuICAgICAgICAgICAgLy8gQ29udmVydCB0aGUgcG9zaXRpb24gZnJvbSBcInB4XCIgdG8gSW50XG4gICAgICAgICAgICBjb25zdCB5ID0gLXBhcnNlSW50KGRvY3VtZW50LmJvZHkuc3R5bGUudG9wLCAxMCk7XG4gICAgICAgICAgICBjb25zdCB4ID0gLXBhcnNlSW50KGRvY3VtZW50LmJvZHkuc3R5bGUubGVmdCwgMTApO1xuICAgICAgICAgICAgLy8gUmVzdG9yZSBzdHlsZXNcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oZG9jdW1lbnQuYm9keS5zdHlsZSwgcHJldmlvdXNCb2R5UG9zaXRpb24pO1xuICAgICAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKT0+e1xuICAgICAgICAgICAgICAgIGlmIChwcmV2ZW50U2Nyb2xsUmVzdG9yYXRpb24gJiYgYWN0aXZlVXJsICE9PSB3aW5kb3cubG9jYXRpb24uaHJlZikge1xuICAgICAgICAgICAgICAgICAgICBzZXRBY3RpdmVVcmwod2luZG93LmxvY2F0aW9uLmhyZWYpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdpbmRvdy5zY3JvbGxUbyh4LCB5KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcHJldmlvdXNCb2R5UG9zaXRpb24gPSBudWxsO1xuICAgICAgICB9XG4gICAgfSwgW1xuICAgICAgICBhY3RpdmVVcmxcbiAgICBdKTtcbiAgICBSZWFjdF9fZGVmYXVsdC51c2VFZmZlY3QoKCk9PntcbiAgICAgICAgZnVuY3Rpb24gb25TY3JvbGwoKSB7XG4gICAgICAgICAgICBzY3JvbGxQb3MuY3VycmVudCA9IHdpbmRvdy5zY3JvbGxZO1xuICAgICAgICB9XG4gICAgICAgIG9uU2Nyb2xsKCk7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBvblNjcm9sbCk7XG4gICAgICAgIHJldHVybiAoKT0+e1xuICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIG9uU2Nyb2xsKTtcbiAgICAgICAgfTtcbiAgICB9LCBbXSk7XG4gICAgUmVhY3RfX2RlZmF1bHQudXNlRWZmZWN0KCgpPT57XG4gICAgICAgIGlmICghbW9kYWwpIHJldHVybjtcbiAgICAgICAgcmV0dXJuICgpPT57XG4gICAgICAgICAgICBpZiAodHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJykgcmV0dXJuO1xuICAgICAgICAgICAgLy8gQW5vdGhlciBkcmF3ZXIgaXMgb3BlbmVkLCBzYWZlIHRvIGlnbm9yZSB0aGUgZXhlY3V0aW9uXG4gICAgICAgICAgICBjb25zdCBoYXNEcmF3ZXJPcGVuZWQgPSAhIWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ1tkYXRhLXZhdWwtZHJhd2VyXScpO1xuICAgICAgICAgICAgaWYgKGhhc0RyYXdlck9wZW5lZCkgcmV0dXJuO1xuICAgICAgICAgICAgcmVzdG9yZVBvc2l0aW9uU2V0dGluZygpO1xuICAgICAgICB9O1xuICAgIH0sIFtcbiAgICAgICAgbW9kYWwsXG4gICAgICAgIHJlc3RvcmVQb3NpdGlvblNldHRpbmdcbiAgICBdKTtcbiAgICBSZWFjdF9fZGVmYXVsdC51c2VFZmZlY3QoKCk9PntcbiAgICAgICAgaWYgKG5lc3RlZCB8fCAhaGFzQmVlbk9wZW5lZCkgcmV0dXJuO1xuICAgICAgICAvLyBUaGlzIGlzIG5lZWRlZCB0byBmb3JjZSBTYWZhcmkgdG9vbGJhciB0byBzaG93ICoqYmVmb3JlKiogdGhlIGRyYXdlciBzdGFydHMgYW5pbWF0aW5nIHRvIHByZXZlbnQgYSBnbmFybHkgc2hpZnQgZnJvbSBoYXBwZW5pbmdcbiAgICAgICAgaWYgKGlzT3Blbikge1xuICAgICAgICAgICAgLy8gYXZvaWQgZm9yIHN0YW5kYWxvbmUgbW9kZSAoUFdBKVxuICAgICAgICAgICAgY29uc3QgaXNTdGFuZGFsb25lID0gd2luZG93Lm1hdGNoTWVkaWEoJyhkaXNwbGF5LW1vZGU6IHN0YW5kYWxvbmUpJykubWF0Y2hlcztcbiAgICAgICAgICAgICFpc1N0YW5kYWxvbmUgJiYgc2V0UG9zaXRpb25GaXhlZCgpO1xuICAgICAgICAgICAgaWYgKCFtb2RhbCkge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KCgpPT57XG4gICAgICAgICAgICAgICAgICAgIHJlc3RvcmVQb3NpdGlvblNldHRpbmcoKTtcbiAgICAgICAgICAgICAgICB9LCA1MDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdG9yZVBvc2l0aW9uU2V0dGluZygpO1xuICAgICAgICB9XG4gICAgfSwgW1xuICAgICAgICBpc09wZW4sXG4gICAgICAgIGhhc0JlZW5PcGVuZWQsXG4gICAgICAgIGFjdGl2ZVVybCxcbiAgICAgICAgbW9kYWwsXG4gICAgICAgIG5lc3RlZCxcbiAgICAgICAgc2V0UG9zaXRpb25GaXhlZCxcbiAgICAgICAgcmVzdG9yZVBvc2l0aW9uU2V0dGluZ1xuICAgIF0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIHJlc3RvcmVQb3NpdGlvblNldHRpbmdcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBSb290KHsgb3Blbjogb3BlblByb3AsIG9uT3BlbkNoYW5nZSwgY2hpbGRyZW4sIG9uRHJhZzogb25EcmFnUHJvcCwgb25SZWxlYXNlOiBvblJlbGVhc2VQcm9wLCBzbmFwUG9pbnRzLCBzaG91bGRTY2FsZUJhY2tncm91bmQgPSBmYWxzZSwgc2V0QmFja2dyb3VuZENvbG9yT25TY2FsZSA9IHRydWUsIGNsb3NlVGhyZXNob2xkID0gQ0xPU0VfVEhSRVNIT0xELCBzY3JvbGxMb2NrVGltZW91dCA9IFNDUk9MTF9MT0NLX1RJTUVPVVQsIGRpc21pc3NpYmxlID0gdHJ1ZSwgaGFuZGxlT25seSA9IGZhbHNlLCBmYWRlRnJvbUluZGV4ID0gc25hcFBvaW50cyAmJiBzbmFwUG9pbnRzLmxlbmd0aCAtIDEsIGFjdGl2ZVNuYXBQb2ludDogYWN0aXZlU25hcFBvaW50UHJvcCwgc2V0QWN0aXZlU25hcFBvaW50OiBzZXRBY3RpdmVTbmFwUG9pbnRQcm9wLCBmaXhlZCwgbW9kYWwgPSB0cnVlLCBvbkNsb3NlLCBuZXN0ZWQsIG5vQm9keVN0eWxlcyA9IGZhbHNlLCBkaXJlY3Rpb24gPSAnYm90dG9tJywgZGVmYXVsdE9wZW4gPSBmYWxzZSwgZGlzYWJsZVByZXZlbnRTY3JvbGwgPSB0cnVlLCBzbmFwVG9TZXF1ZW50aWFsUG9pbnQgPSBmYWxzZSwgcHJldmVudFNjcm9sbFJlc3RvcmF0aW9uID0gZmFsc2UsIHJlcG9zaXRpb25JbnB1dHMgPSB0cnVlLCBvbkFuaW1hdGlvbkVuZCwgY29udGFpbmVyLCBhdXRvRm9jdXMgPSBmYWxzZSB9KSB7XG4gICAgdmFyIF9kcmF3ZXJSZWZfY3VycmVudCwgX2RyYXdlclJlZl9jdXJyZW50MTtcbiAgICBjb25zdCBbaXNPcGVuID0gZmFsc2UsIHNldElzT3Blbl0gPSB1c2VDb250cm9sbGFibGVTdGF0ZSh7XG4gICAgICAgIGRlZmF1bHRQcm9wOiBkZWZhdWx0T3BlbixcbiAgICAgICAgcHJvcDogb3BlblByb3AsXG4gICAgICAgIG9uQ2hhbmdlOiAobyk9PntcbiAgICAgICAgICAgIG9uT3BlbkNoYW5nZSA9PSBudWxsID8gdm9pZCAwIDogb25PcGVuQ2hhbmdlKG8pO1xuICAgICAgICAgICAgaWYgKCFvICYmICFuZXN0ZWQpIHtcbiAgICAgICAgICAgICAgICByZXN0b3JlUG9zaXRpb25TZXR0aW5nKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpPT57XG4gICAgICAgICAgICAgICAgb25BbmltYXRpb25FbmQgPT0gbnVsbCA/IHZvaWQgMCA6IG9uQW5pbWF0aW9uRW5kKG8pO1xuICAgICAgICAgICAgfSwgVFJBTlNJVElPTlMuRFVSQVRJT04gKiAxMDAwKTtcbiAgICAgICAgICAgIGlmIChvICYmICFtb2RhbCkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpPT57XG4gICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnYXV0byc7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghbykge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgd2lsbCBiZSByZW1vdmVkIHdoZW4gdGhlIGV4aXQgYW5pbWF0aW9uIGVuZHMgKGA1MDBtc2ApXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ2F1dG8nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgW2hhc0JlZW5PcGVuZWQsIHNldEhhc0JlZW5PcGVuZWRdID0gUmVhY3RfX2RlZmF1bHQudXNlU3RhdGUoZmFsc2UpO1xuICAgIGNvbnN0IFtpc0RyYWdnaW5nLCBzZXRJc0RyYWdnaW5nXSA9IFJlYWN0X19kZWZhdWx0LnVzZVN0YXRlKGZhbHNlKTtcbiAgICBjb25zdCBbanVzdFJlbGVhc2VkLCBzZXRKdXN0UmVsZWFzZWRdID0gUmVhY3RfX2RlZmF1bHQudXNlU3RhdGUoZmFsc2UpO1xuICAgIGNvbnN0IG92ZXJsYXlSZWYgPSBSZWFjdF9fZGVmYXVsdC51c2VSZWYobnVsbCk7XG4gICAgY29uc3Qgb3BlblRpbWUgPSBSZWFjdF9fZGVmYXVsdC51c2VSZWYobnVsbCk7XG4gICAgY29uc3QgZHJhZ1N0YXJ0VGltZSA9IFJlYWN0X19kZWZhdWx0LnVzZVJlZihudWxsKTtcbiAgICBjb25zdCBkcmFnRW5kVGltZSA9IFJlYWN0X19kZWZhdWx0LnVzZVJlZihudWxsKTtcbiAgICBjb25zdCBsYXN0VGltZURyYWdQcmV2ZW50ZWQgPSBSZWFjdF9fZGVmYXVsdC51c2VSZWYobnVsbCk7XG4gICAgY29uc3QgaXNBbGxvd2VkVG9EcmFnID0gUmVhY3RfX2RlZmF1bHQudXNlUmVmKGZhbHNlKTtcbiAgICBjb25zdCBuZXN0ZWRPcGVuQ2hhbmdlVGltZXIgPSBSZWFjdF9fZGVmYXVsdC51c2VSZWYobnVsbCk7XG4gICAgY29uc3QgcG9pbnRlclN0YXJ0ID0gUmVhY3RfX2RlZmF1bHQudXNlUmVmKDApO1xuICAgIGNvbnN0IGtleWJvYXJkSXNPcGVuID0gUmVhY3RfX2RlZmF1bHQudXNlUmVmKGZhbHNlKTtcbiAgICBjb25zdCBzaG91bGRBbmltYXRlID0gUmVhY3RfX2RlZmF1bHQudXNlUmVmKCFkZWZhdWx0T3Blbik7XG4gICAgY29uc3QgcHJldmlvdXNEaWZmRnJvbUluaXRpYWwgPSBSZWFjdF9fZGVmYXVsdC51c2VSZWYoMCk7XG4gICAgY29uc3QgZHJhd2VyUmVmID0gUmVhY3RfX2RlZmF1bHQudXNlUmVmKG51bGwpO1xuICAgIGNvbnN0IGRyYXdlckhlaWdodFJlZiA9IFJlYWN0X19kZWZhdWx0LnVzZVJlZigoKF9kcmF3ZXJSZWZfY3VycmVudCA9IGRyYXdlclJlZi5jdXJyZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2RyYXdlclJlZl9jdXJyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodCkgfHwgMCk7XG4gICAgY29uc3QgZHJhd2VyV2lkdGhSZWYgPSBSZWFjdF9fZGVmYXVsdC51c2VSZWYoKChfZHJhd2VyUmVmX2N1cnJlbnQxID0gZHJhd2VyUmVmLmN1cnJlbnQpID09IG51bGwgPyB2b2lkIDAgOiBfZHJhd2VyUmVmX2N1cnJlbnQxLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoKSB8fCAwKTtcbiAgICBjb25zdCBpbml0aWFsRHJhd2VySGVpZ2h0ID0gUmVhY3RfX2RlZmF1bHQudXNlUmVmKDApO1xuICAgIGNvbnN0IG9uU25hcFBvaW50Q2hhbmdlID0gUmVhY3RfX2RlZmF1bHQudXNlQ2FsbGJhY2soKGFjdGl2ZVNuYXBQb2ludEluZGV4KT0+e1xuICAgICAgICAvLyBDaGFuZ2Ugb3BlblRpbWUgcmVmIHdoZW4gd2UgcmVhY2ggdGhlIGxhc3Qgc25hcCBwb2ludCB0byBwcmV2ZW50IGRyYWdnaW5nIGZvciA1MDBtcyBpbmNhc2UgaXQncyBzY3JvbGxhYmxlLlxuICAgICAgICBpZiAoc25hcFBvaW50cyAmJiBhY3RpdmVTbmFwUG9pbnRJbmRleCA9PT0gc25hcFBvaW50c09mZnNldC5sZW5ndGggLSAxKSBvcGVuVGltZS5jdXJyZW50ID0gbmV3IERhdGUoKTtcbiAgICB9LCBbXSk7XG4gICAgY29uc3QgeyBhY3RpdmVTbmFwUG9pbnQsIGFjdGl2ZVNuYXBQb2ludEluZGV4LCBzZXRBY3RpdmVTbmFwUG9pbnQsIG9uUmVsZWFzZTogb25SZWxlYXNlU25hcFBvaW50cywgc25hcFBvaW50c09mZnNldCwgb25EcmFnOiBvbkRyYWdTbmFwUG9pbnRzLCBzaG91bGRGYWRlLCBnZXRQZXJjZW50YWdlRHJhZ2dlZDogZ2V0U25hcFBvaW50c1BlcmNlbnRhZ2VEcmFnZ2VkIH0gPSB1c2VTbmFwUG9pbnRzKHtcbiAgICAgICAgc25hcFBvaW50cyxcbiAgICAgICAgYWN0aXZlU25hcFBvaW50UHJvcCxcbiAgICAgICAgc2V0QWN0aXZlU25hcFBvaW50UHJvcCxcbiAgICAgICAgZHJhd2VyUmVmLFxuICAgICAgICBmYWRlRnJvbUluZGV4LFxuICAgICAgICBvdmVybGF5UmVmLFxuICAgICAgICBvblNuYXBQb2ludENoYW5nZSxcbiAgICAgICAgZGlyZWN0aW9uLFxuICAgICAgICBjb250YWluZXIsXG4gICAgICAgIHNuYXBUb1NlcXVlbnRpYWxQb2ludFxuICAgIH0pO1xuICAgIHVzZVByZXZlbnRTY3JvbGwoe1xuICAgICAgICBpc0Rpc2FibGVkOiAhaXNPcGVuIHx8IGlzRHJhZ2dpbmcgfHwgIW1vZGFsIHx8IGp1c3RSZWxlYXNlZCB8fCAhaGFzQmVlbk9wZW5lZCB8fCAhcmVwb3NpdGlvbklucHV0cyB8fCAhZGlzYWJsZVByZXZlbnRTY3JvbGxcbiAgICB9KTtcbiAgICBjb25zdCB7IHJlc3RvcmVQb3NpdGlvblNldHRpbmcgfSA9IHVzZVBvc2l0aW9uRml4ZWQoe1xuICAgICAgICBpc09wZW4sXG4gICAgICAgIG1vZGFsLFxuICAgICAgICBuZXN0ZWQ6IG5lc3RlZCAhPSBudWxsID8gbmVzdGVkIDogZmFsc2UsXG4gICAgICAgIGhhc0JlZW5PcGVuZWQsXG4gICAgICAgIHByZXZlbnRTY3JvbGxSZXN0b3JhdGlvbixcbiAgICAgICAgbm9Cb2R5U3R5bGVzXG4gICAgfSk7XG4gICAgZnVuY3Rpb24gZ2V0U2NhbGUoKSB7XG4gICAgICAgIHJldHVybiAod2luZG93LmlubmVyV2lkdGggLSBXSU5ET1dfVE9QX09GRlNFVCkgLyB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICB9XG4gICAgZnVuY3Rpb24gb25QcmVzcyhldmVudCkge1xuICAgICAgICB2YXIgX2RyYXdlclJlZl9jdXJyZW50LCBfZHJhd2VyUmVmX2N1cnJlbnQxO1xuICAgICAgICBpZiAoIWRpc21pc3NpYmxlICYmICFzbmFwUG9pbnRzKSByZXR1cm47XG4gICAgICAgIGlmIChkcmF3ZXJSZWYuY3VycmVudCAmJiAhZHJhd2VyUmVmLmN1cnJlbnQuY29udGFpbnMoZXZlbnQudGFyZ2V0KSkgcmV0dXJuO1xuICAgICAgICBkcmF3ZXJIZWlnaHRSZWYuY3VycmVudCA9ICgoX2RyYXdlclJlZl9jdXJyZW50ID0gZHJhd2VyUmVmLmN1cnJlbnQpID09IG51bGwgPyB2b2lkIDAgOiBfZHJhd2VyUmVmX2N1cnJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0KSB8fCAwO1xuICAgICAgICBkcmF3ZXJXaWR0aFJlZi5jdXJyZW50ID0gKChfZHJhd2VyUmVmX2N1cnJlbnQxID0gZHJhd2VyUmVmLmN1cnJlbnQpID09IG51bGwgPyB2b2lkIDAgOiBfZHJhd2VyUmVmX2N1cnJlbnQxLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoKSB8fCAwO1xuICAgICAgICBzZXRJc0RyYWdnaW5nKHRydWUpO1xuICAgICAgICBkcmFnU3RhcnRUaW1lLmN1cnJlbnQgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAvLyBpT1MgZG9lc24ndCB0cmlnZ2VyIG1vdXNlVXAgYWZ0ZXIgc2Nyb2xsaW5nIHNvIHdlIG5lZWQgdG8gbGlzdGVuIHRvIHRvdWNoZWQgaW4gb3JkZXIgdG8gZGlzYWxsb3cgZHJhZ2dpbmdcbiAgICAgICAgaWYgKGlzSU9TKCkpIHtcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsICgpPT5pc0FsbG93ZWRUb0RyYWcuY3VycmVudCA9IGZhbHNlLCB7XG4gICAgICAgICAgICAgICAgb25jZTogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRW5zdXJlIHdlIG1haW50YWluIGNvcnJlY3QgcG9pbnRlciBjYXB0dXJlIGV2ZW4gd2hlbiBnb2luZyBvdXRzaWRlIG9mIHRoZSBkcmF3ZXJcbiAgICAgICAgZXZlbnQudGFyZ2V0LnNldFBvaW50ZXJDYXB0dXJlKGV2ZW50LnBvaW50ZXJJZCk7XG4gICAgICAgIHBvaW50ZXJTdGFydC5jdXJyZW50ID0gaXNWZXJ0aWNhbChkaXJlY3Rpb24pID8gZXZlbnQucGFnZVkgOiBldmVudC5wYWdlWDtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2hvdWxkRHJhZyhlbCwgaXNEcmFnZ2luZ0luRGlyZWN0aW9uKSB7XG4gICAgICAgIHZhciBfd2luZG93X2dldFNlbGVjdGlvbjtcbiAgICAgICAgbGV0IGVsZW1lbnQgPSBlbDtcbiAgICAgICAgY29uc3QgaGlnaGxpZ2h0ZWRUZXh0ID0gKF93aW5kb3dfZ2V0U2VsZWN0aW9uID0gd2luZG93LmdldFNlbGVjdGlvbigpKSA9PSBudWxsID8gdm9pZCAwIDogX3dpbmRvd19nZXRTZWxlY3Rpb24udG9TdHJpbmcoKTtcbiAgICAgICAgY29uc3Qgc3dpcGVBbW91bnQgPSBkcmF3ZXJSZWYuY3VycmVudCA/IGdldFRyYW5zbGF0ZShkcmF3ZXJSZWYuY3VycmVudCwgZGlyZWN0aW9uKSA6IG51bGw7XG4gICAgICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAvLyBGaXhlcyBodHRwczovL2dpdGh1Yi5jb20vZW1pbGtvd2Fsc2tpL3ZhdWwvaXNzdWVzLzQ4M1xuICAgICAgICBpZiAoZWxlbWVudC50YWdOYW1lID09PSAnU0VMRUNUJykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbGVtZW50Lmhhc0F0dHJpYnV0ZSgnZGF0YS12YXVsLW5vLWRyYWcnKSB8fCBlbGVtZW50LmNsb3Nlc3QoJ1tkYXRhLXZhdWwtbm8tZHJhZ10nKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkaXJlY3Rpb24gPT09ICdyaWdodCcgfHwgZGlyZWN0aW9uID09PSAnbGVmdCcpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFsbG93IHNjcm9sbGluZyB3aGVuIGFuaW1hdGluZ1xuICAgICAgICBpZiAob3BlblRpbWUuY3VycmVudCAmJiBkYXRlLmdldFRpbWUoKSAtIG9wZW5UaW1lLmN1cnJlbnQuZ2V0VGltZSgpIDwgNTAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN3aXBlQW1vdW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoZGlyZWN0aW9uID09PSAnYm90dG9tJyA/IHN3aXBlQW1vdW50ID4gMCA6IHN3aXBlQW1vdW50IDwgMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIERvbid0IGRyYWcgaWYgdGhlcmUncyBoaWdobGlnaHRlZCB0ZXh0XG4gICAgICAgIGlmIChoaWdobGlnaHRlZFRleHQgJiYgaGlnaGxpZ2h0ZWRUZXh0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBEaXNhbGxvdyBkcmFnZ2luZyBpZiBkcmF3ZXIgd2FzIHNjcm9sbGVkIHdpdGhpbiBgc2Nyb2xsTG9ja1RpbWVvdXRgXG4gICAgICAgIGlmIChsYXN0VGltZURyYWdQcmV2ZW50ZWQuY3VycmVudCAmJiBkYXRlLmdldFRpbWUoKSAtIGxhc3RUaW1lRHJhZ1ByZXZlbnRlZC5jdXJyZW50LmdldFRpbWUoKSA8IHNjcm9sbExvY2tUaW1lb3V0ICYmIHN3aXBlQW1vdW50ID09PSAwKSB7XG4gICAgICAgICAgICBsYXN0VGltZURyYWdQcmV2ZW50ZWQuY3VycmVudCA9IGRhdGU7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzRHJhZ2dpbmdJbkRpcmVjdGlvbikge1xuICAgICAgICAgICAgbGFzdFRpbWVEcmFnUHJldmVudGVkLmN1cnJlbnQgPSBkYXRlO1xuICAgICAgICAgICAgLy8gV2UgYXJlIGRyYWdnaW5nIGRvd24gc28gd2Ugc2hvdWxkIGFsbG93IHNjcm9sbGluZ1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIEtlZXAgY2xpbWJpbmcgdXAgdGhlIERPTSB0cmVlIGFzIGxvbmcgYXMgdGhlcmUncyBhIHBhcmVudFxuICAgICAgICB3aGlsZShlbGVtZW50KXtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSBlbGVtZW50IGlzIHNjcm9sbGFibGVcbiAgICAgICAgICAgIGlmIChlbGVtZW50LnNjcm9sbEhlaWdodCA+IGVsZW1lbnQuY2xpZW50SGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQuc2Nyb2xsVG9wICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RUaW1lRHJhZ1ByZXZlbnRlZC5jdXJyZW50ID0gbmV3IERhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGVsZW1lbnQgaXMgc2Nyb2xsYWJsZSBhbmQgbm90IHNjcm9sbGVkIHRvIHRoZSB0b3AsIHNvIGRvbid0IGRyYWdcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3JvbGUnKSA9PT0gJ2RpYWxvZycpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTW92ZSB1cCB0byB0aGUgcGFyZW50IGVsZW1lbnRcbiAgICAgICAgICAgIGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudE5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm8gc2Nyb2xsYWJsZSBwYXJlbnRzIG5vdCBzY3JvbGxlZCB0byB0aGUgdG9wIGZvdW5kLCBzbyBkcmFnXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvbkRyYWcoZXZlbnQpIHtcbiAgICAgICAgaWYgKCFkcmF3ZXJSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdlIG5lZWQgdG8ga25vdyBob3cgbXVjaCBvZiB0aGUgZHJhd2VyIGhhcyBiZWVuIGRyYWdnZWQgaW4gcGVyY2VudGFnZXMgc28gdGhhdCB3ZSBjYW4gdHJhbnNmb3JtIGJhY2tncm91bmQgYWNjb3JkaW5nbHlcbiAgICAgICAgaWYgKGlzRHJhZ2dpbmcpIHtcbiAgICAgICAgICAgIGNvbnN0IGRpcmVjdGlvbk11bHRpcGxpZXIgPSBkaXJlY3Rpb24gPT09ICdib3R0b20nIHx8IGRpcmVjdGlvbiA9PT0gJ3JpZ2h0JyA/IDEgOiAtMTtcbiAgICAgICAgICAgIGNvbnN0IGRyYWdnZWREaXN0YW5jZSA9IChwb2ludGVyU3RhcnQuY3VycmVudCAtIChpc1ZlcnRpY2FsKGRpcmVjdGlvbikgPyBldmVudC5wYWdlWSA6IGV2ZW50LnBhZ2VYKSkgKiBkaXJlY3Rpb25NdWx0aXBsaWVyO1xuICAgICAgICAgICAgY29uc3QgaXNEcmFnZ2luZ0luRGlyZWN0aW9uID0gZHJhZ2dlZERpc3RhbmNlID4gMDtcbiAgICAgICAgICAgIC8vIFByZSBjb25kaXRpb24gZm9yIGRpc2FsbG93aW5nIGRyYWdnaW5nIGluIHRoZSBjbG9zZSBkaXJlY3Rpb24uXG4gICAgICAgICAgICBjb25zdCBub0Nsb3NlU25hcFBvaW50c1ByZUNvbmRpdGlvbiA9IHNuYXBQb2ludHMgJiYgIWRpc21pc3NpYmxlICYmICFpc0RyYWdnaW5nSW5EaXJlY3Rpb247XG4gICAgICAgICAgICAvLyBEaXNhbGxvdyBkcmFnZ2luZyBkb3duIHRvIGNsb3NlIHdoZW4gZmlyc3Qgc25hcCBwb2ludCBpcyB0aGUgYWN0aXZlIG9uZSBhbmQgZGlzbWlzc2libGUgcHJvcCBpcyBzZXQgdG8gZmFsc2UuXG4gICAgICAgICAgICBpZiAobm9DbG9zZVNuYXBQb2ludHNQcmVDb25kaXRpb24gJiYgYWN0aXZlU25hcFBvaW50SW5kZXggPT09IDApIHJldHVybjtcbiAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gY2FwdHVyZSBsYXN0IHRpbWUgd2hlbiBkcmFnIHdpdGggc2Nyb2xsIHdhcyB0cmlnZ2VyZWQgYW5kIGhhdmUgYSB0aW1lb3V0IGJldHdlZW5cbiAgICAgICAgICAgIGNvbnN0IGFic0RyYWdnZWREaXN0YW5jZSA9IE1hdGguYWJzKGRyYWdnZWREaXN0YW5jZSk7XG4gICAgICAgICAgICBjb25zdCB3cmFwcGVyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignW2RhdGEtdmF1bC1kcmF3ZXItd3JhcHBlcl0nKTtcbiAgICAgICAgICAgIGNvbnN0IGRyYXdlckRpbWVuc2lvbiA9IGRpcmVjdGlvbiA9PT0gJ2JvdHRvbScgfHwgZGlyZWN0aW9uID09PSAndG9wJyA/IGRyYXdlckhlaWdodFJlZi5jdXJyZW50IDogZHJhd2VyV2lkdGhSZWYuY3VycmVudDtcbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgcGVyY2VudGFnZSBkcmFnZ2VkLCB3aGVyZSAxIGlzIHRoZSBjbG9zZWQgcG9zaXRpb25cbiAgICAgICAgICAgIGxldCBwZXJjZW50YWdlRHJhZ2dlZCA9IGFic0RyYWdnZWREaXN0YW5jZSAvIGRyYXdlckRpbWVuc2lvbjtcbiAgICAgICAgICAgIGNvbnN0IHNuYXBQb2ludFBlcmNlbnRhZ2VEcmFnZ2VkID0gZ2V0U25hcFBvaW50c1BlcmNlbnRhZ2VEcmFnZ2VkKGFic0RyYWdnZWREaXN0YW5jZSwgaXNEcmFnZ2luZ0luRGlyZWN0aW9uKTtcbiAgICAgICAgICAgIGlmIChzbmFwUG9pbnRQZXJjZW50YWdlRHJhZ2dlZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHBlcmNlbnRhZ2VEcmFnZ2VkID0gc25hcFBvaW50UGVyY2VudGFnZURyYWdnZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBEaXNhbGxvdyBjbG9zZSBkcmFnZ2luZyBiZXlvbmQgdGhlIHNtYWxsZXN0IHNuYXAgcG9pbnQuXG4gICAgICAgICAgICBpZiAobm9DbG9zZVNuYXBQb2ludHNQcmVDb25kaXRpb24gJiYgcGVyY2VudGFnZURyYWdnZWQgPj0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNBbGxvd2VkVG9EcmFnLmN1cnJlbnQgJiYgIXNob3VsZERyYWcoZXZlbnQudGFyZ2V0LCBpc0RyYWdnaW5nSW5EaXJlY3Rpb24pKSByZXR1cm47XG4gICAgICAgICAgICBkcmF3ZXJSZWYuY3VycmVudC5jbGFzc0xpc3QuYWRkKERSQUdfQ0xBU1MpO1xuICAgICAgICAgICAgLy8gSWYgc2hvdWxkRHJhZyBnYXZlIHRydWUgb25jZSBhZnRlciBwcmVzc2luZyBkb3duIG9uIHRoZSBkcmF3ZXIsIHdlIHNldCBpc0FsbG93ZWRUb0RyYWcgdG8gdHJ1ZSBhbmQgaXQgd2lsbCByZW1haW4gdHJ1ZSB1bnRpbCB3ZSBsZXQgZ28sIHRoZXJlJ3Mgbm8gcmVhc29uIHRvIGRpc2FibGUgZHJhZ2dpbmcgbWlkIHdheSwgZXZlciwgYW5kIHRoYXQncyB0aGUgc29sdXRpb24gdG8gaXRcbiAgICAgICAgICAgIGlzQWxsb3dlZFRvRHJhZy5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgIHNldChkcmF3ZXJSZWYuY3VycmVudCwge1xuICAgICAgICAgICAgICAgIHRyYW5zaXRpb246ICdub25lJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZXQob3ZlcmxheVJlZi5jdXJyZW50LCB7XG4gICAgICAgICAgICAgICAgdHJhbnNpdGlvbjogJ25vbmUnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChzbmFwUG9pbnRzKSB7XG4gICAgICAgICAgICAgICAgb25EcmFnU25hcFBvaW50cyh7XG4gICAgICAgICAgICAgICAgICAgIGRyYWdnZWREaXN0YW5jZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUnVuIHRoaXMgb25seSBpZiBzbmFwUG9pbnRzIGFyZSBub3QgZGVmaW5lZCBvciBpZiB3ZSBhcmUgYXQgdGhlIGxhc3Qgc25hcCBwb2ludCAoaGlnaGVzdCBvbmUpXG4gICAgICAgICAgICBpZiAoaXNEcmFnZ2luZ0luRGlyZWN0aW9uICYmICFzbmFwUG9pbnRzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGFtcGVuZWREcmFnZ2VkRGlzdGFuY2UgPSBkYW1wZW5WYWx1ZShkcmFnZ2VkRGlzdGFuY2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRyYW5zbGF0ZVZhbHVlID0gTWF0aC5taW4oZGFtcGVuZWREcmFnZ2VkRGlzdGFuY2UgKiAtMSwgMCkgKiBkaXJlY3Rpb25NdWx0aXBsaWVyO1xuICAgICAgICAgICAgICAgIHNldChkcmF3ZXJSZWYuY3VycmVudCwge1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IGlzVmVydGljYWwoZGlyZWN0aW9uKSA/IGB0cmFuc2xhdGUzZCgwLCAke3RyYW5zbGF0ZVZhbHVlfXB4LCAwKWAgOiBgdHJhbnNsYXRlM2QoJHt0cmFuc2xhdGVWYWx1ZX1weCwgMCwgMClgXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgb3BhY2l0eVZhbHVlID0gMSAtIHBlcmNlbnRhZ2VEcmFnZ2VkO1xuICAgICAgICAgICAgaWYgKHNob3VsZEZhZGUgfHwgZmFkZUZyb21JbmRleCAmJiBhY3RpdmVTbmFwUG9pbnRJbmRleCA9PT0gZmFkZUZyb21JbmRleCAtIDEpIHtcbiAgICAgICAgICAgICAgICBvbkRyYWdQcm9wID09IG51bGwgPyB2b2lkIDAgOiBvbkRyYWdQcm9wKGV2ZW50LCBwZXJjZW50YWdlRHJhZ2dlZCk7XG4gICAgICAgICAgICAgICAgc2V0KG92ZXJsYXlSZWYuY3VycmVudCwge1xuICAgICAgICAgICAgICAgICAgICBvcGFjaXR5OiBgJHtvcGFjaXR5VmFsdWV9YCxcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNpdGlvbjogJ25vbmUnXG4gICAgICAgICAgICAgICAgfSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAod3JhcHBlciAmJiBvdmVybGF5UmVmLmN1cnJlbnQgJiYgc2hvdWxkU2NhbGVCYWNrZ3JvdW5kKSB7XG4gICAgICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHBlcmNlbnRhZ2VEcmFnZ2VkIGFzIGEgZnJhY3Rpb24gKDAgdG8gMSlcbiAgICAgICAgICAgICAgICBjb25zdCBzY2FsZVZhbHVlID0gTWF0aC5taW4oZ2V0U2NhbGUoKSArIHBlcmNlbnRhZ2VEcmFnZ2VkICogKDEgLSBnZXRTY2FsZSgpKSwgMSk7XG4gICAgICAgICAgICAgICAgY29uc3QgYm9yZGVyUmFkaXVzVmFsdWUgPSA4IC0gcGVyY2VudGFnZURyYWdnZWQgKiA4O1xuICAgICAgICAgICAgICAgIGNvbnN0IHRyYW5zbGF0ZVZhbHVlID0gTWF0aC5tYXgoMCwgMTQgLSBwZXJjZW50YWdlRHJhZ2dlZCAqIDE0KTtcbiAgICAgICAgICAgICAgICBzZXQod3JhcHBlciwge1xuICAgICAgICAgICAgICAgICAgICBib3JkZXJSYWRpdXM6IGAke2JvcmRlclJhZGl1c1ZhbHVlfXB4YCxcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtOiBpc1ZlcnRpY2FsKGRpcmVjdGlvbikgPyBgc2NhbGUoJHtzY2FsZVZhbHVlfSkgdHJhbnNsYXRlM2QoMCwgJHt0cmFuc2xhdGVWYWx1ZX1weCwgMClgIDogYHNjYWxlKCR7c2NhbGVWYWx1ZX0pIHRyYW5zbGF0ZTNkKCR7dHJhbnNsYXRlVmFsdWV9cHgsIDAsIDApYCxcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNpdGlvbjogJ25vbmUnXG4gICAgICAgICAgICAgICAgfSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXNuYXBQb2ludHMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0cmFuc2xhdGVWYWx1ZSA9IGFic0RyYWdnZWREaXN0YW5jZSAqIGRpcmVjdGlvbk11bHRpcGxpZXI7XG4gICAgICAgICAgICAgICAgc2V0KGRyYXdlclJlZi5jdXJyZW50LCB7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogaXNWZXJ0aWNhbChkaXJlY3Rpb24pID8gYHRyYW5zbGF0ZTNkKDAsICR7dHJhbnNsYXRlVmFsdWV9cHgsIDApYCA6IGB0cmFuc2xhdGUzZCgke3RyYW5zbGF0ZVZhbHVlfXB4LCAwLCAwKWBcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBSZWFjdF9fZGVmYXVsdC51c2VFZmZlY3QoKCk9PntcbiAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKT0+e1xuICAgICAgICAgICAgc2hvdWxkQW5pbWF0ZS5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgfSwgW10pO1xuICAgIFJlYWN0X19kZWZhdWx0LnVzZUVmZmVjdCgoKT0+e1xuICAgICAgICB2YXIgX3dpbmRvd192aXN1YWxWaWV3cG9ydDtcbiAgICAgICAgZnVuY3Rpb24gb25WaXN1YWxWaWV3cG9ydENoYW5nZSgpIHtcbiAgICAgICAgICAgIGlmICghZHJhd2VyUmVmLmN1cnJlbnQgfHwgIXJlcG9zaXRpb25JbnB1dHMpIHJldHVybjtcbiAgICAgICAgICAgIGNvbnN0IGZvY3VzZWRFbGVtZW50ID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgICAgICAgICAgIGlmIChpc0lucHV0KGZvY3VzZWRFbGVtZW50KSB8fCBrZXlib2FyZElzT3Blbi5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIF93aW5kb3dfdmlzdWFsVmlld3BvcnQ7XG4gICAgICAgICAgICAgICAgY29uc3QgdmlzdWFsVmlld3BvcnRIZWlnaHQgPSAoKF93aW5kb3dfdmlzdWFsVmlld3BvcnQgPSB3aW5kb3cudmlzdWFsVmlld3BvcnQpID09IG51bGwgPyB2b2lkIDAgOiBfd2luZG93X3Zpc3VhbFZpZXdwb3J0LmhlaWdodCkgfHwgMDtcbiAgICAgICAgICAgICAgICBjb25zdCB0b3RhbEhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodDtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIHRoZSBoZWlnaHQgb2YgdGhlIGtleWJvYXJkXG4gICAgICAgICAgICAgICAgbGV0IGRpZmZGcm9tSW5pdGlhbCA9IHRvdGFsSGVpZ2h0IC0gdmlzdWFsVmlld3BvcnRIZWlnaHQ7XG4gICAgICAgICAgICAgICAgY29uc3QgZHJhd2VySGVpZ2h0ID0gZHJhd2VyUmVmLmN1cnJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0IHx8IDA7XG4gICAgICAgICAgICAgICAgLy8gQWRqdXN0IGRyYXdlciBoZWlnaHQgb25seSBpZiBpdCdzIHRhbGwgZW5vdWdoXG4gICAgICAgICAgICAgICAgY29uc3QgaXNUYWxsRW5vdWdoID0gZHJhd2VySGVpZ2h0ID4gdG90YWxIZWlnaHQgKiAwLjg7XG4gICAgICAgICAgICAgICAgaWYgKCFpbml0aWFsRHJhd2VySGVpZ2h0LmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5pdGlhbERyYXdlckhlaWdodC5jdXJyZW50ID0gZHJhd2VySGVpZ2h0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBvZmZzZXRGcm9tVG9wID0gZHJhd2VyUmVmLmN1cnJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wO1xuICAgICAgICAgICAgICAgIC8vIHZpc3VhbFZpZXdwb3J0IGhlaWdodCBtYXkgY2hhbmdlIGR1ZSB0byBzb21xIGUgc3VidGxlIGNoYW5nZXMgdG8gdGhlIGtleWJvYXJkLiBDaGVja2luZyBpZiB0aGUgaGVpZ2h0IGNoYW5nZWQgYnkgNjAgb3IgbW9yZSB3aWxsIG1ha2Ugc3VyZSB0aGF0IHRoZXkga2V5Ym9hcmQgcmVhbGx5IGNoYW5nZWQgaXRzIG9wZW4gc3RhdGUuXG4gICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKHByZXZpb3VzRGlmZkZyb21Jbml0aWFsLmN1cnJlbnQgLSBkaWZmRnJvbUluaXRpYWwpID4gNjApIHtcbiAgICAgICAgICAgICAgICAgICAga2V5Ym9hcmRJc09wZW4uY3VycmVudCA9ICFrZXlib2FyZElzT3Blbi5jdXJyZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc25hcFBvaW50cyAmJiBzbmFwUG9pbnRzLmxlbmd0aCA+IDAgJiYgc25hcFBvaW50c09mZnNldCAmJiBhY3RpdmVTbmFwUG9pbnRJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhY3RpdmVTbmFwUG9pbnRIZWlnaHQgPSBzbmFwUG9pbnRzT2Zmc2V0W2FjdGl2ZVNuYXBQb2ludEluZGV4XSB8fCAwO1xuICAgICAgICAgICAgICAgICAgICBkaWZmRnJvbUluaXRpYWwgKz0gYWN0aXZlU25hcFBvaW50SGVpZ2h0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwcmV2aW91c0RpZmZGcm9tSW5pdGlhbC5jdXJyZW50ID0gZGlmZkZyb21Jbml0aWFsO1xuICAgICAgICAgICAgICAgIC8vIFdlIGRvbid0IGhhdmUgdG8gY2hhbmdlIHRoZSBoZWlnaHQgaWYgdGhlIGlucHV0IGlzIGluIHZpZXcsIHdoZW4gd2UgYXJlIGhlcmUgd2UgYXJlIGluIHRoZSBvcGVuZWQga2V5Ym9hcmQgc3RhdGUgc28gd2UgY2FuIGNvcnJlY3RseSBjaGVjayBpZiB0aGUgaW5wdXQgaXMgaW4gdmlld1xuICAgICAgICAgICAgICAgIGlmIChkcmF3ZXJIZWlnaHQgPiB2aXN1YWxWaWV3cG9ydEhlaWdodCB8fCBrZXlib2FyZElzT3Blbi5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhlaWdodCA9IGRyYXdlclJlZi5jdXJyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5ld0RyYXdlckhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhlaWdodCA+IHZpc3VhbFZpZXdwb3J0SGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdEcmF3ZXJIZWlnaHQgPSB2aXN1YWxWaWV3cG9ydEhlaWdodCAtIChpc1RhbGxFbm91Z2ggPyBvZmZzZXRGcm9tVG9wIDogV0lORE9XX1RPUF9PRkZTRVQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFdoZW4gZml4ZWQsIGRvbid0IG1vdmUgdGhlIGRyYXdlciB1cHdhcmRzIGlmIHRoZXJlJ3Mgc3BhY2UsIGJ1dCByYXRoZXIgb25seSBjaGFuZ2UgaXQncyBoZWlnaHQgc28gaXQncyBmdWxseSBzY3JvbGxhYmxlIHdoZW4gdGhlIGtleWJvYXJkIGlzIG9wZW5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpeGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkcmF3ZXJSZWYuY3VycmVudC5zdHlsZS5oZWlnaHQgPSBgJHtoZWlnaHQgLSBNYXRoLm1heChkaWZmRnJvbUluaXRpYWwsIDApfXB4YDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyYXdlclJlZi5jdXJyZW50LnN0eWxlLmhlaWdodCA9IGAke01hdGgubWF4KG5ld0RyYXdlckhlaWdodCwgdmlzdWFsVmlld3BvcnRIZWlnaHQgLSBvZmZzZXRGcm9tVG9wKX1weGA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFpc01vYmlsZUZpcmVmb3goKSkge1xuICAgICAgICAgICAgICAgICAgICBkcmF3ZXJSZWYuY3VycmVudC5zdHlsZS5oZWlnaHQgPSBgJHtpbml0aWFsRHJhd2VySGVpZ2h0LmN1cnJlbnR9cHhgO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc25hcFBvaW50cyAmJiBzbmFwUG9pbnRzLmxlbmd0aCA+IDAgJiYgIWtleWJvYXJkSXNPcGVuLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgZHJhd2VyUmVmLmN1cnJlbnQuc3R5bGUuYm90dG9tID0gYDBweGA7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTmVnYXRpdmUgYm90dG9tIHZhbHVlIHdvdWxkIG5ldmVyIG1ha2Ugc2Vuc2VcbiAgICAgICAgICAgICAgICAgICAgZHJhd2VyUmVmLmN1cnJlbnQuc3R5bGUuYm90dG9tID0gYCR7TWF0aC5tYXgoZGlmZkZyb21Jbml0aWFsLCAwKX1weGA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIChfd2luZG93X3Zpc3VhbFZpZXdwb3J0ID0gd2luZG93LnZpc3VhbFZpZXdwb3J0KSA9PSBudWxsID8gdm9pZCAwIDogX3dpbmRvd192aXN1YWxWaWV3cG9ydC5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBvblZpc3VhbFZpZXdwb3J0Q2hhbmdlKTtcbiAgICAgICAgcmV0dXJuICgpPT57XG4gICAgICAgICAgICB2YXIgX3dpbmRvd192aXN1YWxWaWV3cG9ydDtcbiAgICAgICAgICAgIHJldHVybiAoX3dpbmRvd192aXN1YWxWaWV3cG9ydCA9IHdpbmRvdy52aXN1YWxWaWV3cG9ydCkgPT0gbnVsbCA/IHZvaWQgMCA6IF93aW5kb3dfdmlzdWFsVmlld3BvcnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgb25WaXN1YWxWaWV3cG9ydENoYW5nZSk7XG4gICAgICAgIH07XG4gICAgfSwgW1xuICAgICAgICBhY3RpdmVTbmFwUG9pbnRJbmRleCxcbiAgICAgICAgc25hcFBvaW50cyxcbiAgICAgICAgc25hcFBvaW50c09mZnNldFxuICAgIF0pO1xuICAgIGZ1bmN0aW9uIGNsb3NlRHJhd2VyKGZyb21XaXRoaW4pIHtcbiAgICAgICAgY2FuY2VsRHJhZygpO1xuICAgICAgICBvbkNsb3NlID09IG51bGwgPyB2b2lkIDAgOiBvbkNsb3NlKCk7XG4gICAgICAgIGlmICghZnJvbVdpdGhpbikge1xuICAgICAgICAgICAgc2V0SXNPcGVuKGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBzZXRUaW1lb3V0KCgpPT57XG4gICAgICAgICAgICBpZiAoc25hcFBvaW50cykge1xuICAgICAgICAgICAgICAgIHNldEFjdGl2ZVNuYXBQb2ludChzbmFwUG9pbnRzWzBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgVFJBTlNJVElPTlMuRFVSQVRJT04gKiAxMDAwKTsgLy8gc2Vjb25kcyB0byBtc1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXNldERyYXdlcigpIHtcbiAgICAgICAgaWYgKCFkcmF3ZXJSZWYuY3VycmVudCkgcmV0dXJuO1xuICAgICAgICBjb25zdCB3cmFwcGVyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignW2RhdGEtdmF1bC1kcmF3ZXItd3JhcHBlcl0nKTtcbiAgICAgICAgY29uc3QgY3VycmVudFN3aXBlQW1vdW50ID0gZ2V0VHJhbnNsYXRlKGRyYXdlclJlZi5jdXJyZW50LCBkaXJlY3Rpb24pO1xuICAgICAgICBzZXQoZHJhd2VyUmVmLmN1cnJlbnQsIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKDAsIDAsIDApJyxcbiAgICAgICAgICAgIHRyYW5zaXRpb246IGB0cmFuc2Zvcm0gJHtUUkFOU0lUSU9OUy5EVVJBVElPTn1zIGN1YmljLWJlemllcigke1RSQU5TSVRJT05TLkVBU0Uuam9pbignLCcpfSlgXG4gICAgICAgIH0pO1xuICAgICAgICBzZXQob3ZlcmxheVJlZi5jdXJyZW50LCB7XG4gICAgICAgICAgICB0cmFuc2l0aW9uOiBgb3BhY2l0eSAke1RSQU5TSVRJT05TLkRVUkFUSU9OfXMgY3ViaWMtYmV6aWVyKCR7VFJBTlNJVElPTlMuRUFTRS5qb2luKCcsJyl9KWAsXG4gICAgICAgICAgICBvcGFjaXR5OiAnMSdcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIERvbid0IHJlc2V0IGJhY2tncm91bmQgaWYgc3dpcGVkIHVwd2FyZHNcbiAgICAgICAgaWYgKHNob3VsZFNjYWxlQmFja2dyb3VuZCAmJiBjdXJyZW50U3dpcGVBbW91bnQgJiYgY3VycmVudFN3aXBlQW1vdW50ID4gMCAmJiBpc09wZW4pIHtcbiAgICAgICAgICAgIHNldCh3cmFwcGVyLCB7XG4gICAgICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiBgJHtCT1JERVJfUkFESVVTfXB4YCxcbiAgICAgICAgICAgICAgICBvdmVyZmxvdzogJ2hpZGRlbicsXG4gICAgICAgICAgICAgICAgLi4uaXNWZXJ0aWNhbChkaXJlY3Rpb24pID8ge1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IGBzY2FsZSgke2dldFNjYWxlKCl9KSB0cmFuc2xhdGUzZCgwLCBjYWxjKGVudihzYWZlLWFyZWEtaW5zZXQtdG9wKSArIDE0cHgpLCAwKWAsXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybU9yaWdpbjogJ3RvcCdcbiAgICAgICAgICAgICAgICB9IDoge1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IGBzY2FsZSgke2dldFNjYWxlKCl9KSB0cmFuc2xhdGUzZChjYWxjKGVudihzYWZlLWFyZWEtaW5zZXQtdG9wKSArIDE0cHgpLCAwLCAwKWAsXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybU9yaWdpbjogJ2xlZnQnXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB0cmFuc2l0aW9uUHJvcGVydHk6ICd0cmFuc2Zvcm0sIGJvcmRlci1yYWRpdXMnLFxuICAgICAgICAgICAgICAgIHRyYW5zaXRpb25EdXJhdGlvbjogYCR7VFJBTlNJVElPTlMuRFVSQVRJT059c2AsXG4gICAgICAgICAgICAgICAgdHJhbnNpdGlvblRpbWluZ0Z1bmN0aW9uOiBgY3ViaWMtYmV6aWVyKCR7VFJBTlNJVElPTlMuRUFTRS5qb2luKCcsJyl9KWBcbiAgICAgICAgICAgIH0sIHRydWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNhbmNlbERyYWcoKSB7XG4gICAgICAgIGlmICghaXNEcmFnZ2luZyB8fCAhZHJhd2VyUmVmLmN1cnJlbnQpIHJldHVybjtcbiAgICAgICAgZHJhd2VyUmVmLmN1cnJlbnQuY2xhc3NMaXN0LnJlbW92ZShEUkFHX0NMQVNTKTtcbiAgICAgICAgaXNBbGxvd2VkVG9EcmFnLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgc2V0SXNEcmFnZ2luZyhmYWxzZSk7XG4gICAgICAgIGRyYWdFbmRUaW1lLmN1cnJlbnQgPSBuZXcgRGF0ZSgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvblJlbGVhc2UoZXZlbnQpIHtcbiAgICAgICAgaWYgKCFpc0RyYWdnaW5nIHx8ICFkcmF3ZXJSZWYuY3VycmVudCkgcmV0dXJuO1xuICAgICAgICBkcmF3ZXJSZWYuY3VycmVudC5jbGFzc0xpc3QucmVtb3ZlKERSQUdfQ0xBU1MpO1xuICAgICAgICBpc0FsbG93ZWRUb0RyYWcuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICBzZXRJc0RyYWdnaW5nKGZhbHNlKTtcbiAgICAgICAgZHJhZ0VuZFRpbWUuY3VycmVudCA9IG5ldyBEYXRlKCk7XG4gICAgICAgIGNvbnN0IHN3aXBlQW1vdW50ID0gZ2V0VHJhbnNsYXRlKGRyYXdlclJlZi5jdXJyZW50LCBkaXJlY3Rpb24pO1xuICAgICAgICBpZiAoIWV2ZW50IHx8ICFzaG91bGREcmFnKGV2ZW50LnRhcmdldCwgZmFsc2UpIHx8ICFzd2lwZUFtb3VudCB8fCBOdW1iZXIuaXNOYU4oc3dpcGVBbW91bnQpKSByZXR1cm47XG4gICAgICAgIGlmIChkcmFnU3RhcnRUaW1lLmN1cnJlbnQgPT09IG51bGwpIHJldHVybjtcbiAgICAgICAgY29uc3QgdGltZVRha2VuID0gZHJhZ0VuZFRpbWUuY3VycmVudC5nZXRUaW1lKCkgLSBkcmFnU3RhcnRUaW1lLmN1cnJlbnQuZ2V0VGltZSgpO1xuICAgICAgICBjb25zdCBkaXN0TW92ZWQgPSBwb2ludGVyU3RhcnQuY3VycmVudCAtIChpc1ZlcnRpY2FsKGRpcmVjdGlvbikgPyBldmVudC5wYWdlWSA6IGV2ZW50LnBhZ2VYKTtcbiAgICAgICAgY29uc3QgdmVsb2NpdHkgPSBNYXRoLmFicyhkaXN0TW92ZWQpIC8gdGltZVRha2VuO1xuICAgICAgICBpZiAodmVsb2NpdHkgPiAwLjA1KSB7XG4gICAgICAgICAgICAvLyBganVzdFJlbGVhc2VkYCBpcyBuZWVkZWQgdG8gcHJldmVudCB0aGUgZHJhd2VyIGZyb20gZm9jdXNpbmcgb24gYW4gaW5wdXQgd2hlbiB0aGUgZHJhZyBlbmRzLCBhcyBpdCdzIG5vdCB0aGUgaW50ZW50IG1vc3Qgb2YgdGhlIHRpbWUuXG4gICAgICAgICAgICBzZXRKdXN0UmVsZWFzZWQodHJ1ZSk7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpPT57XG4gICAgICAgICAgICAgICAgc2V0SnVzdFJlbGVhc2VkKGZhbHNlKTtcbiAgICAgICAgICAgIH0sIDIwMCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNuYXBQb2ludHMpIHtcbiAgICAgICAgICAgIGNvbnN0IGRpcmVjdGlvbk11bHRpcGxpZXIgPSBkaXJlY3Rpb24gPT09ICdib3R0b20nIHx8IGRpcmVjdGlvbiA9PT0gJ3JpZ2h0JyA/IDEgOiAtMTtcbiAgICAgICAgICAgIG9uUmVsZWFzZVNuYXBQb2ludHMoe1xuICAgICAgICAgICAgICAgIGRyYWdnZWREaXN0YW5jZTogZGlzdE1vdmVkICogZGlyZWN0aW9uTXVsdGlwbGllcixcbiAgICAgICAgICAgICAgICBjbG9zZURyYXdlcixcbiAgICAgICAgICAgICAgICB2ZWxvY2l0eSxcbiAgICAgICAgICAgICAgICBkaXNtaXNzaWJsZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBvblJlbGVhc2VQcm9wID09IG51bGwgPyB2b2lkIDAgOiBvblJlbGVhc2VQcm9wKGV2ZW50LCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBNb3ZlZCB1cHdhcmRzLCBkb24ndCBkbyBhbnl0aGluZ1xuICAgICAgICBpZiAoZGlyZWN0aW9uID09PSAnYm90dG9tJyB8fCBkaXJlY3Rpb24gPT09ICdyaWdodCcgPyBkaXN0TW92ZWQgPiAwIDogZGlzdE1vdmVkIDwgMCkge1xuICAgICAgICAgICAgcmVzZXREcmF3ZXIoKTtcbiAgICAgICAgICAgIG9uUmVsZWFzZVByb3AgPT0gbnVsbCA/IHZvaWQgMCA6IG9uUmVsZWFzZVByb3AoZXZlbnQsIHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2ZWxvY2l0eSA+IFZFTE9DSVRZX1RIUkVTSE9MRCkge1xuICAgICAgICAgICAgY2xvc2VEcmF3ZXIoKTtcbiAgICAgICAgICAgIG9uUmVsZWFzZVByb3AgPT0gbnVsbCA/IHZvaWQgMCA6IG9uUmVsZWFzZVByb3AoZXZlbnQsIGZhbHNlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgX2RyYXdlclJlZl9jdXJyZW50X2dldEJvdW5kaW5nQ2xpZW50UmVjdF9oZWlnaHQ7XG4gICAgICAgIGNvbnN0IHZpc2libGVEcmF3ZXJIZWlnaHQgPSBNYXRoLm1pbigoX2RyYXdlclJlZl9jdXJyZW50X2dldEJvdW5kaW5nQ2xpZW50UmVjdF9oZWlnaHQgPSBkcmF3ZXJSZWYuY3VycmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQpICE9IG51bGwgPyBfZHJhd2VyUmVmX2N1cnJlbnRfZ2V0Qm91bmRpbmdDbGllbnRSZWN0X2hlaWdodCA6IDAsIHdpbmRvdy5pbm5lckhlaWdodCk7XG4gICAgICAgIHZhciBfZHJhd2VyUmVmX2N1cnJlbnRfZ2V0Qm91bmRpbmdDbGllbnRSZWN0X3dpZHRoO1xuICAgICAgICBjb25zdCB2aXNpYmxlRHJhd2VyV2lkdGggPSBNYXRoLm1pbigoX2RyYXdlclJlZl9jdXJyZW50X2dldEJvdW5kaW5nQ2xpZW50UmVjdF93aWR0aCA9IGRyYXdlclJlZi5jdXJyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoKSAhPSBudWxsID8gX2RyYXdlclJlZl9jdXJyZW50X2dldEJvdW5kaW5nQ2xpZW50UmVjdF93aWR0aCA6IDAsIHdpbmRvdy5pbm5lcldpZHRoKTtcbiAgICAgICAgY29uc3QgaXNIb3Jpem9udGFsU3dpcGUgPSBkaXJlY3Rpb24gPT09ICdsZWZ0JyB8fCBkaXJlY3Rpb24gPT09ICdyaWdodCc7XG4gICAgICAgIGlmIChNYXRoLmFicyhzd2lwZUFtb3VudCkgPj0gKGlzSG9yaXpvbnRhbFN3aXBlID8gdmlzaWJsZURyYXdlcldpZHRoIDogdmlzaWJsZURyYXdlckhlaWdodCkgKiBjbG9zZVRocmVzaG9sZCkge1xuICAgICAgICAgICAgY2xvc2VEcmF3ZXIoKTtcbiAgICAgICAgICAgIG9uUmVsZWFzZVByb3AgPT0gbnVsbCA/IHZvaWQgMCA6IG9uUmVsZWFzZVByb3AoZXZlbnQsIGZhbHNlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBvblJlbGVhc2VQcm9wID09IG51bGwgPyB2b2lkIDAgOiBvblJlbGVhc2VQcm9wKGV2ZW50LCB0cnVlKTtcbiAgICAgICAgcmVzZXREcmF3ZXIoKTtcbiAgICB9XG4gICAgUmVhY3RfX2RlZmF1bHQudXNlRWZmZWN0KCgpPT57XG4gICAgICAgIC8vIFRyaWdnZXIgZW50ZXIgYW5pbWF0aW9uIHdpdGhvdXQgdXNpbmcgQ1NTIGFuaW1hdGlvblxuICAgICAgICBpZiAoaXNPcGVuKSB7XG4gICAgICAgICAgICBzZXQoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCB7XG4gICAgICAgICAgICAgICAgc2Nyb2xsQmVoYXZpb3I6ICdhdXRvJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBvcGVuVGltZS5jdXJyZW50ID0gbmV3IERhdGUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKCk9PntcbiAgICAgICAgICAgIHJlc2V0KGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgJ3Njcm9sbEJlaGF2aW9yJyk7XG4gICAgICAgIH07XG4gICAgfSwgW1xuICAgICAgICBpc09wZW5cbiAgICBdKTtcbiAgICBmdW5jdGlvbiBvbk5lc3RlZE9wZW5DaGFuZ2Uobykge1xuICAgICAgICBjb25zdCBzY2FsZSA9IG8gPyAod2luZG93LmlubmVyV2lkdGggLSBORVNURURfRElTUExBQ0VNRU5UKSAvIHdpbmRvdy5pbm5lcldpZHRoIDogMTtcbiAgICAgICAgY29uc3QgaW5pdGlhbFRyYW5zbGF0ZSA9IG8gPyAtTkVTVEVEX0RJU1BMQUNFTUVOVCA6IDA7XG4gICAgICAgIGlmIChuZXN0ZWRPcGVuQ2hhbmdlVGltZXIuY3VycmVudCkge1xuICAgICAgICAgICAgd2luZG93LmNsZWFyVGltZW91dChuZXN0ZWRPcGVuQ2hhbmdlVGltZXIuY3VycmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0KGRyYXdlclJlZi5jdXJyZW50LCB7XG4gICAgICAgICAgICB0cmFuc2l0aW9uOiBgdHJhbnNmb3JtICR7VFJBTlNJVElPTlMuRFVSQVRJT059cyBjdWJpYy1iZXppZXIoJHtUUkFOU0lUSU9OUy5FQVNFLmpvaW4oJywnKX0pYCxcbiAgICAgICAgICAgIHRyYW5zZm9ybTogaXNWZXJ0aWNhbChkaXJlY3Rpb24pID8gYHNjYWxlKCR7c2NhbGV9KSB0cmFuc2xhdGUzZCgwLCAke2luaXRpYWxUcmFuc2xhdGV9cHgsIDApYCA6IGBzY2FsZSgke3NjYWxlfSkgdHJhbnNsYXRlM2QoJHtpbml0aWFsVHJhbnNsYXRlfXB4LCAwLCAwKWBcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghbyAmJiBkcmF3ZXJSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgbmVzdGVkT3BlbkNoYW5nZVRpbWVyLmN1cnJlbnQgPSBzZXRUaW1lb3V0KCgpPT57XG4gICAgICAgICAgICAgICAgY29uc3QgdHJhbnNsYXRlVmFsdWUgPSBnZXRUcmFuc2xhdGUoZHJhd2VyUmVmLmN1cnJlbnQsIGRpcmVjdGlvbik7XG4gICAgICAgICAgICAgICAgc2V0KGRyYXdlclJlZi5jdXJyZW50LCB7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb246ICdub25lJyxcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtOiBpc1ZlcnRpY2FsKGRpcmVjdGlvbikgPyBgdHJhbnNsYXRlM2QoMCwgJHt0cmFuc2xhdGVWYWx1ZX1weCwgMClgIDogYHRyYW5zbGF0ZTNkKCR7dHJhbnNsYXRlVmFsdWV9cHgsIDAsIDApYFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgNTAwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBvbk5lc3RlZERyYWcoX2V2ZW50LCBwZXJjZW50YWdlRHJhZ2dlZCkge1xuICAgICAgICBpZiAocGVyY2VudGFnZURyYWdnZWQgPCAwKSByZXR1cm47XG4gICAgICAgIGNvbnN0IGluaXRpYWxTY2FsZSA9ICh3aW5kb3cuaW5uZXJXaWR0aCAtIE5FU1RFRF9ESVNQTEFDRU1FTlQpIC8gd2luZG93LmlubmVyV2lkdGg7XG4gICAgICAgIGNvbnN0IG5ld1NjYWxlID0gaW5pdGlhbFNjYWxlICsgcGVyY2VudGFnZURyYWdnZWQgKiAoMSAtIGluaXRpYWxTY2FsZSk7XG4gICAgICAgIGNvbnN0IG5ld1RyYW5zbGF0ZSA9IC1ORVNURURfRElTUExBQ0VNRU5UICsgcGVyY2VudGFnZURyYWdnZWQgKiBORVNURURfRElTUExBQ0VNRU5UO1xuICAgICAgICBzZXQoZHJhd2VyUmVmLmN1cnJlbnQsIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogaXNWZXJ0aWNhbChkaXJlY3Rpb24pID8gYHNjYWxlKCR7bmV3U2NhbGV9KSB0cmFuc2xhdGUzZCgwLCAke25ld1RyYW5zbGF0ZX1weCwgMClgIDogYHNjYWxlKCR7bmV3U2NhbGV9KSB0cmFuc2xhdGUzZCgke25ld1RyYW5zbGF0ZX1weCwgMCwgMClgLFxuICAgICAgICAgICAgdHJhbnNpdGlvbjogJ25vbmUnXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvbk5lc3RlZFJlbGVhc2UoX2V2ZW50LCBvKSB7XG4gICAgICAgIGNvbnN0IGRpbSA9IGlzVmVydGljYWwoZGlyZWN0aW9uKSA/IHdpbmRvdy5pbm5lckhlaWdodCA6IHdpbmRvdy5pbm5lcldpZHRoO1xuICAgICAgICBjb25zdCBzY2FsZSA9IG8gPyAoZGltIC0gTkVTVEVEX0RJU1BMQUNFTUVOVCkgLyBkaW0gOiAxO1xuICAgICAgICBjb25zdCB0cmFuc2xhdGUgPSBvID8gLU5FU1RFRF9ESVNQTEFDRU1FTlQgOiAwO1xuICAgICAgICBpZiAobykge1xuICAgICAgICAgICAgc2V0KGRyYXdlclJlZi5jdXJyZW50LCB7XG4gICAgICAgICAgICAgICAgdHJhbnNpdGlvbjogYHRyYW5zZm9ybSAke1RSQU5TSVRJT05TLkRVUkFUSU9OfXMgY3ViaWMtYmV6aWVyKCR7VFJBTlNJVElPTlMuRUFTRS5qb2luKCcsJyl9KWAsXG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtOiBpc1ZlcnRpY2FsKGRpcmVjdGlvbikgPyBgc2NhbGUoJHtzY2FsZX0pIHRyYW5zbGF0ZTNkKDAsICR7dHJhbnNsYXRlfXB4LCAwKWAgOiBgc2NhbGUoJHtzY2FsZX0pIHRyYW5zbGF0ZTNkKCR7dHJhbnNsYXRlfXB4LCAwLCAwKWBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIFJlYWN0X19kZWZhdWx0LnVzZUVmZmVjdCgoKT0+e1xuICAgICAgICBpZiAoIW1vZGFsKSB7XG4gICAgICAgICAgICAvLyBOZWVkIHRvIGRvIHRoaXMgbWFudWFsbHkgdW5mb3J0dW5hdGVseVxuICAgICAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKT0+e1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuc3R5bGUucG9pbnRlckV2ZW50cyA9ICdhdXRvJztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSwgW1xuICAgICAgICBtb2RhbFxuICAgIF0pO1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoRGlhbG9nUHJpbWl0aXZlLlJvb3QsIHtcbiAgICAgICAgZGVmYXVsdE9wZW46IGRlZmF1bHRPcGVuLFxuICAgICAgICBvbk9wZW5DaGFuZ2U6IChvcGVuKT0+e1xuICAgICAgICAgICAgaWYgKCFkaXNtaXNzaWJsZSAmJiAhb3BlbikgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKG9wZW4pIHtcbiAgICAgICAgICAgICAgICBzZXRIYXNCZWVuT3BlbmVkKHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjbG9zZURyYXdlcih0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldElzT3BlbihvcGVuKTtcbiAgICAgICAgfSxcbiAgICAgICAgb3BlbjogaXNPcGVuXG4gICAgfSwgLyojX19QVVJFX18qLyBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KERyYXdlckNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgIGFjdGl2ZVNuYXBQb2ludCxcbiAgICAgICAgICAgIHNuYXBQb2ludHMsXG4gICAgICAgICAgICBzZXRBY3RpdmVTbmFwUG9pbnQsXG4gICAgICAgICAgICBkcmF3ZXJSZWYsXG4gICAgICAgICAgICBvdmVybGF5UmVmLFxuICAgICAgICAgICAgb25PcGVuQ2hhbmdlLFxuICAgICAgICAgICAgb25QcmVzcyxcbiAgICAgICAgICAgIG9uUmVsZWFzZSxcbiAgICAgICAgICAgIG9uRHJhZyxcbiAgICAgICAgICAgIGRpc21pc3NpYmxlLFxuICAgICAgICAgICAgc2hvdWxkQW5pbWF0ZSxcbiAgICAgICAgICAgIGhhbmRsZU9ubHksXG4gICAgICAgICAgICBpc09wZW4sXG4gICAgICAgICAgICBpc0RyYWdnaW5nLFxuICAgICAgICAgICAgc2hvdWxkRmFkZSxcbiAgICAgICAgICAgIGNsb3NlRHJhd2VyLFxuICAgICAgICAgICAgb25OZXN0ZWREcmFnLFxuICAgICAgICAgICAgb25OZXN0ZWRPcGVuQ2hhbmdlLFxuICAgICAgICAgICAgb25OZXN0ZWRSZWxlYXNlLFxuICAgICAgICAgICAga2V5Ym9hcmRJc09wZW4sXG4gICAgICAgICAgICBtb2RhbCxcbiAgICAgICAgICAgIHNuYXBQb2ludHNPZmZzZXQsXG4gICAgICAgICAgICBhY3RpdmVTbmFwUG9pbnRJbmRleCxcbiAgICAgICAgICAgIGRpcmVjdGlvbixcbiAgICAgICAgICAgIHNob3VsZFNjYWxlQmFja2dyb3VuZCxcbiAgICAgICAgICAgIHNldEJhY2tncm91bmRDb2xvck9uU2NhbGUsXG4gICAgICAgICAgICBub0JvZHlTdHlsZXMsXG4gICAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgICBhdXRvRm9jdXNcbiAgICAgICAgfVxuICAgIH0sIGNoaWxkcmVuKSk7XG59XG5jb25zdCBPdmVybGF5ID0gLyojX19QVVJFX18qLyBSZWFjdF9fZGVmYXVsdC5mb3J3YXJkUmVmKGZ1bmN0aW9uKHsgLi4ucmVzdCB9LCByZWYpIHtcbiAgICBjb25zdCB7IG92ZXJsYXlSZWYsIHNuYXBQb2ludHMsIG9uUmVsZWFzZSwgc2hvdWxkRmFkZSwgaXNPcGVuLCBtb2RhbCwgc2hvdWxkQW5pbWF0ZSB9ID0gdXNlRHJhd2VyQ29udGV4dCgpO1xuICAgIGNvbnN0IGNvbXBvc2VkUmVmID0gdXNlQ29tcG9zZWRSZWZzKHJlZiwgb3ZlcmxheVJlZik7XG4gICAgY29uc3QgaGFzU25hcFBvaW50cyA9IHNuYXBQb2ludHMgJiYgc25hcFBvaW50cy5sZW5ndGggPiAwO1xuICAgIC8vIE92ZXJsYXkgaXMgdGhlIGNvbXBvbmVudCB0aGF0IGlzIGxvY2tpbmcgc2Nyb2xsLCByZW1vdmluZyBpdCB3aWxsIHVubG9jayB0aGUgc2Nyb2xsIHdpdGhvdXQgaGF2aW5nIHRvIGRpZyBpbnRvIFJhZGl4J3MgRGlhbG9nIGxpYnJhcnlcbiAgICBpZiAoIW1vZGFsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBvbk1vdXNlVXAgPSBSZWFjdF9fZGVmYXVsdC51c2VDYWxsYmFjaygoZXZlbnQpPT5vblJlbGVhc2UoZXZlbnQpLCBbXG4gICAgICAgIG9uUmVsZWFzZVxuICAgIF0pO1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoRGlhbG9nUHJpbWl0aXZlLk92ZXJsYXksIHtcbiAgICAgICAgb25Nb3VzZVVwOiBvbk1vdXNlVXAsXG4gICAgICAgIHJlZjogY29tcG9zZWRSZWYsXG4gICAgICAgIFwiZGF0YS12YXVsLW92ZXJsYXlcIjogXCJcIixcbiAgICAgICAgXCJkYXRhLXZhdWwtc25hcC1wb2ludHNcIjogaXNPcGVuICYmIGhhc1NuYXBQb2ludHMgPyAndHJ1ZScgOiAnZmFsc2UnLFxuICAgICAgICBcImRhdGEtdmF1bC1zbmFwLXBvaW50cy1vdmVybGF5XCI6IGlzT3BlbiAmJiBzaG91bGRGYWRlID8gJ3RydWUnIDogJ2ZhbHNlJyxcbiAgICAgICAgXCJkYXRhLXZhdWwtYW5pbWF0ZVwiOiAoc2hvdWxkQW5pbWF0ZSA9PSBudWxsID8gdm9pZCAwIDogc2hvdWxkQW5pbWF0ZS5jdXJyZW50KSA/ICd0cnVlJyA6ICdmYWxzZScsXG4gICAgICAgIC4uLnJlc3RcbiAgICB9KTtcbn0pO1xuT3ZlcmxheS5kaXNwbGF5TmFtZSA9ICdEcmF3ZXIuT3ZlcmxheSc7XG5jb25zdCBDb250ZW50ID0gLyojX19QVVJFX18qLyBSZWFjdF9fZGVmYXVsdC5mb3J3YXJkUmVmKGZ1bmN0aW9uKHsgb25Qb2ludGVyRG93bk91dHNpZGUsIHN0eWxlLCBvbk9wZW5BdXRvRm9jdXMsIC4uLnJlc3QgfSwgcmVmKSB7XG4gICAgY29uc3QgeyBkcmF3ZXJSZWYsIG9uUHJlc3MsIG9uUmVsZWFzZSwgb25EcmFnLCBrZXlib2FyZElzT3Blbiwgc25hcFBvaW50c09mZnNldCwgYWN0aXZlU25hcFBvaW50SW5kZXgsIG1vZGFsLCBpc09wZW4sIGRpcmVjdGlvbiwgc25hcFBvaW50cywgY29udGFpbmVyLCBoYW5kbGVPbmx5LCBzaG91bGRBbmltYXRlLCBhdXRvRm9jdXMgfSA9IHVzZURyYXdlckNvbnRleHQoKTtcbiAgICAvLyBOZWVkZWQgdG8gdXNlIHRyYW5zaXRpb24gaW5zdGVhZCBvZiBhbmltYXRpb25zXG4gICAgY29uc3QgW2RlbGF5ZWRTbmFwUG9pbnRzLCBzZXREZWxheWVkU25hcFBvaW50c10gPSBSZWFjdF9fZGVmYXVsdC51c2VTdGF0ZShmYWxzZSk7XG4gICAgY29uc3QgY29tcG9zZWRSZWYgPSB1c2VDb21wb3NlZFJlZnMocmVmLCBkcmF3ZXJSZWYpO1xuICAgIGNvbnN0IHBvaW50ZXJTdGFydFJlZiA9IFJlYWN0X19kZWZhdWx0LnVzZVJlZihudWxsKTtcbiAgICBjb25zdCBsYXN0S25vd25Qb2ludGVyRXZlbnRSZWYgPSBSZWFjdF9fZGVmYXVsdC51c2VSZWYobnVsbCk7XG4gICAgY29uc3Qgd2FzQmV5b25kVGhlUG9pbnRSZWYgPSBSZWFjdF9fZGVmYXVsdC51c2VSZWYoZmFsc2UpO1xuICAgIGNvbnN0IGhhc1NuYXBQb2ludHMgPSBzbmFwUG9pbnRzICYmIHNuYXBQb2ludHMubGVuZ3RoID4gMDtcbiAgICB1c2VTY2FsZUJhY2tncm91bmQoKTtcbiAgICBjb25zdCBpc0RlbHRhSW5EaXJlY3Rpb24gPSAoZGVsdGEsIGRpcmVjdGlvbiwgdGhyZXNob2xkID0gMCk9PntcbiAgICAgICAgaWYgKHdhc0JleW9uZFRoZVBvaW50UmVmLmN1cnJlbnQpIHJldHVybiB0cnVlO1xuICAgICAgICBjb25zdCBkZWx0YVkgPSBNYXRoLmFicyhkZWx0YS55KTtcbiAgICAgICAgY29uc3QgZGVsdGFYID0gTWF0aC5hYnMoZGVsdGEueCk7XG4gICAgICAgIGNvbnN0IGlzRGVsdGFYID0gZGVsdGFYID4gZGVsdGFZO1xuICAgICAgICBjb25zdCBkRmFjdG9yID0gW1xuICAgICAgICAgICAgJ2JvdHRvbScsXG4gICAgICAgICAgICAncmlnaHQnXG4gICAgICAgIF0uaW5jbHVkZXMoZGlyZWN0aW9uKSA/IDEgOiAtMTtcbiAgICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gJ2xlZnQnIHx8IGRpcmVjdGlvbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICAgICAgY29uc3QgaXNSZXZlcnNlRGlyZWN0aW9uID0gZGVsdGEueCAqIGRGYWN0b3IgPCAwO1xuICAgICAgICAgICAgaWYgKCFpc1JldmVyc2VEaXJlY3Rpb24gJiYgZGVsdGFYID49IDAgJiYgZGVsdGFYIDw9IHRocmVzaG9sZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc0RlbHRhWDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGlzUmV2ZXJzZURpcmVjdGlvbiA9IGRlbHRhLnkgKiBkRmFjdG9yIDwgMDtcbiAgICAgICAgICAgIGlmICghaXNSZXZlcnNlRGlyZWN0aW9uICYmIGRlbHRhWSA+PSAwICYmIGRlbHRhWSA8PSB0aHJlc2hvbGQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gIWlzRGVsdGFYO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHdhc0JleW9uZFRoZVBvaW50UmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIFJlYWN0X19kZWZhdWx0LnVzZUVmZmVjdCgoKT0+e1xuICAgICAgICBpZiAoaGFzU25hcFBvaW50cykge1xuICAgICAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKT0+e1xuICAgICAgICAgICAgICAgIHNldERlbGF5ZWRTbmFwUG9pbnRzKHRydWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LCBbXSk7XG4gICAgZnVuY3Rpb24gaGFuZGxlT25Qb2ludGVyVXAoZXZlbnQpIHtcbiAgICAgICAgcG9pbnRlclN0YXJ0UmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICB3YXNCZXlvbmRUaGVQb2ludFJlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgIG9uUmVsZWFzZShldmVudCk7XG4gICAgfVxuICAgIHJldHVybiAvKiNfX1BVUkVfXyovIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoRGlhbG9nUHJpbWl0aXZlLkNvbnRlbnQsIHtcbiAgICAgICAgXCJkYXRhLXZhdWwtZHJhd2VyLWRpcmVjdGlvblwiOiBkaXJlY3Rpb24sXG4gICAgICAgIFwiZGF0YS12YXVsLWRyYXdlclwiOiBcIlwiLFxuICAgICAgICBcImRhdGEtdmF1bC1kZWxheWVkLXNuYXAtcG9pbnRzXCI6IGRlbGF5ZWRTbmFwUG9pbnRzID8gJ3RydWUnIDogJ2ZhbHNlJyxcbiAgICAgICAgXCJkYXRhLXZhdWwtc25hcC1wb2ludHNcIjogaXNPcGVuICYmIGhhc1NuYXBQb2ludHMgPyAndHJ1ZScgOiAnZmFsc2UnLFxuICAgICAgICBcImRhdGEtdmF1bC1jdXN0b20tY29udGFpbmVyXCI6IGNvbnRhaW5lciA/ICd0cnVlJyA6ICdmYWxzZScsXG4gICAgICAgIFwiZGF0YS12YXVsLWFuaW1hdGVcIjogKHNob3VsZEFuaW1hdGUgPT0gbnVsbCA/IHZvaWQgMCA6IHNob3VsZEFuaW1hdGUuY3VycmVudCkgPyAndHJ1ZScgOiAnZmFsc2UnLFxuICAgICAgICAuLi5yZXN0LFxuICAgICAgICByZWY6IGNvbXBvc2VkUmVmLFxuICAgICAgICBzdHlsZTogc25hcFBvaW50c09mZnNldCAmJiBzbmFwUG9pbnRzT2Zmc2V0Lmxlbmd0aCA+IDAgPyB7XG4gICAgICAgICAgICAnLS1zbmFwLXBvaW50LWhlaWdodCc6IGAke3NuYXBQb2ludHNPZmZzZXRbYWN0aXZlU25hcFBvaW50SW5kZXggIT0gbnVsbCA/IGFjdGl2ZVNuYXBQb2ludEluZGV4IDogMF19cHhgLFxuICAgICAgICAgICAgLi4uc3R5bGVcbiAgICAgICAgfSA6IHN0eWxlLFxuICAgICAgICBvblBvaW50ZXJEb3duOiAoZXZlbnQpPT57XG4gICAgICAgICAgICBpZiAoaGFuZGxlT25seSkgcmV0dXJuO1xuICAgICAgICAgICAgcmVzdC5vblBvaW50ZXJEb3duID09IG51bGwgPyB2b2lkIDAgOiByZXN0Lm9uUG9pbnRlckRvd24uY2FsbChyZXN0LCBldmVudCk7XG4gICAgICAgICAgICBwb2ludGVyU3RhcnRSZWYuY3VycmVudCA9IHtcbiAgICAgICAgICAgICAgICB4OiBldmVudC5wYWdlWCxcbiAgICAgICAgICAgICAgICB5OiBldmVudC5wYWdlWVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIG9uUHJlc3MoZXZlbnQpO1xuICAgICAgICB9LFxuICAgICAgICBvbk9wZW5BdXRvRm9jdXM6IChlKT0+e1xuICAgICAgICAgICAgb25PcGVuQXV0b0ZvY3VzID09IG51bGwgPyB2b2lkIDAgOiBvbk9wZW5BdXRvRm9jdXMoZSk7XG4gICAgICAgICAgICBpZiAoIWF1dG9Gb2N1cykge1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgb25Qb2ludGVyRG93bk91dHNpZGU6IChlKT0+e1xuICAgICAgICAgICAgb25Qb2ludGVyRG93bk91dHNpZGUgPT0gbnVsbCA/IHZvaWQgMCA6IG9uUG9pbnRlckRvd25PdXRzaWRlKGUpO1xuICAgICAgICAgICAgaWYgKCFtb2RhbCB8fCBlLmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGtleWJvYXJkSXNPcGVuLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICBrZXlib2FyZElzT3Blbi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG9uRm9jdXNPdXRzaWRlOiAoZSk9PntcbiAgICAgICAgICAgIGlmICghbW9kYWwpIHtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBvblBvaW50ZXJNb3ZlOiAoZXZlbnQpPT57XG4gICAgICAgICAgICBsYXN0S25vd25Qb2ludGVyRXZlbnRSZWYuY3VycmVudCA9IGV2ZW50O1xuICAgICAgICAgICAgaWYgKGhhbmRsZU9ubHkpIHJldHVybjtcbiAgICAgICAgICAgIHJlc3Qub25Qb2ludGVyTW92ZSA9PSBudWxsID8gdm9pZCAwIDogcmVzdC5vblBvaW50ZXJNb3ZlLmNhbGwocmVzdCwgZXZlbnQpO1xuICAgICAgICAgICAgaWYgKCFwb2ludGVyU3RhcnRSZWYuY3VycmVudCkgcmV0dXJuO1xuICAgICAgICAgICAgY29uc3QgeVBvc2l0aW9uID0gZXZlbnQucGFnZVkgLSBwb2ludGVyU3RhcnRSZWYuY3VycmVudC55O1xuICAgICAgICAgICAgY29uc3QgeFBvc2l0aW9uID0gZXZlbnQucGFnZVggLSBwb2ludGVyU3RhcnRSZWYuY3VycmVudC54O1xuICAgICAgICAgICAgY29uc3Qgc3dpcGVTdGFydFRocmVzaG9sZCA9IGV2ZW50LnBvaW50ZXJUeXBlID09PSAndG91Y2gnID8gMTAgOiAyO1xuICAgICAgICAgICAgY29uc3QgZGVsdGEgPSB7XG4gICAgICAgICAgICAgICAgeDogeFBvc2l0aW9uLFxuICAgICAgICAgICAgICAgIHk6IHlQb3NpdGlvblxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IGlzQWxsb3dlZFRvU3dpcGUgPSBpc0RlbHRhSW5EaXJlY3Rpb24oZGVsdGEsIGRpcmVjdGlvbiwgc3dpcGVTdGFydFRocmVzaG9sZCk7XG4gICAgICAgICAgICBpZiAoaXNBbGxvd2VkVG9Td2lwZSkgb25EcmFnKGV2ZW50KTtcbiAgICAgICAgICAgIGVsc2UgaWYgKE1hdGguYWJzKHhQb3NpdGlvbikgPiBzd2lwZVN0YXJ0VGhyZXNob2xkIHx8IE1hdGguYWJzKHlQb3NpdGlvbikgPiBzd2lwZVN0YXJ0VGhyZXNob2xkKSB7XG4gICAgICAgICAgICAgICAgcG9pbnRlclN0YXJ0UmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBvblBvaW50ZXJVcDogKGV2ZW50KT0+e1xuICAgICAgICAgICAgcmVzdC5vblBvaW50ZXJVcCA9PSBudWxsID8gdm9pZCAwIDogcmVzdC5vblBvaW50ZXJVcC5jYWxsKHJlc3QsIGV2ZW50KTtcbiAgICAgICAgICAgIHBvaW50ZXJTdGFydFJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgICAgIHdhc0JleW9uZFRoZVBvaW50UmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgICAgIG9uUmVsZWFzZShldmVudCk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uUG9pbnRlck91dDogKGV2ZW50KT0+e1xuICAgICAgICAgICAgcmVzdC5vblBvaW50ZXJPdXQgPT0gbnVsbCA/IHZvaWQgMCA6IHJlc3Qub25Qb2ludGVyT3V0LmNhbGwocmVzdCwgZXZlbnQpO1xuICAgICAgICAgICAgaGFuZGxlT25Qb2ludGVyVXAobGFzdEtub3duUG9pbnRlckV2ZW50UmVmLmN1cnJlbnQpO1xuICAgICAgICB9LFxuICAgICAgICBvbkNvbnRleHRNZW51OiAoZXZlbnQpPT57XG4gICAgICAgICAgICByZXN0Lm9uQ29udGV4dE1lbnUgPT0gbnVsbCA/IHZvaWQgMCA6IHJlc3Qub25Db250ZXh0TWVudS5jYWxsKHJlc3QsIGV2ZW50KTtcbiAgICAgICAgICAgIGlmIChsYXN0S25vd25Qb2ludGVyRXZlbnRSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgICAgIGhhbmRsZU9uUG9pbnRlclVwKGxhc3RLbm93blBvaW50ZXJFdmVudFJlZi5jdXJyZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xufSk7XG5Db250ZW50LmRpc3BsYXlOYW1lID0gJ0RyYXdlci5Db250ZW50JztcbmNvbnN0IExPTkdfSEFORExFX1BSRVNTX1RJTUVPVVQgPSAyNTA7XG5jb25zdCBET1VCTEVfVEFQX1RJTUVPVVQgPSAxMjA7XG5jb25zdCBIYW5kbGUgPSAvKiNfX1BVUkVfXyovIFJlYWN0X19kZWZhdWx0LmZvcndhcmRSZWYoZnVuY3Rpb24oeyBwcmV2ZW50Q3ljbGUgPSBmYWxzZSwgY2hpbGRyZW4sIC4uLnJlc3QgfSwgcmVmKSB7XG4gICAgY29uc3QgeyBjbG9zZURyYXdlciwgaXNEcmFnZ2luZywgc25hcFBvaW50cywgYWN0aXZlU25hcFBvaW50LCBzZXRBY3RpdmVTbmFwUG9pbnQsIGRpc21pc3NpYmxlLCBoYW5kbGVPbmx5LCBpc09wZW4sIG9uUHJlc3MsIG9uRHJhZyB9ID0gdXNlRHJhd2VyQ29udGV4dCgpO1xuICAgIGNvbnN0IGNsb3NlVGltZW91dElkUmVmID0gUmVhY3RfX2RlZmF1bHQudXNlUmVmKG51bGwpO1xuICAgIGNvbnN0IHNob3VsZENhbmNlbEludGVyYWN0aW9uUmVmID0gUmVhY3RfX2RlZmF1bHQudXNlUmVmKGZhbHNlKTtcbiAgICBmdW5jdGlvbiBoYW5kbGVTdGFydEN5Y2xlKCkge1xuICAgICAgICAvLyBTdG9wIGlmIHRoaXMgaXMgdGhlIHNlY29uZCBjbGljayBvZiBhIGRvdWJsZSBjbGlja1xuICAgICAgICBpZiAoc2hvdWxkQ2FuY2VsSW50ZXJhY3Rpb25SZWYuY3VycmVudCkge1xuICAgICAgICAgICAgaGFuZGxlQ2FuY2VsSW50ZXJhY3Rpb24oKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB3aW5kb3cuc2V0VGltZW91dCgoKT0+e1xuICAgICAgICAgICAgaGFuZGxlQ3ljbGVTbmFwUG9pbnRzKCk7XG4gICAgICAgIH0sIERPVUJMRV9UQVBfVElNRU9VVCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhbmRsZUN5Y2xlU25hcFBvaW50cygpIHtcbiAgICAgICAgLy8gUHJldmVudCBhY2NpZGVudGFsIHRhcHMgd2hpbGUgcmVzaXppbmcgZHJhd2VyXG4gICAgICAgIGlmIChpc0RyYWdnaW5nIHx8IHByZXZlbnRDeWNsZSB8fCBzaG91bGRDYW5jZWxJbnRlcmFjdGlvblJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICBoYW5kbGVDYW5jZWxJbnRlcmFjdGlvbigpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0byBjbGVhciB0aGUgdGltZW91dCBpZCBpZiB0aGUgdXNlciByZWxlYXNlcyB0aGUgaGFuZGxlIGJlZm9yZSB0aGUgY2FuY2VsIHRpbWVvdXRcbiAgICAgICAgaGFuZGxlQ2FuY2VsSW50ZXJhY3Rpb24oKTtcbiAgICAgICAgaWYgKCFzbmFwUG9pbnRzIHx8IHNuYXBQb2ludHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBpZiAoIWRpc21pc3NpYmxlKSB7XG4gICAgICAgICAgICAgICAgY2xvc2VEcmF3ZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpc0xhc3RTbmFwUG9pbnQgPSBhY3RpdmVTbmFwUG9pbnQgPT09IHNuYXBQb2ludHNbc25hcFBvaW50cy5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKGlzTGFzdFNuYXBQb2ludCAmJiBkaXNtaXNzaWJsZSkge1xuICAgICAgICAgICAgY2xvc2VEcmF3ZXIoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjdXJyZW50U25hcEluZGV4ID0gc25hcFBvaW50cy5maW5kSW5kZXgoKHBvaW50KT0+cG9pbnQgPT09IGFjdGl2ZVNuYXBQb2ludCk7XG4gICAgICAgIGlmIChjdXJyZW50U25hcEluZGV4ID09PSAtMSkgcmV0dXJuOyAvLyBhY3RpdmVTbmFwUG9pbnQgbm90IGZvdW5kIGluIHNuYXBQb2ludHNcbiAgICAgICAgY29uc3QgbmV4dFNuYXBQb2ludCA9IHNuYXBQb2ludHNbY3VycmVudFNuYXBJbmRleCArIDFdO1xuICAgICAgICBzZXRBY3RpdmVTbmFwUG9pbnQobmV4dFNuYXBQb2ludCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhbmRsZVN0YXJ0SW50ZXJhY3Rpb24oKSB7XG4gICAgICAgIGNsb3NlVGltZW91dElkUmVmLmN1cnJlbnQgPSB3aW5kb3cuc2V0VGltZW91dCgoKT0+e1xuICAgICAgICAgICAgLy8gQ2FuY2VsIGNsaWNrIGludGVyYWN0aW9uIG9uIGEgbG9uZyBwcmVzc1xuICAgICAgICAgICAgc2hvdWxkQ2FuY2VsSW50ZXJhY3Rpb25SZWYuY3VycmVudCA9IHRydWU7XG4gICAgICAgIH0sIExPTkdfSEFORExFX1BSRVNTX1RJTUVPVVQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBoYW5kbGVDYW5jZWxJbnRlcmFjdGlvbigpIHtcbiAgICAgICAgaWYgKGNsb3NlVGltZW91dElkUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQoY2xvc2VUaW1lb3V0SWRSZWYuY3VycmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgc2hvdWxkQ2FuY2VsSW50ZXJhY3Rpb25SZWYuY3VycmVudCA9IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gLyojX19QVVJFX18qLyBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgICAgb25DbGljazogaGFuZGxlU3RhcnRDeWNsZSxcbiAgICAgICAgb25Qb2ludGVyQ2FuY2VsOiBoYW5kbGVDYW5jZWxJbnRlcmFjdGlvbixcbiAgICAgICAgb25Qb2ludGVyRG93bjogKGUpPT57XG4gICAgICAgICAgICBpZiAoaGFuZGxlT25seSkgb25QcmVzcyhlKTtcbiAgICAgICAgICAgIGhhbmRsZVN0YXJ0SW50ZXJhY3Rpb24oKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25Qb2ludGVyTW92ZTogKGUpPT57XG4gICAgICAgICAgICBpZiAoaGFuZGxlT25seSkgb25EcmFnKGUpO1xuICAgICAgICB9LFxuICAgICAgICAvLyBvblBvaW50ZXJVcCBpcyBhbHJlYWR5IGhhbmRsZWQgYnkgdGhlIGNvbnRlbnQgY29tcG9uZW50XG4gICAgICAgIHJlZjogcmVmLFxuICAgICAgICBcImRhdGEtdmF1bC1kcmF3ZXItdmlzaWJsZVwiOiBpc09wZW4gPyAndHJ1ZScgOiAnZmFsc2UnLFxuICAgICAgICBcImRhdGEtdmF1bC1oYW5kbGVcIjogXCJcIixcbiAgICAgICAgXCJhcmlhLWhpZGRlblwiOiBcInRydWVcIixcbiAgICAgICAgLi4ucmVzdFxuICAgIH0sIC8qI19fUFVSRV9fKi8gUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcInNwYW5cIiwge1xuICAgICAgICBcImRhdGEtdmF1bC1oYW5kbGUtaGl0YXJlYVwiOiBcIlwiLFxuICAgICAgICBcImFyaWEtaGlkZGVuXCI6IFwidHJ1ZVwiXG4gICAgfSwgY2hpbGRyZW4pKTtcbn0pO1xuSGFuZGxlLmRpc3BsYXlOYW1lID0gJ0RyYXdlci5IYW5kbGUnO1xuZnVuY3Rpb24gTmVzdGVkUm9vdCh7IG9uRHJhZywgb25PcGVuQ2hhbmdlLCBvcGVuOiBuZXN0ZWRJc09wZW4sIC4uLnJlc3QgfSkge1xuICAgIGNvbnN0IHsgb25OZXN0ZWREcmFnLCBvbk5lc3RlZE9wZW5DaGFuZ2UsIG9uTmVzdGVkUmVsZWFzZSB9ID0gdXNlRHJhd2VyQ29udGV4dCgpO1xuICAgIGlmICghb25OZXN0ZWREcmFnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRHJhd2VyLk5lc3RlZFJvb3QgbXVzdCBiZSBwbGFjZWQgaW4gYW5vdGhlciBkcmF3ZXInKTtcbiAgICB9XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChSb290LCB7XG4gICAgICAgIG5lc3RlZDogdHJ1ZSxcbiAgICAgICAgb3BlbjogbmVzdGVkSXNPcGVuLFxuICAgICAgICBvbkNsb3NlOiAoKT0+e1xuICAgICAgICAgICAgb25OZXN0ZWRPcGVuQ2hhbmdlKGZhbHNlKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25EcmFnOiAoZSwgcCk9PntcbiAgICAgICAgICAgIG9uTmVzdGVkRHJhZyhlLCBwKTtcbiAgICAgICAgICAgIG9uRHJhZyA9PSBudWxsID8gdm9pZCAwIDogb25EcmFnKGUsIHApO1xuICAgICAgICB9LFxuICAgICAgICBvbk9wZW5DaGFuZ2U6IChvKT0+e1xuICAgICAgICAgICAgaWYgKG8pIHtcbiAgICAgICAgICAgICAgICBvbk5lc3RlZE9wZW5DaGFuZ2Uobyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvbk9wZW5DaGFuZ2UgPT0gbnVsbCA/IHZvaWQgMCA6IG9uT3BlbkNoYW5nZShvKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25SZWxlYXNlOiBvbk5lc3RlZFJlbGVhc2UsXG4gICAgICAgIC4uLnJlc3RcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIFBvcnRhbChwcm9wcykge1xuICAgIGNvbnN0IGNvbnRleHQgPSB1c2VEcmF3ZXJDb250ZXh0KCk7XG4gICAgY29uc3QgeyBjb250YWluZXIgPSBjb250ZXh0LmNvbnRhaW5lciwgLi4ucG9ydGFsUHJvcHMgfSA9IHByb3BzO1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoRGlhbG9nUHJpbWl0aXZlLlBvcnRhbCwge1xuICAgICAgICBjb250YWluZXI6IGNvbnRhaW5lcixcbiAgICAgICAgLi4ucG9ydGFsUHJvcHNcbiAgICB9KTtcbn1cbmNvbnN0IERyYXdlciA9IHtcbiAgICBSb290LFxuICAgIE5lc3RlZFJvb3QsXG4gICAgQ29udGVudCxcbiAgICBPdmVybGF5LFxuICAgIFRyaWdnZXI6IERpYWxvZ1ByaW1pdGl2ZS5UcmlnZ2VyLFxuICAgIFBvcnRhbCxcbiAgICBIYW5kbGUsXG4gICAgQ2xvc2U6IERpYWxvZ1ByaW1pdGl2ZS5DbG9zZSxcbiAgICBUaXRsZTogRGlhbG9nUHJpbWl0aXZlLlRpdGxlLFxuICAgIERlc2NyaXB0aW9uOiBEaWFsb2dQcmltaXRpdmUuRGVzY3JpcHRpb25cbn07XG5cbmV4cG9ydCB7IENvbnRlbnQsIERyYXdlciwgSGFuZGxlLCBOZXN0ZWRSb290LCBPdmVybGF5LCBQb3J0YWwsIFJvb3QgfTtcbiJdLCJuYW1lcyI6WyJfX2luc2VydENTUyIsImNvZGUiLCJkb2N1bWVudCIsImhlYWQiLCJnZXRFbGVtZW50c0J5VGFnTmFtZSIsInN0eWxlIiwiY3JlYXRlRWxlbWVudCIsInR5cGUiLCJhcHBlbmRDaGlsZCIsInN0eWxlU2hlZXQiLCJjc3NUZXh0IiwiY3JlYXRlVGV4dE5vZGUiLCJEaWFsb2dQcmltaXRpdmUiLCJSZWFjdCIsIlJlYWN0X19kZWZhdWx0IiwidXNlTGF5b3V0RWZmZWN0IiwidXNlRWZmZWN0IiwidXNlTWVtbyIsIkRyYXdlckNvbnRleHQiLCJjcmVhdGVDb250ZXh0IiwiZHJhd2VyUmVmIiwiY3VycmVudCIsIm92ZXJsYXlSZWYiLCJvblByZXNzIiwib25SZWxlYXNlIiwib25EcmFnIiwib25OZXN0ZWREcmFnIiwib25OZXN0ZWRPcGVuQ2hhbmdlIiwib25OZXN0ZWRSZWxlYXNlIiwib3BlblByb3AiLCJ1bmRlZmluZWQiLCJkaXNtaXNzaWJsZSIsImlzT3BlbiIsImlzRHJhZ2dpbmciLCJrZXlib2FyZElzT3BlbiIsInNuYXBQb2ludHNPZmZzZXQiLCJzbmFwUG9pbnRzIiwiaGFuZGxlT25seSIsIm1vZGFsIiwic2hvdWxkRmFkZSIsImFjdGl2ZVNuYXBQb2ludCIsIm9uT3BlbkNoYW5nZSIsInNldEFjdGl2ZVNuYXBQb2ludCIsImNsb3NlRHJhd2VyIiwiZGlyZWN0aW9uIiwic2hvdWxkQW5pbWF0ZSIsInNob3VsZFNjYWxlQmFja2dyb3VuZCIsInNldEJhY2tncm91bmRDb2xvck9uU2NhbGUiLCJub0JvZHlTdHlsZXMiLCJjb250YWluZXIiLCJhdXRvRm9jdXMiLCJ1c2VEcmF3ZXJDb250ZXh0IiwiY29udGV4dCIsInVzZUNvbnRleHQiLCJFcnJvciIsImlzTW9iaWxlRmlyZWZveCIsInVzZXJBZ2VudCIsIm5hdmlnYXRvciIsInRlc3QiLCJpc01hYyIsInRlc3RQbGF0Zm9ybSIsImlzSVBob25lIiwiaXNTYWZhcmkiLCJpc0lQYWQiLCJtYXhUb3VjaFBvaW50cyIsImlzSU9TIiwicmUiLCJ3aW5kb3ciLCJwbGF0Zm9ybSIsIktFWUJPQVJEX0JVRkZFUiIsInVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QiLCJjaGFpbiQxIiwiY2FsbGJhY2tzIiwiYXJncyIsImNhbGxiYWNrIiwidmlzdWFsVmlld3BvcnQiLCJpc1Njcm9sbGFibGUiLCJub2RlIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsIm92ZXJmbG93Iiwib3ZlcmZsb3dYIiwib3ZlcmZsb3dZIiwiZ2V0U2Nyb2xsUGFyZW50IiwicGFyZW50RWxlbWVudCIsInNjcm9sbGluZ0VsZW1lbnQiLCJkb2N1bWVudEVsZW1lbnQiLCJub25UZXh0SW5wdXRUeXBlcyIsIlNldCIsInByZXZlbnRTY3JvbGxDb3VudCIsInJlc3RvcmUiLCJ1c2VQcmV2ZW50U2Nyb2xsIiwib3B0aW9ucyIsImlzRGlzYWJsZWQiLCJwcmV2ZW50U2Nyb2xsTW9iaWxlU2FmYXJpIiwic2Nyb2xsYWJsZSIsImxhc3RZIiwib25Ub3VjaFN0YXJ0IiwiZSIsInRhcmdldCIsImJvZHkiLCJjaGFuZ2VkVG91Y2hlcyIsInBhZ2VZIiwib25Ub3VjaE1vdmUiLCJwcmV2ZW50RGVmYXVsdCIsInkiLCJzY3JvbGxUb3AiLCJib3R0b20iLCJzY3JvbGxIZWlnaHQiLCJjbGllbnRIZWlnaHQiLCJvblRvdWNoRW5kIiwiaXNJbnB1dCIsImFjdGl2ZUVsZW1lbnQiLCJ0cmFuc2Zvcm0iLCJmb2N1cyIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsIm9uRm9jdXMiLCJoZWlnaHQiLCJpbm5lckhlaWdodCIsInNjcm9sbEludG9WaWV3IiwiYWRkRXZlbnRMaXN0ZW5lciIsIm9uY2UiLCJvbldpbmRvd1Njcm9sbCIsInNjcm9sbFRvIiwic2Nyb2xsWCIsInBhZ2VYT2Zmc2V0Iiwic2Nyb2xsWSIsInBhZ2VZT2Zmc2V0IiwicmVzdG9yZVN0eWxlcyIsInNldFN0eWxlIiwiaW5uZXJXaWR0aCIsImNsaWVudFdpZHRoIiwicmVtb3ZlRXZlbnRzIiwiYWRkRXZlbnQiLCJwYXNzaXZlIiwiY2FwdHVyZSIsImVsZW1lbnQiLCJ2YWx1ZSIsImN1ciIsImV2ZW50IiwiaGFuZGxlciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJyb290Iiwic2Nyb2xsYWJsZVRvcCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsInRvcCIsInRhcmdldFRvcCIsInRhcmdldEJvdHRvbSIsImtleWJvYXJkSGVpZ2h0IiwiSFRNTElucHV0RWxlbWVudCIsImhhcyIsIkhUTUxUZXh0QXJlYUVsZW1lbnQiLCJIVE1MRWxlbWVudCIsImlzQ29udGVudEVkaXRhYmxlIiwic2V0UmVmIiwicmVmIiwiY29tcG9zZVJlZnMiLCJyZWZzIiwiZm9yRWFjaCIsInVzZUNvbXBvc2VkUmVmcyIsInVzZUNhbGxiYWNrIiwiY2FjaGUiLCJXZWFrTWFwIiwic2V0IiwiZWwiLCJzdHlsZXMiLCJpZ25vcmVDYWNoZSIsIm9yaWdpbmFsU3R5bGVzIiwiT2JqZWN0IiwiZW50cmllcyIsImtleSIsInN0YXJ0c1dpdGgiLCJzZXRQcm9wZXJ0eSIsInJlc2V0IiwicHJvcCIsImdldCIsImlzVmVydGljYWwiLCJnZXRUcmFuc2xhdGUiLCJ3ZWJraXRUcmFuc2Zvcm0iLCJtb3pUcmFuc2Zvcm0iLCJtYXQiLCJtYXRjaCIsInBhcnNlRmxvYXQiLCJzcGxpdCIsImRhbXBlblZhbHVlIiwidiIsIk1hdGgiLCJsb2ciLCJhc3NpZ25TdHlsZSIsInByZXZTdHlsZSIsImFzc2lnbiIsImNoYWluIiwiZm5zIiwiZm4iLCJUUkFOU0lUSU9OUyIsIkRVUkFUSU9OIiwiRUFTRSIsIlZFTE9DSVRZX1RIUkVTSE9MRCIsIkNMT1NFX1RIUkVTSE9MRCIsIlNDUk9MTF9MT0NLX1RJTUVPVVQiLCJCT1JERVJfUkFESVVTIiwiTkVTVEVEX0RJU1BMQUNFTUVOVCIsIldJTkRPV19UT1BfT0ZGU0VUIiwiRFJBR19DTEFTUyIsInVzZUNhbGxiYWNrUmVmIiwiY2FsbGJhY2tSZWYiLCJ1c2VSZWYiLCJjYWxsIiwidXNlVW5jb250cm9sbGVkU3RhdGUiLCJkZWZhdWx0UHJvcCIsIm9uQ2hhbmdlIiwidW5jb250cm9sbGVkU3RhdGUiLCJ1c2VTdGF0ZSIsInByZXZWYWx1ZVJlZiIsImhhbmRsZUNoYW5nZSIsInVzZUNvbnRyb2xsYWJsZVN0YXRlIiwidW5jb250cm9sbGVkUHJvcCIsInNldFVuY29udHJvbGxlZFByb3AiLCJpc0NvbnRyb2xsZWQiLCJzZXRWYWx1ZSIsIm5leHRWYWx1ZSIsInNldHRlciIsInVzZVNuYXBQb2ludHMiLCJhY3RpdmVTbmFwUG9pbnRQcm9wIiwic2V0QWN0aXZlU25hcFBvaW50UHJvcCIsImZhZGVGcm9tSW5kZXgiLCJvblNuYXBQb2ludENoYW5nZSIsInNuYXBUb1NlcXVlbnRpYWxQb2ludCIsIndpbmRvd0RpbWVuc2lvbnMiLCJzZXRXaW5kb3dEaW1lbnNpb25zIiwib25SZXNpemUiLCJpc0xhc3RTbmFwUG9pbnQiLCJsZW5ndGgiLCJhY3RpdmVTbmFwUG9pbnRJbmRleCIsIl9zbmFwUG9pbnRzX2ZpbmRJbmRleCIsImZpbmRJbmRleCIsInNuYXBQb2ludCIsIk51bWJlciIsImlzTmFOIiwiY29udGFpbmVyU2l6ZSIsIndpZHRoIiwiX3NuYXBQb2ludHNfbWFwIiwibWFwIiwiaXNQeCIsInNuYXBQb2ludEFzTnVtYmVyIiwicGFyc2VJbnQiLCJhY3RpdmVTbmFwUG9pbnRPZmZzZXQiLCJzbmFwVG9Qb2ludCIsImRpbWVuc2lvbiIsIl9zbmFwUG9pbnRzT2Zmc2V0X2ZpbmRJbmRleCIsIm5ld1NuYXBQb2ludEluZGV4Iiwic25hcFBvaW50RGltIiwidHJhbnNpdGlvbiIsImpvaW4iLCJvcGFjaXR5IiwibWF4IiwibmV3SW5kZXgiLCJkcmFnZ2VkRGlzdGFuY2UiLCJ2ZWxvY2l0eSIsImN1cnJlbnRQb3NpdGlvbiIsImlzT3ZlcmxheVNuYXBQb2ludCIsImlzRmlyc3QiLCJoYXNEcmFnZ2VkVXAiLCJjbG9zZXN0U25hcFBvaW50IiwicmVkdWNlIiwicHJldiIsImN1cnIiLCJhYnMiLCJkaW0iLCJkcmFnRGlyZWN0aW9uIiwibmV3VmFsdWUiLCJnZXRQZXJjZW50YWdlRHJhZ2dlZCIsImFic0RyYWdnZWREaXN0YW5jZSIsImlzRHJhZ2dpbmdEb3duIiwiaXNPdmVybGF5U25hcFBvaW50T3JIaWdoZXIiLCJ0YXJnZXRTbmFwUG9pbnRJbmRleCIsInNuYXBQb2ludERpc3RhbmNlIiwicGVyY2VudGFnZURyYWdnZWQiLCJub29wIiwidXNlU2NhbGVCYWNrZ3JvdW5kIiwidGltZW91dElkUmVmIiwiaW5pdGlhbEJhY2tncm91bmRDb2xvciIsImJhY2tncm91bmRDb2xvciIsImdldFNjYWxlIiwiY2xlYXJUaW1lb3V0Iiwid3JhcHBlciIsInF1ZXJ5U2VsZWN0b3IiLCJiYWNrZ3JvdW5kIiwidHJhbnNmb3JtT3JpZ2luIiwidHJhbnNpdGlvblByb3BlcnR5IiwidHJhbnNpdGlvbkR1cmF0aW9uIiwidHJhbnNpdGlvblRpbWluZ0Z1bmN0aW9uIiwid3JhcHBlclN0eWxlc0NsZWFudXAiLCJib3JkZXJSYWRpdXMiLCJzZXRUaW1lb3V0IiwicmVtb3ZlUHJvcGVydHkiLCJwcmV2aW91c0JvZHlQb3NpdGlvbiIsInVzZVBvc2l0aW9uRml4ZWQiLCJuZXN0ZWQiLCJoYXNCZWVuT3BlbmVkIiwicHJldmVudFNjcm9sbFJlc3RvcmF0aW9uIiwiYWN0aXZlVXJsIiwic2V0QWN0aXZlVXJsIiwibG9jYXRpb24iLCJocmVmIiwic2Nyb2xsUG9zIiwic2V0UG9zaXRpb25GaXhlZCIsInBvc2l0aW9uIiwibGVmdCIsInJpZ2h0IiwiYm90dG9tQmFySGVpZ2h0IiwicmVzdG9yZVBvc2l0aW9uU2V0dGluZyIsIngiLCJvblNjcm9sbCIsImhhc0RyYXdlck9wZW5lZCIsImlzU3RhbmRhbG9uZSIsIm1hdGNoTWVkaWEiLCJtYXRjaGVzIiwiUm9vdCIsIm9wZW4iLCJjaGlsZHJlbiIsIm9uRHJhZ1Byb3AiLCJvblJlbGVhc2VQcm9wIiwiY2xvc2VUaHJlc2hvbGQiLCJzY3JvbGxMb2NrVGltZW91dCIsImZpeGVkIiwib25DbG9zZSIsImRlZmF1bHRPcGVuIiwiZGlzYWJsZVByZXZlbnRTY3JvbGwiLCJyZXBvc2l0aW9uSW5wdXRzIiwib25BbmltYXRpb25FbmQiLCJfZHJhd2VyUmVmX2N1cnJlbnQiLCJfZHJhd2VyUmVmX2N1cnJlbnQxIiwic2V0SXNPcGVuIiwibyIsInBvaW50ZXJFdmVudHMiLCJzZXRIYXNCZWVuT3BlbmVkIiwic2V0SXNEcmFnZ2luZyIsImp1c3RSZWxlYXNlZCIsInNldEp1c3RSZWxlYXNlZCIsIm9wZW5UaW1lIiwiZHJhZ1N0YXJ0VGltZSIsImRyYWdFbmRUaW1lIiwibGFzdFRpbWVEcmFnUHJldmVudGVkIiwiaXNBbGxvd2VkVG9EcmFnIiwibmVzdGVkT3BlbkNoYW5nZVRpbWVyIiwicG9pbnRlclN0YXJ0IiwicHJldmlvdXNEaWZmRnJvbUluaXRpYWwiLCJkcmF3ZXJIZWlnaHRSZWYiLCJkcmF3ZXJXaWR0aFJlZiIsImluaXRpYWxEcmF3ZXJIZWlnaHQiLCJEYXRlIiwib25SZWxlYXNlU25hcFBvaW50cyIsIm9uRHJhZ1NuYXBQb2ludHMiLCJnZXRTbmFwUG9pbnRzUGVyY2VudGFnZURyYWdnZWQiLCJjb250YWlucyIsInNldFBvaW50ZXJDYXB0dXJlIiwicG9pbnRlcklkIiwicGFnZVgiLCJzaG91bGREcmFnIiwiaXNEcmFnZ2luZ0luRGlyZWN0aW9uIiwiX3dpbmRvd19nZXRTZWxlY3Rpb24iLCJoaWdobGlnaHRlZFRleHQiLCJnZXRTZWxlY3Rpb24iLCJ0b1N0cmluZyIsInN3aXBlQW1vdW50IiwiZGF0ZSIsInRhZ05hbWUiLCJoYXNBdHRyaWJ1dGUiLCJjbG9zZXN0IiwiZ2V0VGltZSIsImdldEF0dHJpYnV0ZSIsInBhcmVudE5vZGUiLCJkaXJlY3Rpb25NdWx0aXBsaWVyIiwibm9DbG9zZVNuYXBQb2ludHNQcmVDb25kaXRpb24iLCJkcmF3ZXJEaW1lbnNpb24iLCJzbmFwUG9pbnRQZXJjZW50YWdlRHJhZ2dlZCIsImNsYXNzTGlzdCIsImFkZCIsImRhbXBlbmVkRHJhZ2dlZERpc3RhbmNlIiwidHJhbnNsYXRlVmFsdWUiLCJtaW4iLCJvcGFjaXR5VmFsdWUiLCJzY2FsZVZhbHVlIiwiYm9yZGVyUmFkaXVzVmFsdWUiLCJfd2luZG93X3Zpc3VhbFZpZXdwb3J0Iiwib25WaXN1YWxWaWV3cG9ydENoYW5nZSIsImZvY3VzZWRFbGVtZW50IiwidmlzdWFsVmlld3BvcnRIZWlnaHQiLCJ0b3RhbEhlaWdodCIsImRpZmZGcm9tSW5pdGlhbCIsImRyYXdlckhlaWdodCIsImlzVGFsbEVub3VnaCIsIm9mZnNldEZyb21Ub3AiLCJhY3RpdmVTbmFwUG9pbnRIZWlnaHQiLCJuZXdEcmF3ZXJIZWlnaHQiLCJmcm9tV2l0aGluIiwiY2FuY2VsRHJhZyIsInJlc2V0RHJhd2VyIiwiY3VycmVudFN3aXBlQW1vdW50IiwicmVtb3ZlIiwidGltZVRha2VuIiwiZGlzdE1vdmVkIiwiX2RyYXdlclJlZl9jdXJyZW50X2dldEJvdW5kaW5nQ2xpZW50UmVjdF9oZWlnaHQiLCJ2aXNpYmxlRHJhd2VySGVpZ2h0IiwiX2RyYXdlclJlZl9jdXJyZW50X2dldEJvdW5kaW5nQ2xpZW50UmVjdF93aWR0aCIsInZpc2libGVEcmF3ZXJXaWR0aCIsImlzSG9yaXpvbnRhbFN3aXBlIiwic2Nyb2xsQmVoYXZpb3IiLCJzY2FsZSIsImluaXRpYWxUcmFuc2xhdGUiLCJfZXZlbnQiLCJpbml0aWFsU2NhbGUiLCJuZXdTY2FsZSIsIm5ld1RyYW5zbGF0ZSIsInRyYW5zbGF0ZSIsIlByb3ZpZGVyIiwiT3ZlcmxheSIsImZvcndhcmRSZWYiLCJyZXN0IiwiY29tcG9zZWRSZWYiLCJoYXNTbmFwUG9pbnRzIiwib25Nb3VzZVVwIiwiZGlzcGxheU5hbWUiLCJDb250ZW50Iiwib25Qb2ludGVyRG93bk91dHNpZGUiLCJvbk9wZW5BdXRvRm9jdXMiLCJkZWxheWVkU25hcFBvaW50cyIsInNldERlbGF5ZWRTbmFwUG9pbnRzIiwicG9pbnRlclN0YXJ0UmVmIiwibGFzdEtub3duUG9pbnRlckV2ZW50UmVmIiwid2FzQmV5b25kVGhlUG9pbnRSZWYiLCJpc0RlbHRhSW5EaXJlY3Rpb24iLCJkZWx0YSIsInRocmVzaG9sZCIsImRlbHRhWSIsImRlbHRhWCIsImlzRGVsdGFYIiwiZEZhY3RvciIsImluY2x1ZGVzIiwiaXNSZXZlcnNlRGlyZWN0aW9uIiwiaGFuZGxlT25Qb2ludGVyVXAiLCJvblBvaW50ZXJEb3duIiwiZGVmYXVsdFByZXZlbnRlZCIsIm9uRm9jdXNPdXRzaWRlIiwib25Qb2ludGVyTW92ZSIsInlQb3NpdGlvbiIsInhQb3NpdGlvbiIsInN3aXBlU3RhcnRUaHJlc2hvbGQiLCJwb2ludGVyVHlwZSIsImlzQWxsb3dlZFRvU3dpcGUiLCJvblBvaW50ZXJVcCIsIm9uUG9pbnRlck91dCIsIm9uQ29udGV4dE1lbnUiLCJMT05HX0hBTkRMRV9QUkVTU19USU1FT1VUIiwiRE9VQkxFX1RBUF9USU1FT1VUIiwiSGFuZGxlIiwicHJldmVudEN5Y2xlIiwiY2xvc2VUaW1lb3V0SWRSZWYiLCJzaG91bGRDYW5jZWxJbnRlcmFjdGlvblJlZiIsImhhbmRsZVN0YXJ0Q3ljbGUiLCJoYW5kbGVDYW5jZWxJbnRlcmFjdGlvbiIsImhhbmRsZUN5Y2xlU25hcFBvaW50cyIsImN1cnJlbnRTbmFwSW5kZXgiLCJwb2ludCIsIm5leHRTbmFwUG9pbnQiLCJoYW5kbGVTdGFydEludGVyYWN0aW9uIiwib25DbGljayIsIm9uUG9pbnRlckNhbmNlbCIsIk5lc3RlZFJvb3QiLCJuZXN0ZWRJc09wZW4iLCJwIiwiUG9ydGFsIiwicHJvcHMiLCJwb3J0YWxQcm9wcyIsIkRyYXdlciIsIlRyaWdnZXIiLCJDbG9zZSIsIlRpdGxlIiwiRGVzY3JpcHRpb24iXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/vaul/dist/index.mjs\n");

/***/ })

};
;